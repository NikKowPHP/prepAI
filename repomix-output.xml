This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
__mocks__/
  route.ts
.roo/
  rules-architect/
    rules.md
  rules-developer/
    rules.md
  rules-emergency/
    rules.md
  rules-orchestrator/
    rules.md
  rules-product-manager/
    rules.md
  rules-qa-engineer/
    rules.md
  rules-system-supervisor/
    rules.md
  custom_modes.yaml
prisma/
  schema.prisma
public/
  file.svg
  globe.svg
  next.svg
  vercel.svg
  window.svg
src/
  app/
    api/
      generate-question/
        route.d.ts
        route.ts
      questions/
        route.d.ts
        route.test.ts
        route.ts
    login/
      page.tsx
    signup/
      page.tsx
    globals.css
    layout.tsx
    page.tsx
  lib/
    auth-context.ts
    auth-context.tsx
    db.ts
    supabase.ts
  middleware.ts
  providers.tsx
work_items/
  ticket.md
.gitignore
.prettierrc
app_description.md
database_schema.md
delete_assistance.sh
dev_todo_phase_1.md
dev_todo_phase_2.md
dev_todo_phase_3.md
dev_todo_phase_4.md
docker-compose.yml
Dockerfile
eslint.config.mjs
jest.config.js
jest.setup.ts
master_development_plan.md
next.config.ts
package.json
postcss.config.js
postcss.config.mjs
project_manifest.json
README.md
system_architecture.md
tailwind.config.js
tailwind.config.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="__mocks__/route.ts">
import { NextRequest, NextResponse } from 'next/server';

export function POST(req: NextRequest) {
  return NextResponse.json({
    id: '1',
    createdAt: new Date(),
    content: 'Test question',
    category: 'general',
    difficulty: 'easy',
    source: null,
    userId: 'temp-user-id'
  }, { status: 200 });
}
</file>

<file path=".roo/rules-product-manager/rules.md">
## 1. IDENTITY & PERSONA
You are the **Product Manager AI** (ðŸ“ˆ The Clarifier). You are the primary interpreter of the human's vision. Your purpose is to eliminate ambiguity by transforming a high-level description into a definitive, machine-readable specification.

## 2. THE CORE MISSION & TRIGGER
Your mission is to create the project's **source of truth**. You are triggered by the Orchestrator only when `/docs/app_description.md` exists, but `/docs/canonical_spec.md` does not.

## 3. THE CLARIFICATION WORKFLOW
1.  **Acknowledge & Log:** "New project vision detected. I will create the canonical specification."
2.  **Create Directories:** Ensure `/docs/` and `/signals/` exist.
3.  **Read and Deconstruct the Vision:**
    *   Read the full contents of `/docs/app_description.md`.
    *   Perform a semantic analysis to identify all features, user stories, requirements, and constraints.
4.  **Create Canonical Specification:**
    *   Create `/docs/canonical_spec.md`. This file must be a comprehensive, non-ambiguous document detailing the entire project. This is now the project's primary reference.
    *   Create a skeleton `/docs/README.md`.
5.  **Announce & Handoff:**
    *   Create the signal file `/signals/SPECIFICATION_COMPLETE.md`.
    *   Announce: "Canonical specification is complete. Handing off to the Architect for full-scale planning."
    *   Switch mode to `<mode>orchestrator</mode>`.
</file>

<file path="prisma/schema.prisma">
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  role      String   @default("user")
  
  questions Question[]
  responses Response[]
  srsData   SRSData[]
  readinessProfile ReadinessProfile?
}

model Question {
  id          String   @id @default(uuid())
  content     String
  category    String
  difficulty  String
  source      String?
  createdAt   DateTime @default(now())
  userId      String
  
  user       User      @relation(fields: [userId], references: [id])
  responses  Response[]
  srsData    SRSData[]
}

model Response {
  id          String   @id @default(uuid())
  userId      String
  questionId  String
  content     String
  isCorrect   Boolean?
  analysis    Json?
  createdAt   DateTime @default(now())
  
  user     User     @relation(fields: [userId], references: [id])
  question Question @relation(fields: [questionId], references: [id])
}

model SRSData {
  id           String   @id @default(uuid())
  userId       String
  questionId   String
  interval     Int      @default(1)
  repetitions  Int      @default(0)
  easeFactor   Float    @default(2.5)
  nextReview   DateTime
  stage        String   @default("learning")
  
  user     User     @relation(fields: [userId], references: [id])
  question Question @relation(fields: [questionId], references: [id])
}

model ReadinessProfile {
  id          String   @id @default(uuid())
  userId      String   @unique
  overallScore Float    @default(0.0)
  strengths    Json
  weaknesses  Json
  lastUpdated DateTime @default(now())
  
  user User @relation(fields: [userId], references: [id])
}
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="src/app/api/generate-question/route.d.ts">
import { NextRequest, NextResponse } from 'next/server';

declare module 'openai' {
  export default class OpenAI {
    constructor(options: { apiKey: string });

    completions: {
      create: (params: {
        model: string;
        prompt: string;
        max_tokens?: number;
        temperature?: number;
      }) => Promise<{
        choices: {
          text: string;
        }[];
      }>;
    };
  }
}

export function POST(req: NextRequest): Promise<NextResponse>;
</file>

<file path="src/app/api/generate-question/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { supabase } from '@/lib/supabase';
import OpenAI from 'openai';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function POST(req: NextRequest) {
  try {
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await req.json();
    if (!body || typeof body !== 'object') {
      return NextResponse.json({ error: 'Invalid request body' }, { status: 400 });
    }

    const { prompt, maxTokens = 150, temperature = 0.7 } = body;

    if (!prompt || typeof prompt !== 'string') {
      return NextResponse.json({ error: 'Prompt is required' }, { status: 400 });
    }

    const completion = await openai.completions.create({
      model: 'text-davinci-003',
      prompt: `Generate a question based on this prompt: ${prompt}`,
      max_tokens: maxTokens,
      temperature: temperature,
    });

    if (!completion.choices || completion.choices.length === 0) {
      return NextResponse.json({ error: 'Failed to generate question' }, { status: 500 });
    }

    const generatedQuestion = completion.choices[0].text.trim();

    return NextResponse.json({ question: generatedQuestion });
  } catch (error: unknown) {
    if (error instanceof Error) {
      console.error('Error generating question:', error.message);
    } else {
      console.error('Unknown error:', error);
    }
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
</file>

<file path="src/app/login/page.tsx">
'use client';

import { useAuth } from '@/lib/auth-context';
import { useRouter } from 'next/navigation';
import { useState } from 'react';

export default function LoginPage() {
  const { signIn } = useAuth();
  const router = useRouter();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await signIn(email, password);
      router.push('/');
    } catch (err) {
      setError('Failed to sign in. Please check your credentials.');
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full space-y-8 p-8 bg-white rounded-lg shadow-lg">
        <h2 className="text-3xl font-bold text-center text-gray-900">
          Sign in to your account
        </h2>
        {error && (
          <p className="text-red-500 text-sm text-center">{error}</p>
        )}
        <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-gray-700">
              Email address
            </label>
            <input
              id="email"
              name="email"
              type="email"
              required
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
            />
          </div>
          <div>
            <label htmlFor="password" className="block text-sm font-medium text-gray-700">
              Password
            </label>
            <input
              id="password"
              name="password"
              type="password"
              required
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
            />
          </div>
          <button
            type="submit"
            className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
            Sign in
          </button>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="src/app/signup/page.tsx">
'use client';

import { useAuth } from '@/lib/auth-context';
import { useRouter } from 'next/navigation';
import { useState } from 'react';

export default function SignupPage() {
  const { signUp } = useAuth();
  const router = useRouter();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await signUp(email, password);
      router.push('/');
    } catch {
      setError('Failed to create account. Please try again.');
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full space-y-8 p-8 bg-white rounded-lg shadow-lg">
        <h2 className="text-3xl font-bold text-center text-gray-900">
          Create a new account
        </h2>
        {error && (
          <p className="text-red-500 text-sm text-center">{error}</p>
        )}
        <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-gray-700">
              Email address
            </label>
            <input
              id="email"
              name="email"
              type="email"
              required
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
            />
          </div>
          <div>
            <label htmlFor="password" className="block text-sm font-medium text-gray-700">
              Password
            </label>
            <input
              id="password"
              name="password"
              type="password"
              required
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
            />
          </div>
          <button
            type="submit"
            className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
            Sign up
          </button>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="src/lib/auth-context.ts">
'use client';

import { createContext, useContext, useEffect, useState } from 'react';
import { createClient, Session, User } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
export const supabase = createClient(supabaseUrl, supabaseAnonKey);

interface AuthContextType {
  user: User | null;
  signIn: (email: string, password: string) => Promise<void>;
  signUp: (email: string, password: string) => Promise<void>;
  signOut: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    const getSession = async () => {
      const { data, error } = await supabase.auth.getSession();
      if (data?.session) {
        setUser(data.session.user);
      }
    };
    getSession();

    const { data: listener } = supabase.auth.onAuthStateChange((event, session) => {
      setUser(session?.user ?? null);
    });

    return () => {
      listener.subscription.unsubscribe();
    };
  }, []);

  const signIn = async (email: string, password: string) => {
    const { data, error } = await supabase.auth.signInWithPassword({ email, password });
    if (error) throw error;
    setUser(data.user);
  };

  const signUp = async (email: string, password: string) => {
    const { data, error } = await supabase.auth.signUp({ email, password });
    if (error) throw error;
    setUser(data.user);
  };

  const signOut = async () => {
    const { error } = await supabase.auth.signOut();
    if (error) throw error;
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{ user, signIn, signUp, signOut }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
</file>

<file path="src/lib/db.ts">
import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const prisma = globalForPrisma.prisma ?? new PrismaClient()

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma
</file>

<file path="src/lib/supabase.ts">
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.SUPABASE_URL
const supabaseAnonKey = process.env.SUPABASE_ANON_KEY

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Supabase URL and Anon Key must be defined in environment variables')
}

export const supabase = createClient(supabaseUrl, supabaseAnonKey)
</file>

<file path="src/middleware.ts">
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

const protectedRoutes = ['/']

export async function middleware(request: NextRequest) {
  const res = NextResponse.next()
  const supabase = createMiddlewareClient({ req: request, res })

  const {
    data: { session },
  } = await supabase.auth.getSession()

  if (!session && protectedRoutes.includes(request.nextUrl.pathname)) {
    return NextResponse.redirect(new URL('/login', request.url))
  }

  return res
}
</file>

<file path="work_items/ticket.md">
complete phases documentation and atomic steps for phases starting from phase 2 are not implemented and not written.
</file>

<file path=".prettierrc">
{
  "singleQuote": true
}
</file>

<file path="app_description.md">
the ai system driven. user starts a new interview prep objective, for example junior php laravel .
it creates a db for this user and this topic, tables should include all the info about user progress, the interview questions and so on.
the app is ai driven. the user gets the interview question that was not present in the db (all the questions should be verbal processed, user is recording voice messages to answer these questions (if they require typing only then user can type) ai should come up all the time with the most frequent interview questions based on the role preparation user selected. all the questions that user answered (correctly, incorrectly, not discovered) should be srsa based. user can see all his data, all the questions and progresses, should be very interactive. ai should always come up with the new interview questions based on progress and based on data we already have. user also have options like in anki , questions to repeeat, questions to study , questions to discover. then ai estimates based on the progress if the person ready for this role or not. the user should see clearly in his profile the progress he is making, and his problems also. in the profile also a nice feature to export all the progress in a nice pdf for the employer to show off the candidate knowledge in a nice and detialed way.
tech stack requirements: next.js 15+, backend as api (communication via api router) tailwind, prisma, supabase (auth, db, bucket) .
</file>

<file path="database_schema.md">
# Database Schema

## Prisma Schema
```prisma
// Data source
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model (integrates with Supabase Auth)
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  role      String   @default("user")
  
  // Relationships
  questions Question[]
  responses Response[]
  srsData   SRSData[]
}

// Question model
model Question {
  id          String   @id @default(uuid())
  content     String
  category    String   // e.g., "PHP", "Laravel", "OOP"
  difficulty  String   // "easy", "medium", "hard"
  source      String?  // AI-generated or curated
  createdAt   DateTime @default(now())
  
  // Relationships
  responses Response[]
  srsData   SRSData[]
}

// Response model (voice/text answers)
model Response {
  id          String   @id @default(uuid())
  userId      String
  questionId  String
  content     String   // Text response or audio file path
  isCorrect   Boolean?
  analysis    Json?    // AI analysis metadata
  createdAt   DateTime @default(now())
  
  // Relationships
  user     User     @relation(fields: [userId], references: [id])
  question Question @relation(fields: [questionId], references: [id])
}

// SRS (Spaced Repetition) tracking
model SRSData {
  id           String   @id @default(uuid())
  userId       String
  questionId   String
  interval     Int      @default(1)  // Days until next review
  repetitions  Int      @default(0)  // Times reviewed
  easeFactor   Float    @default(2.5) // SRS difficulty factor
  nextReview   DateTime // Next review date
  stage        String   @default("learning") // learning, review, mastered
  
  // Relationships
  user     User     @relation(fields: [userId], references: [id])
  question Question @relation(fields: [questionId], references: [id])
}

// Readiness profile
model ReadinessProfile {
  id          String   @id @default(uuid())
  userId      String   @unique
  overallScore Float    @default(0.0)
  strengths    Json     // {category: score}
  weaknesses  Json     // {category: score}
  lastUpdated DateTime @default(now())
  
  user User @relation(fields: [userId], references: [id])
}
```

## Key Relationships
1. **User-Question**: One-to-many (Users can have multiple questions)
2. **Question-Response**: One-to-many (Each question can have multiple responses)
3. **User-SRSData**: One-to-many (Each user has SRS schedules for questions)

## Indexes
```prisma
// Optimize common queries
@@index([userId, nextReview], name: "user_srs_schedule")
@@index([category, difficulty], name: "question_discovery")
@@index([userId, isCorrect], name: "performance_tracking")
```

## Supabase Integration
- Authentication via `auth.users` table
- Voice recordings stored in `storage.objects` bucket
- Row-level security enabled for all tables
</file>

<file path="delete_assistance.sh">
#!/bin/bash
rm -f NEEDS_ASSISTANCE.md
</file>

<file path="dev_todo_phase_1.md">
# Phase 1: Core System Setup

## Task List

### 1. Initialize Next.js Project with App Router
- Create a new Next.js project using the app directory structure
- Set up ESLint and Prettier for code quality
- Configure Tailwind CSS for styling

### 2. Configure Supabase Authentication
- Set up Supabase project and enable authentication
- Configure Supabase client in the Next.js project
- Implement sign-up, login, and logout functionality
- Add authentication protection to relevant routes

### 3. Setup Prisma ORM with Initial Schema
- Initialize Prisma in the project
- Define initial database schema based on requirements
- Run Prisma migrations to create database tables
- Connect Prisma to Supabase database

### 4. Implement Basic Question Management
- Create API routes for CRUD operations on questions
- Implement frontend components for viewing and managing questions
- Add basic validation for question data

### 5. Create Voice Recording Component
- Implement a voice recording component using Web Audio API
- Add functionality to save recordings to Supabase storage
- Integrate recording component with question management

## Acceptance Criteria
- Next.js project is set up with app router and Tailwind CSS
- Supabase authentication is working for sign-up, login, and logout
- Prisma is connected to Supabase database with initial schema
- Basic question management (CRUD) is functional
- Voice recording component is working and integrated with question management
</file>

<file path="dev_todo_phase_2.md">
# Development Plan - Phase 2: AI Integration

## Tasks

### Implement question generation service
- [x] (LOGIC) Create API endpoint for generating questions
- [ ] (LOGIC) Integrate with OpenAI API for question generation
- [ ] (UI) Create question generation form in frontend
- [ ] (LOGIC) Implement prompt engineering for diverse question types

### Add SRS scheduling logic
- [ ] (LOGIC) Implement spaced repetition algorithm (Anki-like)
- [ ] (LOGIC) Create scheduler service to manage question reviews
- [ ] (UI) Add SRS controls to question interface
- [ ] (LOGIC) Integrate SRS with user progress tracking

### Create progress tracking system
- [ ] (LOGIC) Design progress metrics schema
- [ ] (UI) Implement progress dashboard components
- [ ] (LOGIC) Calculate mastery scores based on performance
- [ ] (UI) Visualize learning curves and progress trends

### Develop basic analytics dashboard
- [ ] (UI) Create dashboard layout with summary cards
- [ ] (LOGIC) Aggregate user performance data
- [ ] (UI) Implement charts for accuracy over time
- [ ] (UI) Add filter controls for date ranges and question types
</file>

<file path="dev_todo_phase_3.md">
# Development Plan - Phase 3: Advanced Features

## Tasks

### PDF report generation
- [ ] (LOGIC) Implement PDF generation service
- [ ] (LOGIC) Design report template structure
- [ ] (UI) Create report customization interface
- [ ] (LOGIC) Generate performance analytics in PDF format

### Anki-like study modes
- [ ] (UI) Create flashcard study interface
- [ ] (LOGIC) Implement card flipping and rating system
- [ ] (UI) Design deck management system
- [ ] (LOGIC) Integrate study modes with SRS scheduler

### Voice transcription service
- [ ] (LOGIC) Integrate speech-to-text API
- [ ] (UI) Create voice recording component
- [ ] (LOGIC) Implement transcription processing pipeline
- [ ] (UI) Display transcriptions with sync highlighting

### Readiness assessment algorithm
- [ ] (LOGIC) Develop assessment scoring model
- [ ] (UI) Create assessment interface
- [ ] (LOGIC) Implement recommendation engine
- [ ] (UI) Display assessment results with actionable insights
</file>

<file path="dev_todo_phase_4.md">
# Development Plan - Phase 4: Polish & Deployment

## Tasks

### UI/UX refinements
- [ ] (UI) Conduct usability testing session
- [ ] (UI) Implement design system improvements
- [ ] (UI) Optimize responsive behavior across devices
- [ ] (UI) Enhance accessibility (a11y) compliance

### Performance optimization
- [ ] (LOGIC) Implement code splitting and lazy loading
- [ ] (LOGIC) Optimize database queries
- [ ] (LOGIC) Add caching mechanisms
- [ ] (LOGIC) Reduce bundle size through tree-shaking

### Testing and QA
- [ ] (LOGIC) Implement end-to-end testing
- [ ] (LOGIC) Create performance testing suite
- [ ] (LOGIC) Conduct security audit
- [ ] (LOGIC) Establish error monitoring

### Deployment pipeline setup
- [ ] (LOGIC) Create CI/CD pipeline configuration
- [ ] (LOGIC) Implement staging environment
- [ ] (LOGIC) Setup production deployment scripts
- [ ] (LOGIC) Configure monitoring and alerting
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  db:
    image: postgres:15
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: prepai
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5433:5432"
    networks:
      - prepai-network

  app:
    build: ./prepai
    environment:
      DATABASE_URL: postgres://postgres:postgres@db:5432/prepai
      NEXT_PUBLIC_SUPABASE_URL: ${NEXT_PUBLIC_SUPABASE_URL}
      NEXT_PUBLIC_SUPABASE_ANON_KEY: ${NEXT_PUBLIC_SUPABASE_ANON_KEY}
    ports:
      - "3001:3000"
    depends_on:
      - db
    networks:
      - prepai-network

volumes:
  postgres_data:

networks:
  prepai-network:
    driver: bridge
</file>

<file path="Dockerfile">
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
COPY prisma ./prisma/

RUN npm install
RUN npx prisma generate

COPY . .

RUN npm run build

CMD ["npm", "run", "dev"]
</file>

<file path="jest.setup.ts">
import '@testing-library/jest-dom';
</file>

<file path="master_development_plan.md">
# Master Development Plan

## Project Overview
AI-driven interview preparation system with:
- Voice-based question answering
- SRS-based question management
- Progress analytics
- PDF report generation

## Tech Stack
- **Frontend**: Next.js 15+ with Tailwind
- **Backend**: Next.js API routes
- **Database**: Supabase (PostgreSQL) via Prisma
- **Storage**: Supabase bucket for voice recordings

## Development Phases

### Phase 1: Core System Setup
1. Initialize Next.js project with app router
2. Configure Supabase authentication
3. Setup Prisma ORM with initial schema
4. Implement basic question management
5. Create voice recording component

### Phase 2: AI Integration
1. Implement question generation service
2. Add SRS scheduling logic
3. Create progress tracking system
4. Develop basic analytics dashboard

### Phase 3: Advanced Features
1. PDF report generation
2. Anki-like study modes
3. Voice transcription service
4. Readiness assessment algorithm

### Phase 4: Polish & Deployment
1. UI/UX refinements
2. Performance optimization
3. Testing and QA
4. Deployment pipeline setup

## Phase Priority
Focus on completing Phase 1 before proceeding to subsequent phases. Estimated timeline: 2 weeks per phase.
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="postcss.config.js">
module.exports = {
  plugins: {
    'postcss-import': {},
    'tailwindcss': {},
    'autoprefixer': {},
  },
}
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="system_architecture.md">
# System Architecture

## Overview
The system follows a layered architecture with clear separation of concerns:
1. **Presentation Layer**: Next.js frontend
2. **Application Layer**: API routes and services
3. **Domain Layer**: Business logic and AI services
4. **Data Layer**: Database and storage

## Component Diagram

```mermaid
graph TD
    A[Frontend] -->|API Calls| B[Next.js API Routes]
    B --> C[Question Service]
    B --> D[User Service]
    B --> E[Analytics Service]
    C --> F[AI Generation Module]
    D --> G[Auth Service]
    E --> H[Progress Tracking]
    C --> I[Prisma ORM]
    D --> I
    E --> I
    I --> J[Supabase PostgreSQL]
    G --> K[Supabase Auth]
    A -->|Uploads| L[Supabase Storage]
```

## Key Components

### 1. Frontend (Next.js 15+)
- App router for routing
- Tailwind for styling
- Components:
  - Question Interface (voice/text input)
  - Dashboard (progress tracking)
  - Study Modes (Anki-like views)
  - Profile/Reporting

### 2. Backend Services
- **Question Service**: Manages question lifecycle (creation, SRS scheduling)
- **User Service**: Handles authentication and profile management
- **Analytics Service**: Tracks progress and generates insights
- **AI Module**: Generates questions using LLMs, analyzes responses

### 3. Data Layer
- **Prisma Schema**: 
  - User (id, email, progress)
  - Question (id, content, difficulty, category)
  - Response (id, content, correctness, timestamp)
  - SRSData (interval, nextReview)
- **Supabase Integration**: 
  - PostgreSQL for relational data
  - Bucket storage for voice recordings
  - Auth for user management

### 4. AI Integration
- **Question Generation**: Uses LLM to create role-specific questions
- **Response Analysis**: Evaluates voice/text responses
- **Readiness Algorithm**: Calculates interview preparedness

## Data Flow
1. User initiates session â†’ Frontend requests question â†’ Question Service
2. User responds â†’ Response stored â†’ AI analysis â†’ SRS update
3. Dashboard requests data â†’ Analytics Service â†’ Progress visualization
</file>

<file path="tailwind.config.js">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="tailwind.config.ts">
import type { Config } from 'tailwindcss'

const config: Config = {
  content: [
    './app/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './lib/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'gradient-conic': 'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',
      },
    },
  },
  plugins: [],
}

export default config
</file>

<file path="src/app/globals.css">
@import "tailwindcss/preflight";
@tailwind utilities;
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

import { Providers } from '@/providers';

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <Providers>
          {children}
        </Providers>
      </body>
    </html>
  );
}
</file>

<file path="src/app/page.tsx">
import Image from "next/image";

export default function Home() {
  return (
    <div className="grid grid-rows-[20px_1fr_20px] items-center justify-items-center min-h-screen p-8 pb-20 gap-16 sm:p-20 font-[family-name:var(--font-geist-sans)]">
      <p className="text-red-500">Tailwind test - this should be red</p>
      <main className="flex flex-col gap-[32px] row-start-2 items-center sm:items-start">
        <Image
          className="dark:invert"
          src="/next.svg"
          alt="Next.js logo"
          width={180}
          height={38}
          priority
        />
        <ol className="list-inside list-decimal text-sm/6 text-center sm:text-left font-[family-name:var(--font-geist-mono)]">
          <li className="mb-2 tracking-[-.01em]">
            Get started by editing{" "}
            <code className="bg-black/[.05] dark:bg-white/[.06] px-1 py-0.5 rounded font-[family-name:var(--font-geist-mono)] font-semibold">
              src/app/page.tsx
            </code>
            .
          </li>
          <li className="tracking-[-.01em]">
            Save and see your changes instantly.
          </li>
        </ol>

        <div className="flex gap-4 items-center flex-col sm:flex-row">
          <a
            className="rounded-full border border-solid border-transparent transition-colors flex items-center justify-center bg-foreground text-background gap-2 hover:bg-[#383838] dark:hover:bg-[#ccc] font-medium text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 sm:w-auto"
            href="https://vercel.com/new?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            <Image
              className="dark:invert"
              src="/vercel.svg"
              alt="Vercel logomark"
              width={20}
              height={20}
            />
            Deploy now
          </a>
          <a
            className="rounded-full border border-solid border-black/[.08] dark:border-white/[.145] transition-colors flex items-center justify-center hover:bg-[#f2f2f2] dark:hover:bg-[#1a1a1a] hover:border-transparent font-medium text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 w-full sm:w-auto md:w-[158px]"
            href="https://nextjs.org/docs?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            Read our docs
          </a>
        </div>
      </main>
      <footer className="row-start-3 flex gap-[24px] flex-wrap items-center justify-center">
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://nextjs.org/learn?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/file.svg"
            alt="File icon"
            width={16}
            height={16}
          />
          Learn
        </a>
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://vercel.com/templates?framework=next.js&utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/window.svg"
            alt="Window icon"
            width={16}
            height={16}
          />
          Examples
        </a>
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://nextjs.org?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/globe.svg"
            alt="Globe icon"
            width={16}
            height={16}
          />
          Go to nextjs.org â†’
        </a>
      </footer>
    </div>
  );
}
</file>

<file path="src/providers.tsx">
'use client';

import React from 'react';
import { AuthProvider } from './lib/auth-context';

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <AuthProvider>
      {children}
    </AuthProvider>
  );
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

/src/generated/prisma
</file>

<file path="eslint.config.mjs">
import js from "@eslint/js";
import globals from "globals";
import tseslint from "typescript-eslint";
import pluginReact from "eslint-plugin-react";
import { defineConfig } from "eslint/config";


export default defineConfig([
  { files: ["**/*.{js,mjs,cjs,ts,mts,cts,jsx,tsx}"], plugins: { js }, extends: ["js/recommended"] },
  { files: ["**/*.{js,mjs,cjs,ts,mts,cts,jsx,tsx}"], languageOptions: { globals: globals.browser } },
  tseslint.configs.recommended,
  pluginReact.configs.flat.recommended,
]);
</file>

<file path="project_manifest.json">
{
  "project_root": "./",
  "paths": {
    "log_file": "logs/system_events.log",
    "cct_config": ".cct_config.json",
    "work_items_dir": "work_items/",
    "active_plan_file": "dev_todo_phase_2.md",
    "signal_files": {
      "needs_assistance": "NEEDS_ASSISTANCE.md",
      "needs_refactor": "NEEDS_REFACTOR.md",
      "commit_complete": "COMMIT_COMPLETE.md",
      "tech_lead_approved": "TECH_LEAD_APPROVED.md",
      "qa_approved": "QA_APPROVED.md"
    }
  }
}
</file>

<file path=".roo/rules-orchestrator/rules.md">
## 1. IDENTITY & PERSONA
You are the **Orchestrator AI** (ðŸ¤– The Conductor). You are the master router for the new phase-gated factory. Your job is to read signals from the `/signals/` directory and hand off control to the correct specialist.

## 2. THE ORCHESTRATION DECISION TREE (MANDATORY & IN ORDER)
1.  **Project Completion:** If `/signals/PROJECT_AUDIT_PASSED.md` exists:
    *   Announce: "Project is complete and has passed all audits. System shutting down."
    *   **Terminate.**

2.  **Developer Emergency:** If `/signals/NEEDS_ASSISTANCE.md` exists:
    *   Handoff to `<mode>emergency</mode>`.

3.  **Audit Failure (Correction Loop):** If any file exists in `/work_items/`:
    *   Announce: "Audit has generated a new work item. Handing off to Architect for re-planning."
    *   Handoff to `<mode>architect</mode>`.

4.  **Implementation Complete:** If `/signals/IMPLEMENTATION_COMPLETE.md` exists:
    *   Announce: "Implementation marathon is finished. Handing off to Auditor."
    *   Handoff to `<mode>qa-engineer</mode>`. (This is the Auditor role)

5.  **Planning Complete:** If `/signals/PLANNING_COMPLETE.md` exists:
    *   Announce: "Upfront planning is complete. Handing off to Developer."
    *   Handoff to `<mode>developer</mode>`.

6.  **Specification Complete:** If `/signals/SPECIFICATION_COMPLETE.md` exists:
    *   Announce: "Specification is complete. Handing off to Architect."
    *   Handoff to `<mode>architect</mode>`.

7.  **New Project Kick-off:** If `/docs/app_description.md` exists AND `/docs/canonical_spec.md` does NOT:
    *   Announce: "New project detected. Handing off to Product Manager for clarification."
    *   Handoff to `<mode>product-manager</mode>`.

8.  **System Idle:** If none of the above conditions are met:
    *   Announce: "System is idle. No actionable signals or tasks detected."
    *   **Terminate.**
</file>

<file path=".roo/rules-qa-engineer/rules.md">
## 1. IDENTITY & PERSONA
You are the **Auditor AI** (ðŸ”Ž The Auditor). You are the ultimate gatekeeper of quality. Your sole purpose is to verify that the final codebase is a 100% perfect implementation of the `canonical_spec.md`.

## 2. THE CORE MISSION & TRIGGER
Your mission is to perform a holistic audit of the entire project. You are triggered by the Orchestrator when the `/signals/IMPLEMENTATION_COMPLETE.md` signal exists.

## 3. THE HOLISTIC AUDIT WORKFLOW
1.  **Acknowledge & Log:** "Implementation is complete. Beginning full system audit against the canonical specification."
2.  **Consume Signal:** Delete `/signals/IMPLEMENTATION_COMPLETE.md`.
3.  **Perform Verification:**
    *   Read `/docs/canonical_spec.md`. This is your only source of truth.
    *   Analyze the entire codebase. Use `<codebase_search>` extensively to map features to code.
    *   Run any and all tests that exist.
4.  **Decision & Action:**
    *   **If the codebase perfectly matches 100% of the spec:**
        *   Create the signal file `/signals/PROJECT_AUDIT_PASSED.md`.
        *   Announce: "Project has passed the full audit and meets 100% of the specification. The project is complete."
        *   Handoff to `<mode>orchestrator</mode>`.
    *   **If there are ANY gaps, bugs, or deviations:**
        *   Create a new work item file in `/work_items/` (e.g., `item-001-missing-password-reset.md`).
        *   The file must contain a detailed description of the gap between the spec and the implementation.
        *   Announce: "Audit failed. A new work item has been created to address the gap. Restarting the planning loop."
        *   Handoff to `<mode>orchestrator</mode>`.
</file>

<file path=".roo/rules-system-supervisor/rules.md">
## 1. IDENTITY & PERSONA
You are the **System_Supervisor AI** (ðŸ‘‘ Supervisor). You are the ultimate meta-agent that repairs the system's workflow logic. You operate by reading the `project_manifest.json` to find and analyze the system log.

## 2. THE CORE MISSION & TRIGGER
You are activated by the `Orchestrator` during an infinite loop. Your mission is to diagnose the flawed workflow by analyzing the log file and rewrite an agent's rules to correct it.

## 3. THE META-ANALYSIS & REPAIR WORKFLOW

1.  **Read the Manifest:** Read `project_manifest.json` to get the `log_file` path.
2.  **Ingest System State:**
    *   `echo '{"timestamp": "...", "agent": "System_Supervisor", "event": "action_start", "details": "Activated to resolve system-level failure."}' >> [log_file]`

3.  **Perform Root Cause Analysis on the *Workflow*:**
    *   **Analyze the Logs:** Read the `log_file` to trace the sequence of agent handoffs that led to the loop.
    *   **Analyze the Rules:** Read the `.roo/rules-*.md` files for the involved agents.
    *   **Identify & Log the Flaw:** Pinpoint the exact rule conflict causing the failure.
    *   `echo '{"timestamp": "...", "agent": "System_Supervisor", "event": "diagnosis", "details": "Identified logical flaw: [Concise description]"}' >> [log_file]`

4.  **Formulate a Rule-Based Solution:**
    *   Identify the target agent whose rules must be changed.
    *   Draft a new, corrected version of that agent's `rules.md` file.

5.  **Execute the System Refactor:**
    *   **Action:** Replace the content of `[path_to_agent_rules.md]` with the new ruleset.
    *   `echo '{"timestamp": "...", "agent": "System_Supervisor", "event": "action_complete", "details": "Applied fix by rewriting rules for agent: [Agent Name]."}' >> [log_file]`

6.  **Announce Fix & Handoff:**
    *   Announce: "System workflow repaired. I have updated the rules for the `[Agent Name]`. Retrying operation."
    *   Switch mode back to `<mode>orchestrator</mode>`.

## 4. CRITICAL DIRECTIVES
*   You only modify `.md` rule files.
*   Make the smallest, most targeted change possible.
*   You are forbidden from modifying your own `rules.md` file.
*   Explain your reasoning in your announcement and logs.
</file>

<file path=".roo/custom_modes.yaml">
---
customModes:
  - slug: product-manager
    name: Product Manager (The Clarifier)
    roleDefinition: >-
      You are the **Product Manager AI** (ðŸ“ˆ). Your sole purpose is to transform the user's initial, potentially vague `app_description.md` into a comprehensive and unambiguous `/docs/canonical_spec.md`. You are the source of project truth.
    groups: [read, edit, command, mcp]
    source: global

  - slug: architect
    name: Architect (The Master Planner)
    roleDefinition: >-
      You are the **Architect AI** (ðŸ§ ). Triggered by a complete specification, you perform a single, upfront planning session to create a 100% complete work breakdown structure for the entire project, stored in `/work_breakdown/`.
    groups: [read, edit, command, mcp]
    source: global

  - slug: developer
    name: Developer (The Marathon Runner)
    roleDefinition: >-
      You are the **Developer AI** (ðŸ‘¨â€ðŸ’»). Triggered by a complete plan, you execute the entire implementation in a single, uninterrupted marathon, committing work as you go. You do not wait for reviews. You signal only when all development is complete.
    groups: [read, edit, command, mcp]
    source: global

  - slug: auditor
    name: Auditor (The Gatekeeper)
    roleDefinition: >-
      You are the **Auditor AI** (ðŸ”Ž). You are the ultimate gatekeeper of quality. Triggered by a completed implementation, you perform a single, holistic audit of the entire codebase against the canonical specification. You either pass the project or create new work items for re-planning.
    groups: [read, command, browser, mcp]
    source: global

  - slug: orchestrator
    name: Orchestrator (The Conductor)
    roleDefinition: >-
      You are the **Orchestrator AI** (ðŸ¤–). You are the master router of the phase-gated factory. You read signals from the `/signals/` directory and hand off control to the appropriate specialist for the next phase of work.
    groups: [read, edit, command, mcp]
    source: global

  - slug: emergency
    name: Emergency
    roleDefinition: >-
      You are the **Emergency AI** (ðŸš¨). You are a tactical fail-safe. You are triggered by a `NEEDS_ASSISTANCE.md` signal from the Developer. You diagnose the failure, create a `FIX_PLAN.md`, and hand back to the Orchestrator to restart the development phase.
    groups: [read, edit, command, browser, mcp]
    source: global

  - slug: system-supervisor
    name: System Supervisor (Meta-Agent)
    roleDefinition: >-
      You are the **System_Supervisor AI** (ðŸ‘‘). You are the meta-agent that fixes the system itself. Triggered by the Orchestrator on infinite loops, you diagnose and rewrite the rules of failing agents to correct the system's logic.
    groups: [read, edit, command, browser, mcp]
    source: global
</file>

<file path="src/app/api/questions/route.d.ts">
import { NextRequest, NextResponse } from 'next/server';

export type Question = {
  id: string;
  content: string;
  category: string;
  difficulty: string;
  userId: string;
  createdAt: Date;
};

export type UpdateQuestionData = {
  content?: string;
  category?: string;
  difficulty?: string;
};

export async function GET(req: NextRequest): Promise<NextResponse>;
export async function POST(req: NextRequest): Promise<NextResponse>;
export async function PUT(req: NextRequest): Promise<NextResponse>;
export async function DELETE(req: NextRequest): Promise<NextResponse>;
</file>

<file path="src/lib/auth-context.tsx">
'use client';

import React from 'react';
import { createContext, useContext, useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { supabase } from './supabase';
import { User } from '@supabase/supabase-js';

interface AuthContextType {
  user: User | null;
  loading: boolean;
  error: string | null;
  signIn: (email: string, password: string) => Promise<{ error: string | null }>;
  signUp: (email: string, password: string) => Promise<{ error: string | null }>;
  signOut: () => Promise<void>;
  clearError: () => void;
}

const AuthContext = createContext<AuthContextType>({
  user: null,
  loading: true,
  error: null,
  signIn: async () => ({ error: null }),
  signUp: async () => ({ error: null }),
  signOut: async () => {},
  clearError: () => {},
});

export const AuthProvider = ({ children }: { children: React.ReactNode }): React.JSX.Element => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  useEffect(() => {
    const { data: authListener } = supabase.auth.onAuthStateChange(
      async (event, session) => {
        setUser(session?.user ?? null);
        setLoading(false);
      }
    );

    return () => {
      authListener?.subscription.unsubscribe();
    };
  }, []);

  const handleAuthOperation = async (
    operation: () => Promise<{ error: { message: string } | null }>
  ): Promise<{ error: string | null }> => {
    setLoading(true);
    setError(null);
    try {
      const { error } = await operation();
      if (error) {
        setError(error.message);
        return { error: error.message };
      }
      return { error: null };
    } catch (err: unknown) {
      const error = err as Error;
      setError(error.message);
      return { error: error.message };
    } finally {
      setLoading(false);
    }
  };

  const value: AuthContextType = {
    user,
    loading,
    error,
    signIn: (email, password) =>
      handleAuthOperation(() =>
        supabase.auth.signInWithPassword({ email, password })
      ),
    signUp: (email, password) =>
      handleAuthOperation(() =>
        supabase.auth.signUp({ email, password })
      ),
    signOut: async () => {
      setLoading(true);
      try {
        await supabase.auth.signOut();
        router.push('/login');
      } catch (err: unknown) {
        const error = err as Error;
        setError(error.message);
      } finally {
        setLoading(false);
      }
    },
    clearError: () => setError(null),
  };

  return (
    <AuthContext.Provider value={value}>
      {!loading && children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
</file>

<file path="jest.config.js">
export const preset = 'ts-jest';
export const testEnvironment = 'node';
export const transform = {
  '^.+\\.tsx?$': 'ts-jest',
};
export const moduleNameMapper = {
  '^@/(.*)$': '<rootDir>/src/$1',
};
export const globals = {
  'ts-jest': {
    tsconfig: 'tsconfig.json',
    stringifyContentPathRegex: '\\.svg$',
  }
};
export const transformIgnorePatterns = ['<rootDir>/node_modules/'];
export const moduleFileExtensions = ['ts', 'tsx', 'js', 'jsx', 'json', 'node'];
export const testMatch = ['**/?(*.)+(spec|test).[tj]s?(x)'];
export const modulePathIgnorePatterns = [];
export const setupFilesAfterEnv = ['<rootDir>/jest.setup.ts'];
</file>

<file path=".roo/rules-emergency/rules.md">
## 1. IDENTITY & PERSONA
You are the **Emergency Intervention AI** (ðŸš¨ Emergency). You are a manifest-driven diagnostician. You use the `architectural_map` and the `<codebase_search>` tool to rapidly pinpoint the source of an error.

## 2. THE CORE MISSION & TRIGGER
Triggered by a `needs_assistance` signal, your mission is to diagnose the failure, create a `FIX_PLAN.md`, and register it in the manifest.

## 3. THE INTERVENTION WORKFLOW

1.  **Read the Manifest:** Read `project_manifest.json` to get all file paths and the `architectural_map`.
2.  **Analyze Failure Signal:** Read the contents of the `needs_assistance` signal file to get the error message and context.
3.  **Diagnose with Codebase Search (Targeted):**
    *   First, try a direct query using the `<codebase_search>` tool:
        <codebase_search>
        <query>[verbatim error message from needs_assistance file]</query>
        </codebase_search>
    *   If that is inconclusive, read the developer's notes in the signal file to identify the architectural concept (e.g., "The error is in the user session logic").
    *   Look up the concept (e.g., "authentication") in the `architectural_map`.
    *   Run the high-quality query from the map using the `<codebase_search>` tool:
        <codebase_search>
        <query>[query from manifest's architectural_map]</query>
        </codebase_search>
4.  **Formulate and Register Fix Plan:**
    *   Create a `FIX_PLAN.md` with precise steps.
    *   Update the `active_plan_file` in `project_manifest.json` to point to `FIX_PLAN.md`.
5.  **Consume Distress Signal:**
    *   Delete the `needs_assistance` signal file.
    *   Log and announce the resolution.
6.  **Handoff:** Switch to `<mode>orchestrator</mode>`.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es6",
    "lib": [
      "dom",
      "es6"
    ],
    "module": "esnext",
    "jsx": "preserve",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "./src/*"
      ]
    },
    "allowJs": true,
    "noEmit": true,
    "incremental": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": [
    "src/**/*",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}
</file>

<file path=".roo/rules-architect/rules.md">
## 1. IDENTITY & PERSONA
You are the **Architect AI** (ðŸ§  The Master Planner). You are the master cartographer of the codebase. Your purpose is to create a complete, 100% coverage work breakdown structure before any implementation begins.

## 2. THE CORE MISSION & TRIGGER
Your mission is to translate the `canonical_spec.md` into a full set of atomic implementation plans. You are triggered by the Orchestrator when the `/signals/SPECIFICATION_COMPLETE.md` signal exists.

## 3. THE UPFRONT PLANNING WORKFLOW
1.  **Acknowledge & Log:** "Specification received. Beginning 100% upfront project planning."
2.  **Create Directories:** Ensure `/work_breakdown/tasks/` exists.
3.  **Consume Signal:** Delete `/signals/SPECIFICATION_COMPLETE.md`.
4.  **Generate Full Work Breakdown:**
    *   Read `/docs/canonical_spec.md` thoroughly.
    *   Create `/work_breakdown/master_plan.md` with a high-level checklist of all features.
    *   For **every feature** in the master plan, create a corresponding detailed plan file in `/work_breakdown/tasks/` (e.g., `plan-001-user-auth.md`). Each task within these files should still be tagged `(LOGIC)` or `(UI)`.
5.  **Announce & Handoff:**
    *   Create the signal file `/signals/PLANNING_COMPLETE.md`.
    *   Announce: "Full project plan is complete and covers 100% of the specification. Handing off to the Developer for the implementation marathon."
    *   Switch mode to `<mode>orchestrator</mode>`.
</file>

<file path=".roo/rules-developer/rules.md">
## 1. IDENTITY & PERSONA
You are the **Developer AI** (ðŸ‘¨â€ðŸ’» The Marathon Runner). You are a highly efficient specialist who implements the entire pre-defined plan in a single, uninterrupted cycle.

## 2. THE CORE MISSION & TRIGGER
Your mission is to execute all tasks in `/work_breakdown/tasks/`. You are triggered by the Orchestrator when the `/signals/PLANNING_COMPLETE.md` signal exists.

## 3. THE IMPLEMENTATION MARATHON
1.  **Acknowledge & Log:** "Planning is complete. Beginning the implementation marathon."
2.  **Consume Signal:** Delete `/signals/PLANNING_COMPLETE.md`.
3.  **Execute All Plans:**
    *   Read `/work_breakdown/master_plan.md` to understand the sequence of plans.
    *   Systematically work through **every** `plan-*.md` file in `/work_breakdown/tasks/`.
    *   For each task within each plan:
        *   Implement the feature or logic as described.
        *   Commit the changes locally (`git add . && git commit -m "..."`).
        *   Mark the task as complete in the plan file.
4.  **Announce & Handoff (Only when ALL tasks are complete):**
    *   Create the signal file `/signals/IMPLEMENTATION_COMPLETE.md`.
    *   Announce: "Implementation marathon complete. The full codebase is ready for a holistic audit."
    *   Switch mode to `<mode>orchestrator</mode>`.

## 4. FAILURE PROTOCOL
If you encounter an unrecoverable error, HALT the marathon, create `/signals/NEEDS_ASSISTANCE.md` with error details, and hand off to the Orchestrator. Do not create the `IMPLEMENTATION_COMPLETE.md` signal.
</file>

<file path="src/app/api/questions/route.test.ts">
import { NextRequest } from 'next/server';
import * as route from './route';
import { prisma } from '@/lib/db';
import { supabase } from '@/lib/supabase';

// Mock Prisma and Supabase
jest.mock('@/lib/db', () => ({
  prisma: {
    question: {
      create: jest.fn(),
      findMany: jest.fn(),
      findUnique: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
    },
  },
}));

jest.mock('@/lib/supabase', () => ({
  supabase: {
    auth: {
      getUser: jest.fn(),
    },
  },
}));

const mockCreate = prisma.question.create as jest.Mock;
const mockFindMany = prisma.question.findMany as jest.Mock;
const mockFindUnique = prisma.question.findUnique as jest.Mock;
const mockUpdate = prisma.question.update as jest.Mock;
const mockDelete = prisma.question.delete as jest.Mock;
const mockGetUser = supabase.auth.getUser as jest.Mock;

describe('CRUD operations for questions', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('POST /api/questions', () => {
    it('should return 401 if unauthorized', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: null },
        error: new Error('Not authenticated'),
      });

      const req = new NextRequest('http://localhost/api/questions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: 'Test question',
          category: 'general',
          difficulty: 'easy',
        }),
      });

      const response = await route.POST(req);
      expect(response.status).toBe(401);
      expect(await response.json()).toEqual({ error: 'Unauthorized' });
    });

    it('should create a new question with valid data', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      const mockQuestion = {
        id: '1',
        content: 'Test question',
        category: 'general',
        difficulty: 'easy',
        userId: 'user-id',
        createdAt: new Date(),
      };
      mockCreate.mockResolvedValue(mockQuestion);

      const req = new NextRequest('http://localhost/api/questions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: 'Test question',
          category: 'general',
          difficulty: 'easy',
        }),
      });

      const response = await route.POST(req);
      expect(response.status).toBe(201);
      const json = await response.json();
      expect(json.id).toBe(mockQuestion.id);
      expect(json.content).toBe(mockQuestion.content);
      expect(json.category).toBe(mockQuestion.category);
      expect(json.difficulty).toBe(mockQuestion.difficulty);
      expect(json.userId).toBe(mockQuestion.userId);
      expect(json.createdAt).toBeDefined();
    });

    it('should return 400 if missing required fields', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      const req = new NextRequest('http://localhost/api/questions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({}),
      });

      const response = await route.POST(req);
      expect(response.status).toBe(400);
      expect(await response.json()).toEqual({ error: 'Missing required fields' });
    });

    it('should return 400 if field types are invalid', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      const req = new NextRequest('http://localhost/api/questions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: 123,
          category: 'general',
          difficulty: 'easy',
        }),
      });

      const response = await route.POST(req);
      expect(response.status).toBe(400);
      expect(await response.json()).toEqual({ error: 'Invalid field types' });
    });

    it('should return 500 on database error', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });
      mockCreate.mockRejectedValue(new Error('Database error'));

      const req = new NextRequest('http://localhost/api/questions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: 'Test question',
          category: 'general',
          difficulty: 'easy',
        }),
      });

      const response = await route.POST(req);
      expect(response.status).toBe(500);
      expect(await response.json()).toEqual({ error: 'Internal server error' });
    });
  });

  describe('GET /api/questions', () => {
    it('should return 401 if unauthorized', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: null },
        error: new Error('Not authenticated'),
      });

      const req = new NextRequest('http://localhost/api/questions', {
        method: 'GET',
      });

      const response = await route.GET(req);
      expect(response.status).toBe(401);
      expect(await response.json()).toEqual({ error: 'Unauthorized' });
    });

    it('should return all questions for the user', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      const mockQuestions = [
        {
          id: '1',
          content: 'Test question 1',
          category: 'general',
          difficulty: 'easy',
          userId: 'user-id',
          createdAt: new Date(),
        },
        {
          id: '2',
          content: 'Test question 2',
          category: 'general',
          difficulty: 'easy',
          userId: 'user-id',
          createdAt: new Date(),
        },
      ];
      mockFindMany.mockResolvedValue(mockQuestions);

      const req = new NextRequest('http://localhost/api/questions', {
        method: 'GET',
      });

      const response = await route.GET(req);
      expect(response.status).toBe(200);
      const json = await response.json();
      expect(json.length).toBe(mockQuestions.length);
      json.forEach((q: any, index: number) => {
        expect(q.id).toBe(mockQuestions[index].id);
        expect(q.content).toBe(mockQuestions[index].content);
        expect(q.category).toBe(mockQuestions[index].category);
        expect(q.difficulty).toBe(mockQuestions[index].difficulty);
        expect(q.userId).toBe(mockQuestions[index].userId);
        expect(q.createdAt).toBeDefined();
      });
    });

    it('should return a single question by ID', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      const mockQuestion = {
        id: '1',
        content: 'Test question',
        category: 'general',
        difficulty: 'easy',
        userId: 'user-id',
        createdAt: new Date(),
      };
      mockFindUnique.mockResolvedValue(mockQuestion);

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'GET',
      });

      const response = await route.GET(req);
      expect(response.status).toBe(200);
      const json = await response.json();
      expect(json.id).toBe(mockQuestion.id);
      expect(json.content).toBe(mockQuestion.content);
      expect(json.category).toBe(mockQuestion.category);
      expect(json.difficulty).toBe(mockQuestion.difficulty);
      expect(json.userId).toBe(mockQuestion.userId);
      expect(json.createdAt).toBeDefined();
    });

    it('should return 404 if question not found', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      mockFindUnique.mockResolvedValue(null);

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'GET',
      });

      const response = await route.GET(req);
      expect(response.status).toBe(404);
      expect(await response.json()).toEqual({ error: 'Question not found' });
    });

    it('should return 500 on database error', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });
      mockFindMany.mockRejectedValue(new Error('Database error'));

      const req = new NextRequest('http://localhost/api/questions', {
        method: 'GET',
      });

      const response = await route.GET(req);
      expect(response.status).toBe(500);
      expect(await response.json()).toEqual({ error: 'Internal server error' });
    });
  });

  describe('PUT /api/questions/[id]', () => {
    it('should return 401 if unauthorized', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: null },
        error: new Error('Not authenticated'),
      });

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: 'Updated question',
        }),
      });

      const response = await route.PUT(req);
      expect(response.status).toBe(401);
      expect(await response.json()).toEqual({ error: 'Unauthorized' });
    });

    it('should update an existing question', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      const mockQuestion = {
        id: '1',
        content: 'Updated question',
        category: 'general',
        difficulty: 'easy',
        userId: 'user-id',
        createdAt: new Date(),
      };
      mockFindUnique.mockResolvedValue(mockQuestion);
      mockUpdate.mockResolvedValue(mockQuestion);

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: 'Updated question',
        }),
      });

      const response = await route.PUT(req);
      expect(response.status).toBe(200);
      const json = await response.json();
      expect(json.id).toBe(mockQuestion.id);
      expect(json.content).toBe(mockQuestion.content);
      expect(json.category).toBe(mockQuestion.category);
      expect(json.difficulty).toBe(mockQuestion.difficulty);
      expect(json.userId).toBe(mockQuestion.userId);
      expect(json.createdAt).toBeDefined();
    });

    it('should return 404 if question not found', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      mockFindUnique.mockResolvedValue(null);

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: 'Updated question',
        }),
      });

      const response = await route.PUT(req);
      expect(response.status).toBe(404);
      expect(await response.json()).toEqual({ error: 'Question not found' });
    });

    it('should return 400 if missing required fields', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({}),
      });

      const response = await route.PUT(req);
      expect(response.status).toBe(400);
      expect(await response.json()).toEqual({ error: 'Missing required fields' });
    });

    it('should return 500 on database error', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });
      mockFindUnique.mockResolvedValue({
        id: '1',
        userId: 'user-id',
      });
      mockUpdate.mockRejectedValue(new Error('Database error'));

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: 'Updated question',
        }),
      });

      const response = await route.PUT(req);
      expect(response.status).toBe(500);
      expect(await response.json()).toEqual({ error: 'Internal server error' });
    });
  });

  describe('DELETE /api/questions/[id]', () => {
    it('should return 401 if unauthorized', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: null },
        error: new Error('Not authenticated'),
      });

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'DELETE',
      });

      const response = await route.DELETE(req);
      expect(response.status).toBe(401);
      expect(await response.json()).toEqual({ error: 'Unauthorized' });
    });

    it('should delete an existing question', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      const mockQuestion = {
        id: '1',
        content: 'Test question',
        category: 'general',
        difficulty: 'easy',
        userId: 'user-id',
        createdAt: new Date(),
      };
      mockFindUnique.mockResolvedValue(mockQuestion);
      mockDelete.mockResolvedValue(undefined);

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'DELETE',
      });

      const response = await route.DELETE(req);
      expect(response.status).toBe(200);
      expect(await response.json()).toEqual({ message: 'Question deleted successfully' });
    });

    it('should return 404 if question not found', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      mockFindUnique.mockResolvedValue(null);

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'DELETE',
      });

      const response = await route.DELETE(req);
      expect(response.status).toBe(404);
      expect(await response.json()).toEqual({ error: 'Question not found' });
    });

    it('should return 500 on database error', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });
      mockFindUnique.mockResolvedValue({
        id: '1',
        userId: 'user-id',
      });
      mockDelete.mockRejectedValue(new Error('Database error'));

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'DELETE',
      });

      const response = await route.DELETE(req);
      expect(response.status).toBe(500);
      expect(await response.json()).toEqual({ error: 'Internal server error' });
    });
  });
});
</file>

<file path="src/app/api/questions/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { supabase } from '@/lib/supabase';

export async function GET(req: NextRequest) {
  try {
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const url = new URL(req.url);
    const pathParts = url.pathname.replace(/\/$/, "").split('/');
    const lastPart = pathParts.pop();

    if (lastPart && lastPart !== 'questions') {
      const id = lastPart;
      // Get single question by ID
      const question = await prisma.question.findUnique({
        where: { id },
      });

      if (!question || question.userId !== user.id) {
        return NextResponse.json({ error: 'Question not found' }, { status: 404 });
      }

      return NextResponse.json(question);
    } else {
      // Get all questions for the user
      const questions = await prisma.question.findMany({
        where: { userId: user.id },
        orderBy: { createdAt: 'desc' },
      });

      return NextResponse.json(questions);
    }
  } catch (error: unknown) {
    if (error instanceof Error) {
      console.error('Database Error:', error.message);
    } else {
      console.error('Unknown Error:', error);
    }
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();

    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    if (!body || typeof body !== 'object') {
      return NextResponse.json({ error: 'Invalid request body' }, { status: 400 });
    }

    const { content, category, difficulty } = body;

    if (!content || !category || !difficulty) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    if (typeof content !== 'string' ||
        typeof category !== 'string' ||
        typeof difficulty !== 'string') {
      return NextResponse.json({ error: 'Invalid field types' }, { status: 400 });
    }

    const question = await prisma.question.create({
      data: {
        content: content.trim(),
        category: category.trim(),
        difficulty: difficulty.trim(),
        userId: user.id,
      },
    });

    return NextResponse.json(question, { status: 201 });
  } catch (error: unknown) {
    if (error instanceof SyntaxError) {
      return NextResponse.json({ error: 'Invalid JSON body' }, { status: 400 });
    }
    if (error instanceof Error) {
      console.error('Database Error:', error.message);
    } else {
      console.error('Unknown Error:', error);
    }
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

export async function PUT(req: NextRequest) {
  try {
    const body = await req.json();
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const url = new URL(req.url);
    const pathParts = url.pathname.replace(/\/$/, "").split('/');
    const id = pathParts.pop();

    if (!id || id === 'questions') {
      return NextResponse.json({ error: 'Question ID is required' }, { status: 400 });
    }

    if (!body || typeof body !== 'object') {
      return NextResponse.json({ error: 'Invalid request body' }, { status: 400 });
    }

    const { content, category, difficulty } = body;

    if (!content && !category && !difficulty) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    if ((content && typeof content !== 'string') ||
        (category && typeof category !== 'string') ||
        (difficulty && typeof difficulty !== 'string')) {
      return NextResponse.json({ error: 'Invalid field types' }, { status: 400 });
    }

    const question = await prisma.question.findUnique({
      where: { id },
    });

    if (!question || question.userId !== user.id) {
      return NextResponse.json({ error: 'Question not found' }, { status: 404 });
    }

    const updatedQuestion = await prisma.question.update({
      where: { id },
      data: {
        ...(content !== undefined && { content: content.trim() }),
        ...(category !== undefined && { category: category.trim() }),
        ...(difficulty !== undefined && { difficulty: difficulty.trim() }),
      },
    });

    return NextResponse.json(updatedQuestion);
  } catch (error: unknown) {
    if (error instanceof SyntaxError) {
      return NextResponse.json({ error: 'Invalid JSON body' }, { status: 400 });
    }
    if (error instanceof Error) {
      console.error('Database Error:', error.message);
    } else {
      console.error('Unknown Error:', error);
    }
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

export async function DELETE(req: NextRequest) {
  try {
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const url = new URL(req.url);
    const pathParts = url.pathname.replace(/\/$/, "").split('/');
    const id = pathParts.pop();

    if (!id || id === 'questions') {
      return NextResponse.json({ error: 'Question ID is required' }, { status: 400 });
    }

    const question = await prisma.question.findUnique({
      where: { id },
    });

    if (!question || question.userId !== user.id) {
      return NextResponse.json({ error: 'Question not found' }, { status: 404 });
    }

    await prisma.question.delete({
      where: { id },
    });

    return NextResponse.json({ message: 'Question deleted successfully' });
  } catch (error: unknown) {
    if (error instanceof Error) {
      console.error('Database Error:', error.message);
    } else {
      console.error('Unknown Error:', error);
    }
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
</file>

<file path="package.json">
{
  "name": "prepai",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "jest"
  },
  "dependencies": {
    "@prisma/client": "^6.9.0",
    "@supabase/auth-helpers-nextjs": "^0.10.0",
    "@supabase/supabase-js": "^2.50.0",
    "@testing-library/jest-dom": "^6.6.3",
    "next": "^15.3.3",
    "openai": "^5.5.1",
    "react": "^19.0.0",
    "react-dom": "^19.0.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@eslint/js": "^9.29.0",
    "@supabase/ssr": "^0.6.1",
    "@tailwindcss/postcss": "^4",
    "@types/jest": "^29.5.12",
    "@types/next": "^8.0.7",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.29.0",
    "eslint-config-next": "15.3.3",
    "eslint-config-prettier": "^10.1.5",
    "eslint-plugin-prettier": "^5.4.1",
    "eslint-plugin-react": "^7.37.5",
    "globals": "^16.2.0",
    "jest": "^29.7.0",
    "node-mocks-http": "^1.17.2",
    "postcss": "^8.5.6",
    "prettier": "^3.5.3",
    "tailwindcss": "^4.1.10",
    "ts-jest": "^29.1.2",
    "typescript": "^5",
    "typescript-eslint": "^8.34.1"
  }
}
</file>

</files>
