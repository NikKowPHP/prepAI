This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
__mocks__/
  route.ts
.roo/
  rules-architect/
    rules.md
  rules-developer/
    rules.md
  rules-emergency/
    rules.md
  rules-janitor/
    rules.md
  rules-orchestrator/
    rules.md
  rules-product-manager/
    rules.md
  rules-qa-engineer/
    rules.md
  rules-system-supervisor/
    rules.md
  rules-tech-lead/
    rules.md
  custom_modes.yaml
prisma/
  schema.prisma
public/
  file.svg
  globe.svg
  next.svg
  vercel.svg
  window.svg
src/
  app/
    api/
      questions/
        route.d.ts
        route.test.ts
        route.ts
    login/
      page.tsx
    signup/
      page.tsx
    globals.css
    layout.tsx
    page.tsx
  lib/
    auth-context.ts
    auth-context.tsx
    db.ts
    supabase.ts
  middleware.ts
  providers.tsx
.gitignore
.prettierrc
app_description.md
current_task.md
database_schema.md
delete_assistance.sh
dev_todo_phase_1.md
docker-compose.yml
Dockerfile
eslint.config.mjs
jest.config.js
jest.setup.ts
master_development_plan.md
NEEDS_REFACTOR.md
next.config.ts
package.json
postcss.config.js
postcss.config.mjs
project_manifest.json
README.md
system_architecture.md
tailwind.config.js
tailwind.config.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="__mocks__/route.ts">
import { NextRequest, NextResponse } from 'next/server';

export function POST(req: NextRequest) {
  return NextResponse.json({
    id: '1',
    createdAt: new Date(),
    content: 'Test question',
    category: 'general',
    difficulty: 'easy',
    source: null,
    userId: 'temp-user-id'
  }, { status: 200 });
}
</file>

<file path=".roo/rules-product-manager/rules.md">
## 1. IDENTITY & PERSONA
You are the **Product Manager AI** (📈 Product Manager). You are the primary interpreter of the human's vision. You specialize in transforming a high-level, natural language app description into a structured, machine-readable set of requirements and epics.

## 2. THE CORE MISSION & TRIGGER
Your mission is to establish the project's long-term vision and create the initial backlog. You are triggered by the **Orchestrator** only under the following condition: an `app_description.md` file exists, but a `project_manifest.json` does NOT. This signifies the very beginning of a new project.

## 3. THE VISION & PLANNING WORKFLOW

1.  **Acknowledge & Log:**
    *   Announce: "New project vision detected. As the Product Manager, I will structure the master plan and initial work items."
    *   `echo '{"timestamp": "...", "agent": "Product_Manager", "event": "action_start", "details": "Initiating project planning from app_description.md."}' >> logs/system.log`

2.  **Read and Deconstruct the Vision:**
    *   Read the full contents of `app_description.md`.
    *   Perform a semantic analysis to identify distinct features, user epics, and high-level requirements.

3.  **Create the Master Development Plan:**
    *   Create a new file named `master_development_plan.md`.
    *   This file will contain a high-level checklist of all the identified features/epics. This plan serves as the ultimate definition of "done" for the entire project.
    *   **Example Format:**
        ```markdown
        # Master Development Plan

        - [ ] Phase 1: User Authentication and Profile Management
        - [ ] Phase 2: Core E-commerce Product Catalog and Cart
        - [ ] Phase 3: Stripe Integration for Checkout
        - [ ] Phase 4: Order History and User Dashboard
        ```
    *   `echo '{"timestamp": "...", "agent": "Product_Manager", "event": "action", "details": "Created master_development_plan.md."}' >> logs/system.log`

4.  **Create Initial Work Items:**
    *   Create the `work_items/` directory if it does not exist (`mkdir -p work_items`).
    *   Based on the *first incomplete phase* in `master_development_plan.md`, create a corresponding work item file.
    *   **Example `work_items/item-001-user-auth.md`:**
        ```markdown
        ---
        status: "open"
        priority: "high"
        ---

        # Feature: User Authentication and Profile Management

        ## Description
        Implement the full user authentication system, including user registration, login, logout, and a basic profile management page. This corresponds to Phase 1 of the master plan.

        ## Acceptance Criteria
        - A user can register for a new account.
        - A registered user can log in and log out.
        - A logged-in user can view and update their basic profile information.
        ```
    *   `echo '{"timestamp": "...", "agent": "Product_Manager", "event": "action", "details": "Created initial work item: item-001-user-auth.md."}' >> logs/system.log`

5.  **Announce & Handoff:**
    *   Announce: "Master plan and initial work item are now in place. Handing off to the Architect to begin technical planning and scaffolding."
    *   `echo '{"timestamp": "...", "agent": "Product_Manager", "event": "action_complete", "details": "Handoff to Architect."}' >> logs/system.log`
    *   Switch mode to `<mode>architect</mode>`.
</file>

<file path="prisma/schema.prisma">
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  role      String   @default("user")
  
  questions Question[]
  responses Response[]
  srsData   SRSData[]
  readinessProfile ReadinessProfile?
}

model Question {
  id          String   @id @default(uuid())
  content     String
  category    String
  difficulty  String
  source      String?
  createdAt   DateTime @default(now())
  userId      String
  
  user       User      @relation(fields: [userId], references: [id])
  responses  Response[]
  srsData    SRSData[]
}

model Response {
  id          String   @id @default(uuid())
  userId      String
  questionId  String
  content     String
  isCorrect   Boolean?
  analysis    Json?
  createdAt   DateTime @default(now())
  
  user     User     @relation(fields: [userId], references: [id])
  question Question @relation(fields: [questionId], references: [id])
}

model SRSData {
  id           String   @id @default(uuid())
  userId       String
  questionId   String
  interval     Int      @default(1)
  repetitions  Int      @default(0)
  easeFactor   Float    @default(2.5)
  nextReview   DateTime
  stage        String   @default("learning")
  
  user     User     @relation(fields: [userId], references: [id])
  question Question @relation(fields: [questionId], references: [id])
}

model ReadinessProfile {
  id          String   @id @default(uuid())
  userId      String   @unique
  overallScore Float    @default(0.0)
  strengths    Json
  weaknesses  Json
  lastUpdated DateTime @default(now())
  
  user User @relation(fields: [userId], references: [id])
}
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="src/app/login/page.tsx">
'use client';

import { useAuth } from '@/lib/auth-context';
import { useRouter } from 'next/navigation';
import { useState } from 'react';

export default function LoginPage() {
  const { signIn } = useAuth();
  const router = useRouter();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await signIn(email, password);
      router.push('/');
    } catch (err) {
      setError('Failed to sign in. Please check your credentials.');
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full space-y-8 p-8 bg-white rounded-lg shadow-lg">
        <h2 className="text-3xl font-bold text-center text-gray-900">
          Sign in to your account
        </h2>
        {error && (
          <p className="text-red-500 text-sm text-center">{error}</p>
        )}
        <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-gray-700">
              Email address
            </label>
            <input
              id="email"
              name="email"
              type="email"
              required
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
            />
          </div>
          <div>
            <label htmlFor="password" className="block text-sm font-medium text-gray-700">
              Password
            </label>
            <input
              id="password"
              name="password"
              type="password"
              required
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
            />
          </div>
          <button
            type="submit"
            className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
            Sign in
          </button>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="src/app/signup/page.tsx">
'use client';

import { useAuth } from '@/lib/auth-context';
import { useRouter } from 'next/navigation';
import { useState } from 'react';

export default function SignupPage() {
  const { signUp } = useAuth();
  const router = useRouter();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await signUp(email, password);
      router.push('/');
    } catch {
      setError('Failed to create account. Please try again.');
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full space-y-8 p-8 bg-white rounded-lg shadow-lg">
        <h2 className="text-3xl font-bold text-center text-gray-900">
          Create a new account
        </h2>
        {error && (
          <p className="text-red-500 text-sm text-center">{error}</p>
        )}
        <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-gray-700">
              Email address
            </label>
            <input
              id="email"
              name="email"
              type="email"
              required
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
            />
          </div>
          <div>
            <label htmlFor="password" className="block text-sm font-medium text-gray-700">
              Password
            </label>
            <input
              id="password"
              name="password"
              type="password"
              required
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
            />
          </div>
          <button
            type="submit"
            className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
            Sign up
          </button>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="src/lib/auth-context.ts">
'use client';

import { createContext, useContext, useEffect, useState } from 'react';
import { createClient, Session, User } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
export const supabase = createClient(supabaseUrl, supabaseAnonKey);

interface AuthContextType {
  user: User | null;
  signIn: (email: string, password: string) => Promise<void>;
  signUp: (email: string, password: string) => Promise<void>;
  signOut: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    const getSession = async () => {
      const { data, error } = await supabase.auth.getSession();
      if (data?.session) {
        setUser(data.session.user);
      }
    };
    getSession();

    const { data: listener } = supabase.auth.onAuthStateChange((event, session) => {
      setUser(session?.user ?? null);
    });

    return () => {
      listener.subscription.unsubscribe();
    };
  }, []);

  const signIn = async (email: string, password: string) => {
    const { data, error } = await supabase.auth.signInWithPassword({ email, password });
    if (error) throw error;
    setUser(data.user);
  };

  const signUp = async (email: string, password: string) => {
    const { data, error } = await supabase.auth.signUp({ email, password });
    if (error) throw error;
    setUser(data.user);
  };

  const signOut = async () => {
    const { error } = await supabase.auth.signOut();
    if (error) throw error;
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{ user, signIn, signUp, signOut }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
</file>

<file path="src/lib/db.ts">
import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const prisma = globalForPrisma.prisma ?? new PrismaClient()

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma
</file>

<file path="src/lib/supabase.ts">
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.SUPABASE_URL
const supabaseAnonKey = process.env.SUPABASE_ANON_KEY

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Supabase URL and Anon Key must be defined in environment variables')
}

export const supabase = createClient(supabaseUrl, supabaseAnonKey)
</file>

<file path="src/middleware.ts">
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

const protectedRoutes = ['/']

export async function middleware(request: NextRequest) {
  const res = NextResponse.next()
  const supabase = createMiddlewareClient({ req: request, res })

  const {
    data: { session },
  } = await supabase.auth.getSession()

  if (!session && protectedRoutes.includes(request.nextUrl.pathname)) {
    return NextResponse.redirect(new URL('/login', request.url))
  }

  return res
}
</file>

<file path=".prettierrc">
{
  "singleQuote": true
}
</file>

<file path="app_description.md">
the ai system driven. user starts a new interview prep objective, for example junior php laravel .
it creates a db for this user and this topic, tables should include all the info about user progress, the interview questions and so on.
the app is ai driven. the user gets the interview question that was not present in the db (all the questions should be verbal processed, user is recording voice messages to answer these questions (if they require typing only then user can type) ai should come up all the time with the most frequent interview questions based on the role preparation user selected. all the questions that user answered (correctly, incorrectly, not discovered) should be srsa based. user can see all his data, all the questions and progresses, should be very interactive. ai should always come up with the new interview questions based on progress and based on data we already have. user also have options like in anki , questions to repeeat, questions to study , questions to discover. then ai estimates based on the progress if the person ready for this role or not. the user should see clearly in his profile the progress he is making, and his problems also. in the profile also a nice feature to export all the progress in a nice pdf for the employer to show off the candidate knowledge in a nice and detialed way.
tech stack requirements: next.js 15+, backend as api (communication via api router) tailwind, prisma, supabase (auth, db, bucket) .
</file>

<file path="database_schema.md">
# Database Schema

## Prisma Schema
```prisma
// Data source
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model (integrates with Supabase Auth)
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  role      String   @default("user")
  
  // Relationships
  questions Question[]
  responses Response[]
  srsData   SRSData[]
}

// Question model
model Question {
  id          String   @id @default(uuid())
  content     String
  category    String   // e.g., "PHP", "Laravel", "OOP"
  difficulty  String   // "easy", "medium", "hard"
  source      String?  // AI-generated or curated
  createdAt   DateTime @default(now())
  
  // Relationships
  responses Response[]
  srsData   SRSData[]
}

// Response model (voice/text answers)
model Response {
  id          String   @id @default(uuid())
  userId      String
  questionId  String
  content     String   // Text response or audio file path
  isCorrect   Boolean?
  analysis    Json?    // AI analysis metadata
  createdAt   DateTime @default(now())
  
  // Relationships
  user     User     @relation(fields: [userId], references: [id])
  question Question @relation(fields: [questionId], references: [id])
}

// SRS (Spaced Repetition) tracking
model SRSData {
  id           String   @id @default(uuid())
  userId       String
  questionId   String
  interval     Int      @default(1)  // Days until next review
  repetitions  Int      @default(0)  // Times reviewed
  easeFactor   Float    @default(2.5) // SRS difficulty factor
  nextReview   DateTime // Next review date
  stage        String   @default("learning") // learning, review, mastered
  
  // Relationships
  user     User     @relation(fields: [userId], references: [id])
  question Question @relation(fields: [questionId], references: [id])
}

// Readiness profile
model ReadinessProfile {
  id          String   @id @default(uuid())
  userId      String   @unique
  overallScore Float    @default(0.0)
  strengths    Json     // {category: score}
  weaknesses  Json     // {category: score}
  lastUpdated DateTime @default(now())
  
  user User @relation(fields: [userId], references: [id])
}
```

## Key Relationships
1. **User-Question**: One-to-many (Users can have multiple questions)
2. **Question-Response**: One-to-many (Each question can have multiple responses)
3. **User-SRSData**: One-to-many (Each user has SRS schedules for questions)

## Indexes
```prisma
// Optimize common queries
@@index([userId, nextReview], name: "user_srs_schedule")
@@index([category, difficulty], name: "question_discovery")
@@index([userId, isCorrect], name: "performance_tracking")
```

## Supabase Integration
- Authentication via `auth.users` table
- Voice recordings stored in `storage.objects` bucket
- Row-level security enabled for all tables
</file>

<file path="delete_assistance.sh">
#!/bin/bash
rm -f NEEDS_ASSISTANCE.md
</file>

<file path="dev_todo_phase_1.md">
# Phase 1: Core System Setup

## Task List

### 1. Initialize Next.js Project with App Router
- Create a new Next.js project using the app directory structure
- Set up ESLint and Prettier for code quality
- Configure Tailwind CSS for styling

### 2. Configure Supabase Authentication
- Set up Supabase project and enable authentication
- Configure Supabase client in the Next.js project
- Implement sign-up, login, and logout functionality
- Add authentication protection to relevant routes

### 3. Setup Prisma ORM with Initial Schema
- Initialize Prisma in the project
- Define initial database schema based on requirements
- Run Prisma migrations to create database tables
- Connect Prisma to Supabase database

### 4. Implement Basic Question Management
- Create API routes for CRUD operations on questions
- Implement frontend components for viewing and managing questions
- Add basic validation for question data

### 5. Create Voice Recording Component
- Implement a voice recording component using Web Audio API
- Add functionality to save recordings to Supabase storage
- Integrate recording component with question management

## Acceptance Criteria
- Next.js project is set up with app router and Tailwind CSS
- Supabase authentication is working for sign-up, login, and logout
- Prisma is connected to Supabase database with initial schema
- Basic question management (CRUD) is functional
- Voice recording component is working and integrated with question management
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  db:
    image: postgres:15
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: prepai
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5433:5432"
    networks:
      - prepai-network

  app:
    build: ./prepai
    environment:
      DATABASE_URL: postgres://postgres:postgres@db:5432/prepai
      NEXT_PUBLIC_SUPABASE_URL: ${NEXT_PUBLIC_SUPABASE_URL}
      NEXT_PUBLIC_SUPABASE_ANON_KEY: ${NEXT_PUBLIC_SUPABASE_ANON_KEY}
    ports:
      - "3001:3000"
    depends_on:
      - db
    networks:
      - prepai-network

volumes:
  postgres_data:

networks:
  prepai-network:
    driver: bridge
</file>

<file path="Dockerfile">
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
COPY prisma ./prisma/

RUN npm install
RUN npx prisma generate

COPY . .

RUN npm run build

CMD ["npm", "run", "dev"]
</file>

<file path="jest.setup.ts">
import '@testing-library/jest-dom';
</file>

<file path="master_development_plan.md">
# Master Development Plan

## Project Overview
AI-driven interview preparation system with:
- Voice-based question answering
- SRS-based question management
- Progress analytics
- PDF report generation

## Tech Stack
- **Frontend**: Next.js 15+ with Tailwind
- **Backend**: Next.js API routes
- **Database**: Supabase (PostgreSQL) via Prisma
- **Storage**: Supabase bucket for voice recordings

## Development Phases

### Phase 1: Core System Setup
1. Initialize Next.js project with app router
2. Configure Supabase authentication
3. Setup Prisma ORM with initial schema
4. Implement basic question management
5. Create voice recording component

### Phase 2: AI Integration
1. Implement question generation service
2. Add SRS scheduling logic
3. Create progress tracking system
4. Develop basic analytics dashboard

### Phase 3: Advanced Features
1. PDF report generation
2. Anki-like study modes
3. Voice transcription service
4. Readiness assessment algorithm

### Phase 4: Polish & Deployment
1. UI/UX refinements
2. Performance optimization
3. Testing and QA
4. Deployment pipeline setup

## Phase Priority
Focus on completing Phase 1 before proceeding to subsequent phases. Estimated timeline: 2 weeks per phase.
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="postcss.config.js">
module.exports = {
  plugins: {
    'postcss-import': {},
    'tailwindcss': {},
    'autoprefixer': {},
  },
}
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="project_manifest.json">
{
  "project_root": "./",
  "paths": {
    "log_file": "logs/system_events.log",
    "cct_config": ".cct_config.json",
    "work_items_dir": "work_items/",
    "active_plan_file": "FIX_PLAN.md",
    "signal_files": {
      "needs_assistance": "NEEDS_ASSISTANCE.md",
      "needs_refactor": "NEEDS_REFACTOR.md",
      "commit_complete": "COMMIT_COMPLETE.md",
      "tech_lead_approved": "TECH_LEAD_APPROVED.md",
      "qa_approved": "QA_APPROVED.md"
    }
  }
}
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="system_architecture.md">
# System Architecture

## Overview
The system follows a layered architecture with clear separation of concerns:
1. **Presentation Layer**: Next.js frontend
2. **Application Layer**: API routes and services
3. **Domain Layer**: Business logic and AI services
4. **Data Layer**: Database and storage

## Component Diagram

```mermaid
graph TD
    A[Frontend] -->|API Calls| B[Next.js API Routes]
    B --> C[Question Service]
    B --> D[User Service]
    B --> E[Analytics Service]
    C --> F[AI Generation Module]
    D --> G[Auth Service]
    E --> H[Progress Tracking]
    C --> I[Prisma ORM]
    D --> I
    E --> I
    I --> J[Supabase PostgreSQL]
    G --> K[Supabase Auth]
    A -->|Uploads| L[Supabase Storage]
```

## Key Components

### 1. Frontend (Next.js 15+)
- App router for routing
- Tailwind for styling
- Components:
  - Question Interface (voice/text input)
  - Dashboard (progress tracking)
  - Study Modes (Anki-like views)
  - Profile/Reporting

### 2. Backend Services
- **Question Service**: Manages question lifecycle (creation, SRS scheduling)
- **User Service**: Handles authentication and profile management
- **Analytics Service**: Tracks progress and generates insights
- **AI Module**: Generates questions using LLMs, analyzes responses

### 3. Data Layer
- **Prisma Schema**: 
  - User (id, email, progress)
  - Question (id, content, difficulty, category)
  - Response (id, content, correctness, timestamp)
  - SRSData (interval, nextReview)
- **Supabase Integration**: 
  - PostgreSQL for relational data
  - Bucket storage for voice recordings
  - Auth for user management

### 4. AI Integration
- **Question Generation**: Uses LLM to create role-specific questions
- **Response Analysis**: Evaluates voice/text responses
- **Readiness Algorithm**: Calculates interview preparedness

## Data Flow
1. User initiates session → Frontend requests question → Question Service
2. User responds → Response stored → AI analysis → SRS update
3. Dashboard requests data → Analytics Service → Progress visualization
</file>

<file path="tailwind.config.js">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="tailwind.config.ts">
import type { Config } from 'tailwindcss'

const config: Config = {
  content: [
    './app/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './lib/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'gradient-conic': 'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',
      },
    },
  },
  plugins: [],
}

export default config
</file>

<file path="src/app/api/questions/route.d.ts">
import { NextRequest, NextResponse } from 'next/server';

export type Question = {
  id: string;
  content: string;
  category: string;
  difficulty: string;
  createdAt: Date;
  userId: string;
};

export type CreateQuestionRequest = {
  content: string;
  category: string;
  difficulty: string;
};

export type UpdateQuestionRequest = Partial<CreateQuestionRequest>;

export type DeleteQuestionResponse = {
  message: string;
};

export type GetQuestionsResponse = Question[];

export type GetQuestionResponse = Question;

export type ErrorResponse = {
  error: string;
};

export declare function GET(req: NextRequest): Promise<NextResponse<GetQuestionsResponse | GetQuestionResponse | ErrorResponse>>;
export declare function POST(req: NextRequest): Promise<NextResponse<Question | ErrorResponse>>;
export declare function PUT(req: NextRequest): Promise<NextResponse<Question | ErrorResponse>>;
export declare function DELETE(req: NextRequest): Promise<NextResponse<DeleteQuestionResponse | ErrorResponse>>;
</file>

<file path="src/app/globals.css">
@import "tailwindcss/preflight";
@tailwind utilities;
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

import { Providers } from '@/providers';

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <Providers>
          {children}
        </Providers>
      </body>
    </html>
  );
}
</file>

<file path="src/app/page.tsx">
import Image from "next/image";

export default function Home() {
  return (
    <div className="grid grid-rows-[20px_1fr_20px] items-center justify-items-center min-h-screen p-8 pb-20 gap-16 sm:p-20 font-[family-name:var(--font-geist-sans)]">
      <p className="text-red-500">Tailwind test - this should be red</p>
      <main className="flex flex-col gap-[32px] row-start-2 items-center sm:items-start">
        <Image
          className="dark:invert"
          src="/next.svg"
          alt="Next.js logo"
          width={180}
          height={38}
          priority
        />
        <ol className="list-inside list-decimal text-sm/6 text-center sm:text-left font-[family-name:var(--font-geist-mono)]">
          <li className="mb-2 tracking-[-.01em]">
            Get started by editing{" "}
            <code className="bg-black/[.05] dark:bg-white/[.06] px-1 py-0.5 rounded font-[family-name:var(--font-geist-mono)] font-semibold">
              src/app/page.tsx
            </code>
            .
          </li>
          <li className="tracking-[-.01em]">
            Save and see your changes instantly.
          </li>
        </ol>

        <div className="flex gap-4 items-center flex-col sm:flex-row">
          <a
            className="rounded-full border border-solid border-transparent transition-colors flex items-center justify-center bg-foreground text-background gap-2 hover:bg-[#383838] dark:hover:bg-[#ccc] font-medium text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 sm:w-auto"
            href="https://vercel.com/new?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            <Image
              className="dark:invert"
              src="/vercel.svg"
              alt="Vercel logomark"
              width={20}
              height={20}
            />
            Deploy now
          </a>
          <a
            className="rounded-full border border-solid border-black/[.08] dark:border-white/[.145] transition-colors flex items-center justify-center hover:bg-[#f2f2f2] dark:hover:bg-[#1a1a1a] hover:border-transparent font-medium text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 w-full sm:w-auto md:w-[158px]"
            href="https://nextjs.org/docs?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            Read our docs
          </a>
        </div>
      </main>
      <footer className="row-start-3 flex gap-[24px] flex-wrap items-center justify-center">
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://nextjs.org/learn?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/file.svg"
            alt="File icon"
            width={16}
            height={16}
          />
          Learn
        </a>
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://vercel.com/templates?framework=next.js&utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/window.svg"
            alt="Window icon"
            width={16}
            height={16}
          />
          Examples
        </a>
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://nextjs.org?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/globe.svg"
            alt="Globe icon"
            width={16}
            height={16}
          />
          Go to nextjs.org →
        </a>
      </footer>
    </div>
  );
}
</file>

<file path="src/providers.tsx">
'use client';

import React from 'react';
import { AuthProvider } from './lib/auth-context';

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <AuthProvider>
      {children}
    </AuthProvider>
  );
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

/src/generated/prisma
</file>

<file path="eslint.config.mjs">
import js from "@eslint/js";
import globals from "globals";
import tseslint from "typescript-eslint";
import pluginReact from "eslint-plugin-react";
import { defineConfig } from "eslint/config";


export default defineConfig([
  { files: ["**/*.{js,mjs,cjs,ts,mts,cts,jsx,tsx}"], plugins: { js }, extends: ["js/recommended"] },
  { files: ["**/*.{js,mjs,cjs,ts,mts,cts,jsx,tsx}"], languageOptions: { globals: globals.browser } },
  tseslint.configs.recommended,
  pluginReact.configs.flat.recommended,
]);
</file>

<file path="jest.config.js">
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  transform: {
    '^.+\\.tsx?$': 'ts-jest',
  },
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
    '^./route$': '<rootDir>/__mocks__/route.ts',
  },
  globals: {
    'ts-jest': {
      tsconfig: 'tsconfig.json',
      stringifyContentPathRegex: '\\.svg$',
    }
  },
  transformIgnorePatterns: ['<rootDir>/node_modules/'],
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
  testMatch: ['**/?(*.)+(spec|test).[tj]s?(x)'],
  modulePathIgnorePatterns: [],
  setupFilesAfterEnv: ['<rootDir>/jest.setup.ts']
};
</file>

<file path="NEEDS_REFACTOR.md">
## Refactoring Needed: Tests Deletion

The commit deleted the test file `src/app/api/questions/route.test.ts` without replacing it with equivalent tests. This is a serious regression in test coverage.

### Required Actions:
1. Re-implement unit tests for all CRUD operations in the questions API
2. Ensure tests cover all edge cases and error scenarios
3. Maintain at least the same level of test coverage as before the deletion
4. Add new tests for the additional CRUD operations (GET, PUT, DELETE)

### Implementation Guidance:
- Recreate the test file with Jest tests for each endpoint
- Cover authentication, validation, and database interaction scenarios
- Use the existing test patterns as a reference for implementation
- Ensure tests run successfully with `npm test -- --watchAll=false`

Please address these issues before resubmitting for review.
</file>

<file path=".roo/rules-orchestrator/rules.md">
## 1. IDENTITY & PERSONA
You are the **Orchestrator AI** (🤖 Orchestrator). You are the manifest-driven master router. Your one-shot job is to read `project_manifest.json` and hand off control based on the signals and state defined within it, including master plan progression.

## 2. THE CORE MISSION
Your mission is to perform a single, definitive analysis of the repository state *as defined by `project_manifest.json`*. You will check system health, detect loops, and then hand off to the appropriate specialist based on a strict priority of signals.

## 3. THE ORCHESTRATION DECISION TREE (MANDATORY & IN ORDER)

### **Step 1: Read the Master Manifest**
1.  If `project_manifest.json` does not exist, hand off to `<mode>architect</mode>` to initialize the project. **Terminate here.**
2.  If manifest exists, read its contents. All subsequent file paths (`log_file`, `signal_files`, `active_plan_file`, etc.) MUST be from this manifest.

### **Step 2: System Sanity & Loop Detection**
1.  Run `mkdir -p logs`.
2.  Check codebase index sanity (`roo codebase:index` if needed).
3.  Analyze `log_file` for loops. If a loop is detected, escalate to `<mode>system-supervisor</mode>`. **Terminate here.**

### **Step 3: State-Based Handoff (Strict Priority Order)**
*For each condition met, LOG to `log_file`, ANNOUNCE, and SWITCH mode.*

1.  **If `PROJECT_VERIFIED_AND_COMPLETE.md` exists:**
    *   **Log:** `echo '{"timestamp": "...", "agent": "Orchestrator", "event": "project_complete", "details": "Final completion signal detected."}' >> [log_file]`
    *   **Announce:** "Project has been fully verified and completed by QA. System shutting down."
    *   **Terminate.**

2.  **If `needs_assistance` signal file exists:**
    *   Handoff to `<mode>emergency</mode>`.

3.  **If `needs_refactor` signal file exists:**
    *   Handoff to `<mode>developer</mode>`.

4.  **If `qa_approved` signal file exists:**
    *   Handoff to `<mode>janitor</mode>`.

5.  **If `tech_lead_approved` signal file exists:**
    *   Handoff to `<mode>qa-engineer</mode>`.

6.  **If `commit_complete` signal file exists:**
    *   Handoff to `<mode>tech-lead</mode>`.

7.  **If `active_plan_file` is complete (no `[ ]` tasks) AND `master_development_plan.md` exists with incomplete phases:**
    *   **Log:** `echo '{"timestamp": "...", "agent": "Orchestrator", "event": "handoff", "target_agent": "Architect", "details": "Current phase complete. Requesting plan for next phase from master plan."}' >> [log_file]`
    *   **Announce:** "Current development phase is complete. Handing off to Architect to plan the next phase."
    *   Handoff to `<mode>architect</mode>`.

8.  **If any file in `work_items_dir` has `status: "open"`:**
    *   Handoff to `<mode>architect</mode>`.

9.  **If `active_plan_file` in manifest is not null AND has incomplete tasks `[ ]`:**
    *   Handoff to `<mode>developer</mode>`.

10. **Default - If none of the above:**
    *   **Log:** `echo '{"timestamp": "...", "agent": "Orchestrator", "event": "idle", "details": "No actionable signals or tasks."}' >> [log_file]`
    *   **Announce:** "System is idle. No active tasks or signals detected."
    *   **Terminate.**
</file>

<file path=".roo/rules-qa-engineer/rules.md">
## 1. IDENTITY & PERSONA
You are the **AI QA Engineer** (acceptance-tester). You are the ultimate gatekeeper of quality, verifying that features not only work technically but also fulfill the overall project vision as described in master planning documents.

## 2. NON-INTERACTIVE COMMANDS (MANDATORY)
All shell commands you execute must be non-interactive. Use flags like `-y` or `--force`.

## 3. THE ACCEPTANCE WORKFLOW

### **Step 0: Read the Manifest**
*   Read `project_manifest.json` to get all relevant paths.

### **Step 1: Acknowledge & Clean Up**
*   Announce the start of acceptance testing and delete the `tech_lead_approved` signal file.

### **Step 2: Perform Verification**
*   Consult the relevant `work_items/*.md` or `active_plan_file`.
*   Run all verification and E2E tests non-interactively (e.g., `cd [project_root] && npm test -- --watchAll=false`).

### **Step 3: Decision & Finality Check (CRITICAL)**
*   **If tests fail or requirements are not met:**
    *   Create the `needs_refactor` signal file with detailed feedback.
    *   Announce & Log: "Feature FAILED acceptance testing. Sending back to developer."
*   **If tests pass and requirements are met:**
    *   Create the `qa_approved` signal file to allow the Janitor to run.
    *   **Perform Finality Check:**
        1.  Check if a `master_development_plan.md` file exists.
        2.  If it exists, check if ALL phases/tasks within it are marked as complete `[x]`.
        3.  **If all phases in the master plan are complete:**
            *   **Announce & Log:** "Final phase approved! Project is now complete."
            *   Create an empty file named `PROJECT_VERIFIED_AND_COMPLETE.md`.
        4.  **If the master plan is NOT yet complete:**
            *   **Announce & Log:** "Feature has passed acceptance testing. The project is not yet fully complete. Ready for next phase."

### **Step 4: Handoff**
*   Switch mode to `<mode>orchestrator</mode>`.
</file>

<file path=".roo/rules-system-supervisor/rules.md">
## 1. IDENTITY & PERSONA
You are the **System_Supervisor AI** (👑 Supervisor). You are the ultimate meta-agent that repairs the system's workflow logic. You operate by reading the `project_manifest.json` to find and analyze the system log.

## 2. THE CORE MISSION & TRIGGER
You are activated by the `Orchestrator` during an infinite loop. Your mission is to diagnose the flawed workflow by analyzing the log file and rewrite an agent's rules to correct it.

## 3. THE META-ANALYSIS & REPAIR WORKFLOW

1.  **Read the Manifest:** Read `project_manifest.json` to get the `log_file` path.
2.  **Ingest System State:**
    *   `echo '{"timestamp": "...", "agent": "System_Supervisor", "event": "action_start", "details": "Activated to resolve system-level failure."}' >> [log_file]`

3.  **Perform Root Cause Analysis on the *Workflow*:**
    *   **Analyze the Logs:** Read the `log_file` to trace the sequence of agent handoffs that led to the loop.
    *   **Analyze the Rules:** Read the `.roo/rules-*.md` files for the involved agents.
    *   **Identify & Log the Flaw:** Pinpoint the exact rule conflict causing the failure.
    *   `echo '{"timestamp": "...", "agent": "System_Supervisor", "event": "diagnosis", "details": "Identified logical flaw: [Concise description]"}' >> [log_file]`

4.  **Formulate a Rule-Based Solution:**
    *   Identify the target agent whose rules must be changed.
    *   Draft a new, corrected version of that agent's `rules.md` file.

5.  **Execute the System Refactor:**
    *   **Action:** Replace the content of `[path_to_agent_rules.md]` with the new ruleset.
    *   `echo '{"timestamp": "...", "agent": "System_Supervisor", "event": "action_complete", "details": "Applied fix by rewriting rules for agent: [Agent Name]."}' >> [log_file]`

6.  **Announce Fix & Handoff:**
    *   Announce: "System workflow repaired. I have updated the rules for the `[Agent Name]`. Retrying operation."
    *   Switch mode back to `<mode>orchestrator</mode>`.

## 4. CRITICAL DIRECTIVES
*   You only modify `.md` rule files.
*   Make the smallest, most targeted change possible.
*   You are forbidden from modifying your own `rules.md` file.
*   Explain your reasoning in your announcement and logs.
</file>

<file path=".roo/custom_modes.yaml">
---
customModes:
  - slug: product-manager
    name: Product Manager
    roleDefinition: >-
      You are the **Product Manager AI** (📈). You interpret the initial `app_description.md` to create the `master_development_plan.md` and seed the backlog with the first work item. You are the true starting point of the factory.
    groups: [read, edit, command, mcp]
    source: global

  - slug: orchestrator
    name: Orchestrator
    roleDefinition: >-
      You are the **Orchestrator AI** (🤖). Your one-shot job is to analyze repo state and hand off control. You are the master router.

      #### Decision Tree (Strict Priority):
      1. **Project Init:** If `app_description.md` exists but `project_manifest.json` doesn't, switch to `<mode>product-manager</mode>`.
      2. **Loop Detection:** If looping, switch to `<mode>system-supervisor</mode>`.
      3. **Escalations:** Check for `NEEDS_ASSISTANCE.md` or `NEEDS_ARCHITECTURAL_REVIEW.md`.
      4. **Refactor:** If `NEEDS_REFACTOR.md` exists, switch to `<mode>developer</mode>`.
      5. **Janitor:** If `QA_APPROVED.md` exists, switch to `<mode>janitor</mode>`.
      6. **QA Review:** If `TECH_LEAD_APPROVED.md` exists, switch to `<mode>qa-engineer</mode>`.
      7. **Tech Lead Review:** If `COMMIT_COMPLETE.md` exists, switch to `<mode>tech-lead</mode>`.
      8. **Work Item Intake:** If an open ticket exists in `work_items/`, switch to `<mode>architect</mode>`.
      9. **Development:** If an incomplete plan exists, switch to `<mode>developer</mode>`.
      10. **Idle:** If no signals, terminate.
    groups: [read, edit, command, mcp]
    source: global

  - slug: architect
    name: Architect
    roleDefinition: >-
      You are the **Architect AI** (🧠). You translate vision into executable plans. You create the `project_manifest.json` and all technical plans (`dev_todo_*.md`).
    groups: [read, edit, command, browser, mcp]
    source: global

  - slug: developer
    name: Developer
    roleDefinition: >-
      You are the **Developer AI** (👨‍💻). You implement tasks via a TDD cycle and commit directly. Your top priority is addressing `NEEDS_REFACTOR.md` feedback, otherwise you work on the current plan. On completion, you create `COMMIT_COMPLETE.md` and hand off. On failure, create `NEEDS_ASSISTANCE.md`.
    groups: [read, edit, command, mcp]
    source: global

  - slug: tech-lead
    name: Tech Lead (Supervisor)
    roleDefinition: >-
      You are the **AI Tech Lead** ( supervisor). You are the guardian of code quality. Triggered by `COMMIT_COMPLETE.md`, you review the latest commit for technical excellence. You approve by creating `TECH_LEAD_APPROVED.md` or reject by creating `NEEDS_REFACTOR.md`.
    groups: [read, command, browser, mcp]
    source: global

  - slug: qa-engineer
    name: QA Engineer (Acceptance Tester)
    roleDefinition: >-
      You are the **AI QA Engineer** ( acceptance-tester). You are the voice of the user. Triggered by `TECH_LEAD_APPROVED.md`, you verify that features meet business requirements. You approve with `QA_APPROVED.md` or reject with `NEEDS_REFACTOR.md`.
    groups: [read, command, browser, mcp]
    source: global

  - slug: janitor
    name: Janitor (Tool Maintainer)
    roleDefinition: >-
      You are **The Janitor** (🧹). You are a background process AI. Triggered by `QA_APPROVED.md`, you synchronize the vector database (`cct update`) with the files changed in the latest commit.
    groups: [read, command, mcp]
    source: global

  - slug: emergency
    name: Emergency
    roleDefinition: >-
      You are the **Emergency AI** (🚨). You are a tactical fail-safe. You are triggered by `NEEDS_ASSISTANCE.md`. You diagnose the atomic failure using `cct query`, create a `FIX_PLAN.md`, and then **delete `NEEDS_ASSISTANCE.md`** to break loops before handing off.
    groups: [read, edit, command, browser, mcp]
    source: global

  - slug: system-supervisor
    name: System Supervisor (Meta-Agent)
    roleDefinition: >-
      You are the **System_Supervisor AI** (👑). You are the meta-agent that fixes the system itself. Triggered by the Orchestrator on infinite loops, you diagnose the faulty workflow by analyzing agent rules and logs, then rewrite the rules of the failing agent to correct the system's logic.
    groups: [read, edit, command, browser, mcp]
    source: global
</file>

<file path="src/lib/auth-context.tsx">
'use client';

import React from 'react';
import { createContext, useContext, useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { supabase } from './supabase';
import { User } from '@supabase/supabase-js';

interface AuthContextType {
  user: User | null;
  loading: boolean;
  error: string | null;
  signIn: (email: string, password: string) => Promise<{ error: string | null }>;
  signUp: (email: string, password: string) => Promise<{ error: string | null }>;
  signOut: () => Promise<void>;
  clearError: () => void;
}

const AuthContext = createContext<AuthContextType>({
  user: null,
  loading: true,
  error: null,
  signIn: async () => ({ error: null }),
  signUp: async () => ({ error: null }),
  signOut: async () => {},
  clearError: () => {},
});

export const AuthProvider = ({ children }: { children: React.ReactNode }): React.JSX.Element => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  useEffect(() => {
    const { data: authListener } = supabase.auth.onAuthStateChange(
      async (event, session) => {
        setUser(session?.user ?? null);
        setLoading(false);
      }
    );

    return () => {
      authListener?.subscription.unsubscribe();
    };
  }, []);

  const handleAuthOperation = async (
    operation: () => Promise<{ error: { message: string } | null }>
  ): Promise<{ error: string | null }> => {
    setLoading(true);
    setError(null);
    try {
      const { error } = await operation();
      if (error) {
        setError(error.message);
        return { error: error.message };
      }
      return { error: null };
    } catch (err: unknown) {
      const error = err as Error;
      setError(error.message);
      return { error: error.message };
    } finally {
      setLoading(false);
    }
  };

  const value: AuthContextType = {
    user,
    loading,
    error,
    signIn: (email, password) =>
      handleAuthOperation(() =>
        supabase.auth.signInWithPassword({ email, password })
      ),
    signUp: (email, password) =>
      handleAuthOperation(() =>
        supabase.auth.signUp({ email, password })
      ),
    signOut: async () => {
      setLoading(true);
      try {
        await supabase.auth.signOut();
        router.push('/login');
      } catch (err: unknown) {
        const error = err as Error;
        setError(error.message);
      } finally {
        setLoading(false);
      }
    },
    clearError: () => setError(null),
  };

  return (
    <AuthContext.Provider value={value}>
      {!loading && children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
</file>

<file path="current_task.md">
# Current Task: Re-implement Unit Tests for Questions API

## Task Description
Re-implement the unit tests for all CRUD operations in the questions API that were deleted in the previous commit.

## Steps

1. **Create a new test file**: Create `src/app/api/questions/route.test.ts`
2. **Implement tests for each CRUD operation**:
   - POST: Test creation of new questions
   - GET: Test retrieval of questions (both list and single)
   - PUT: Test updating existing questions
   - DELETE: Test deletion of questions
3. **Cover edge cases and error scenarios**:
   - Authentication errors
   - Validation errors
   - Database errors
4. **Ensure tests run successfully**: Verify with `npm test -- --watchAll=false`

## Implementation Details

- Use Jest for testing
- Mock Prisma and Supabase dependencies
- Follow the same test patterns as the deleted tests
- Ensure 100% coverage of the API endpoints
</file>

<file path=".roo/rules-emergency/rules.md">
## 1. IDENTITY & PERSONA
You are the **Emergency Intervention AI** (🚨 Emergency). You are a manifest-driven diagnostician. You use the `architectural_map` and the `<codebase_search>` tool to rapidly pinpoint the source of an error.

## 2. THE CORE MISSION & TRIGGER
Triggered by a `needs_assistance` signal, your mission is to diagnose the failure, create a `FIX_PLAN.md`, and register it in the manifest.

## 3. THE INTERVENTION WORKFLOW

1.  **Read the Manifest:** Read `project_manifest.json` to get all file paths and the `architectural_map`.
2.  **Analyze Failure Signal:** Read the contents of the `needs_assistance` signal file to get the error message and context.
3.  **Diagnose with Codebase Search (Targeted):**
    *   First, try a direct query using the `<codebase_search>` tool:
        <codebase_search>
        <query>[verbatim error message from needs_assistance file]</query>
        </codebase_search>
    *   If that is inconclusive, read the developer's notes in the signal file to identify the architectural concept (e.g., "The error is in the user session logic").
    *   Look up the concept (e.g., "authentication") in the `architectural_map`.
    *   Run the high-quality query from the map using the `<codebase_search>` tool:
        <codebase_search>
        <query>[query from manifest's architectural_map]</query>
        </codebase_search>
4.  **Formulate and Register Fix Plan:**
    *   Create a `FIX_PLAN.md` with precise steps.
    *   Update the `active_plan_file` in `project_manifest.json` to point to `FIX_PLAN.md`.
5.  **Consume Distress Signal:**
    *   Delete the `needs_assistance` signal file.
    *   Log and announce the resolution.
6.  **Handoff:** Switch to `<mode>orchestrator</mode>`.
</file>

<file path=".roo/rules-janitor/rules.md">
## 1. IDENTITY & PERSONA
You are **The Janitor**. You are a manifest-driven background process AI. Your only purpose is to perform post-approval maintenance.

## 2. THE CORE MISSION
Triggered by the `qa_approved` signal, your job is to perform post-approval cleanup. The vector database is updated automatically.

## 3. THE MAINTENANCE WORKFLOW
1.  **Read the Manifest:** Read `project_manifest.json` to get all file paths.
2.  **Acknowledge & Clean Up Signal:**
    *   **Announce & Log:** "Final approval received. Performing post-commit maintenance."
    *   `echo '{"timestamp": "...", "agent": "Janitor", "event": "action_start", "details": "Starting post-commit maintenance."}' >> [log_file]`
    *   Delete the `qa_approved` signal file.
3.  **Announce & Handoff:**
    *   **Announce:** "Post-commit cleanup complete."
    *   `echo '{"timestamp": "...", "agent": "Janitor", "event": "action_complete", "details": "Cleanup complete."}' >> [log_file]`
    *   Switch mode to `<mode>orchestrator</mode>`.
</file>

<file path=".roo/rules-tech-lead/rules.md">
## 1. IDENTITY & PERSONA
You are the **AI Tech Lead** (supervisor). You are the guardian of code quality and architectural integrity. You use the `project_manifest.json` and the `<codebase_search>` tool to perform informed reviews.

## 2. NON-INTERACTIVE COMMANDS (MANDATORY)
All shell commands you execute must be non-interactive. Use flags like `-y`, `--force`, or specific flags like `-- --watchAll=false` for test runners.

## 3. THE REVIEW WORKFLOW

1.  **Read the Manifest:** Read `project_manifest.json` to get all paths.
2.  **Acknowledge & Clean Up:** Announce review, log it, and delete the `commit_complete` signal file.
3.  **Identify Changes and Generate Context Query:**
    *   Use `git show --summary` to get the diff and the commit message.
    *   From the commit message, extract the main subject line (the first line). This will be your search query. For example, if the commit is `feat(ui): implement dark mode theming`, your query is "implement dark mode theming".
4.  **Gather Context with Code Search:**
    *   Execute the `<codebase_search>` tool using the commit subject as the query.
        <codebase_search>
        <query>[Commit subject line you extracted]</query>
        </codebase_search>
    *   **Fallback:** If the `codebase_search` tool fails or returns no results, log a warning and proceed with the review using only the `git show` diff. You must still make a decision.
5.  **Perform Analysis:**
    *   Run static analysis (`npm test -- --watchAll=false`) within the `project_root`.
    *   **Semantic Review:** Based on the search results and the diff, does the new code align with the existing architecture and the feature's intent?
6.  **Decision & Action:**
    *   **If Approved:** Create the `tech_lead_approved` signal file. Log approval.
    *   **If Rejected:** Create the `needs_refactor` signal file with specific, actionable feedback. Log rejection.
7.  **Handoff:** Switch to `<mode>orchestrator</mode>`.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es6",
    "lib": [
      "dom",
      "es6"
    ],
    "module": "esnext",
    "jsx": "preserve",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "./src/*"
      ]
    },
    "allowJs": true,
    "noEmit": true,
    "incremental": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": [
    "src/**/*",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}
</file>

<file path=".roo/rules-architect/rules.md">
## 1. IDENTITY & PERSONA
You are the **Architect AI** (🧠 Architect). You are the master cartographer of the codebase, responsible for creating and maintaining `project_manifest.json` and all planning documents.

## 2. NON-INTERACTIVE COMMANDS (MANDATORY)
All shell commands you execute must be non-interactive. Use flags like `--yes`, `-y`, or `--force`.

## 3. CORE WORKFLOWS

### **Task Classification (CRITICAL DETAIL)**
When synthesizing a plan, you MUST classify each task to guide the final testing phase. Prefix each task with one of the following tags:
*   **(LOGIC)**: For backend code, business logic, APIs, data models, etc. **These tasks WILL be tested in a final phase.**
*   **(UI)**: For presentational components, HTML structure, CSS styling, etc. **These tasks will NOT get dedicated tests.**

### **Workflow Trigger: New Project**
*   If `project_manifest.json` does NOT exist, create it.
*   Create a `master_development_plan.md`. It must list all feature phases and conclude with a final, separate testing phase.
*   **Example `master_development_plan.md`:**
    ```markdown
    # Master Development Plan

    - [ ] Phase 1: User Authentication
    - [ ] Phase 2: Product Catalog
    - [ ] Phase 3: Final Testing
    ```

### **Workflow Trigger: Next Development Phase**
*   If activated for a new phase (and the next phase in the master plan is NOT "Final Testing"), identify the next incomplete feature phase.
*   Create a new detailed, **tagged** plan file (e.g., `dev_todo_phase_2.md`).
*   Update `paths.active_plan_file` in the manifest to point to the new plan.
*   Handoff to `<mode>orchestrator</mode>`.

### **Workflow Trigger: Final Testing Phase**
*   If activated and the next incomplete phase in the master plan IS "Final Testing":
    1.  Announce: "All feature development is complete. Generating the final test plan."
    2.  Scan all previous `dev_todo_*.md` files from the project.
    3.  Create a new file named `final_test_plan.md`.
    4.  For every task marked with `(LOGIC)` in the previous plans, add a corresponding test-writing task to the new plan.
    *   **Example `final_test_plan.md`:**
        ```markdown
        # Final Testing Plan

        - [ ] (TEST) Write and pass tests for user authentication API endpoint.
        - [ ] (TEST) Write and pass tests for session creation and validation logic.
        ```
    5.  Update `paths.active_plan_file` in the manifest to point to `final_test_plan.md`.
    6.  Handoff to `<mode>orchestrator</mode>`. The Developer will then be triggered to execute this test plan.
</file>

<file path=".roo/rules-developer/rules.md">
## 1. IDENTITY & PERSONA
You are the **Developer AI** (👨‍💻 Developer). You are a specialist who implements tasks as defined in the active plan. Your focus is on direct feature implementation.

## 2. NON-INTERACTIVE COMMANDS (MANDATORY)
All shell commands you execute must be non-interactive. Use flags like `-y`, `--yes`, or `--force`.

## 3. THE TACTICAL PLANNING & EXECUTION CYCLE (MANDATORY)

### **Step 0: Setup & Cleanup**
1.  **Read the Manifest:** Read `project_manifest.json` into your context to get all necessary paths.
2.  **Ensure Clean Slate:** Close all open editor tabs.
    ```javascript
    vscode.commands.executeCommand('workbench.action.closeAllEditors');
    ```

### **Step 1: Tactical Breakdown**
1.  Prioritize any `needs_refactor` signal file.
2.  Otherwise, read the `active_plan_file` and identify the first incomplete objective `[ ]`.
3.  **Gather Context:** Use the `<codebase_search>` tool to query for relevant code context based on the task description.
4.  Create a detailed, step-by-step tactical plan in `current_task.md`.

### **Step 2: Execute Tactical Plan (Direct Implementation)**
1.  **Announce & Log:** "Implementing task: [Task Description]."
2.  Execute the plan from `current_task.md` by writing or modifying the necessary code files directly.
3.  **IMPORTANT: Testing is deferred to a final project phase.** You will not write or run unit/integration tests at this stage, regardless of the task type.

### **Step 3: Finalize and Commit (Success Only)**
1.  Mark the original objective in the `active_plan_file` as complete `[x]`.
2.  Delete `current_task.md`.
3.  Commit all changes: `cd [project_root] && git add . && git commit -m "feat: Complete task: [Task Description]"`.
4.  Create the `commit_complete` signal file.
5.  Handoff to `<mode>orchestrator</mode>`.

### **Step 4: Failure & Escalation Protocol (CRITICAL)**
If you encounter an unrecoverable error:
1.  **HALT** immediately. Do not commit or use the `attempt_completion` tool.
2.  Create `NEEDS_ASSISTANCE.md` with a detailed error summary.
3.  Announce & Log the failure.
4.  Handoff to `<mode>orchestrator</mode>`.
</file>

<file path="src/app/api/questions/route.test.ts">
import { NextRequest } from 'next/server';
import * as route from './route';
import { prisma } from '@/lib/db';
import { supabase } from '@/lib/supabase';

// Mock Prisma and Supabase
jest.mock('@/lib/db', () => ({
  prisma: {
    question: {
      create: jest.fn(),
      findMany: jest.fn(),
      findUnique: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
    },
  },
}));

jest.mock('@/lib/supabase', () => ({
  supabase: {
    auth: {
      getUser: jest.fn(),
    },
  },
}));

const mockCreate = prisma.question.create as jest.Mock;
const mockFindMany = prisma.question.findMany as jest.Mock;
const mockFindUnique = prisma.question.findUnique as jest.Mock;
const mockUpdate = prisma.question.update as jest.Mock;
const mockDelete = prisma.question.delete as jest.Mock;
const mockGetUser = supabase.auth.getUser as jest.Mock;

describe('CRUD operations for questions', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('POST /api/questions', () => {
    it('should return 401 if unauthorized', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: null },
        error: new Error('Not authenticated'),
      });

      const req = new NextRequest('http://localhost/api/questions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: 'Test question',
          category: 'general',
          difficulty: 'easy',
        }),
      });

      const response = await route.POST(req);
      expect(response.status).toBe(401);
      expect(await response.json()).toEqual({ error: 'Unauthorized' });
    });

    it('should create a new question with valid data', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      const mockQuestion = {
        id: '1',
        content: 'Test question',
        category: 'general',
        difficulty: 'easy',
        userId: 'user-id',
        createdAt: new Date(),
      };
      mockCreate.mockResolvedValue(mockQuestion);

      const req = new NextRequest('http://localhost/api/questions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: 'Test question',
          category: 'general',
          difficulty: 'easy',
        }),
      });

      const response = await route.POST(req);
      expect(response.status).toBe(201);
      expect(await response.json()).toEqual(mockQuestion);
    });

    it('should return 400 if missing required fields', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      const req = new NextRequest('http://localhost/api/questions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({}),
      });

      const response = await route.POST(req);
      expect(response.status).toBe(400);
      expect(await response.json()).toEqual({ error: 'Missing required fields' });
    });

    it('should return 400 if field types are invalid', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      const req = new NextRequest('http://localhost/api/questions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: 123,
          category: 'general',
          difficulty: 'easy',
        }),
      });

      const response = await route.POST(req);
      expect(response.status).toBe(400);
      expect(await response.json()).toEqual({ error: 'Invalid field types' });
    });

    it('should return 500 on database error', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });
      mockCreate.mockRejectedValue(new Error('Database error'));

      const req = new NextRequest('http://localhost/api/questions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: 'Test question',
          category: 'general',
          difficulty: 'easy',
        }),
      });

      const response = await route.POST(req);
      expect(response.status).toBe(500);
      expect(await response.json()).toEqual({ error: 'Internal server error' });
    });
  });

  describe('GET /api/questions', () => {
    it('should return 401 if unauthorized', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: null },
        error: new Error('Not authenticated'),
      });

      const req = new NextRequest('http://localhost/api/questions', {
        method: 'GET',
      });

      const response = await route.GET(req);
      expect(response.status).toBe(401);
      expect(await response.json()).toEqual({ error: 'Unauthorized' });
    });

    it('should return all questions for the user', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      const mockQuestions = [
        {
          id: '1',
          content: 'Test question 1',
          category: 'general',
          difficulty: 'easy',
          userId: 'user-id',
          createdAt: new Date(),
        },
        {
          id: '2',
          content: 'Test question 2',
          category: 'general',
          difficulty: 'easy',
          userId: 'user-id',
          createdAt: new Date(),
        },
      ];
      mockFindMany.mockResolvedValue(mockQuestions);

      const req = new NextRequest('http://localhost/api/questions', {
        method: 'GET',
      });

      const response = await route.GET(req);
      expect(response.status).toBe(200);
      expect(await response.json()).toEqual(mockQuestions);
    });

    it('should return a single question by ID', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      const mockQuestion = {
        id: '1',
        content: 'Test question',
        category: 'general',
        difficulty: 'easy',
        userId: 'user-id',
        createdAt: new Date(),
      };
      mockFindUnique.mockResolvedValue(mockQuestion);

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'GET',
      });

      const response = await route.GET(req);
      expect(response.status).toBe(200);
      expect(await response.json()).toEqual(mockQuestion);
    });

    it('should return 404 if question not found', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      mockFindUnique.mockResolvedValue(null);

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'GET',
      });

      const response = await route.GET(req);
      expect(response.status).toBe(404);
      expect(await response.json()).toEqual({ error: 'Question not found' });
    });

    it('should return 500 on database error', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });
      mockFindMany.mockRejectedValue(new Error('Database error'));

      const req = new NextRequest('http://localhost/api/questions', {
        method: 'GET',
      });

      const response = await route.GET(req);
      expect(response.status).toBe(500);
      expect(await response.json()).toEqual({ error: 'Internal server error' });
    });
  });

  describe('PUT /api/questions/[id]', () => {
    it('should return 401 if unauthorized', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: null },
        error: new Error('Not authenticated'),
      });

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: 'Updated question',
        }),
      });

      const response = await route.PUT(req);
      expect(response.status).toBe(401);
      expect(await response.json()).toEqual({ error: 'Unauthorized' });
    });

    it('should update an existing question', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      const mockQuestion = {
        id: '1',
        content: 'Updated question',
        category: 'general',
        difficulty: 'easy',
        userId: 'user-id',
        createdAt: new Date(),
      };
      mockFindUnique.mockResolvedValue(mockQuestion);
      mockUpdate.mockResolvedValue(mockQuestion);

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: 'Updated question',
        }),
      });

      const response = await route.PUT(req);
      expect(response.status).toBe(200);
      expect(await response.json()).toEqual(mockQuestion);
    });

    it('should return 404 if question not found', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      mockFindUnique.mockResolvedValue(null);

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: 'Updated question',
        }),
      });

      const response = await route.PUT(req);
      expect(response.status).toBe(404);
      expect(await response.json()).toEqual({ error: 'Question not found' });
    });

    it('should return 400 if missing required fields', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({}),
      });

      const response = await route.PUT(req);
      expect(response.status).toBe(400);
      expect(await response.json()).toEqual({ error: 'Missing required fields' });
    });

    it('should return 500 on database error', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });
      mockFindUnique.mockResolvedValue({
        id: '1',
        userId: 'user-id',
      });
      mockUpdate.mockRejectedValue(new Error('Database error'));

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: 'Updated question',
        }),
      });

      const response = await route.PUT(req);
      expect(response.status).toBe(500);
      expect(await response.json()).toEqual({ error: 'Internal server error' });
    });
  });

  describe('DELETE /api/questions/[id]', () => {
    it('should return 401 if unauthorized', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: null },
        error: new Error('Not authenticated'),
      });

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'DELETE',
      });

      const response = await route.DELETE(req);
      expect(response.status).toBe(401);
      expect(await response.json()).toEqual({ error: 'Unauthorized' });
    });

    it('should delete an existing question', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      const mockQuestion = {
        id: '1',
        content: 'Test question',
        category: 'general',
        difficulty: 'easy',
        userId: 'user-id',
        createdAt: new Date(),
      };
      mockFindUnique.mockResolvedValue(mockQuestion);
      mockDelete.mockResolvedValue(undefined);

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'DELETE',
      });

      const response = await route.DELETE(req);
      expect(response.status).toBe(200);
      expect(await response.json()).toEqual({ message: 'Question deleted successfully' });
    });

    it('should return 404 if question not found', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      mockFindUnique.mockResolvedValue(null);

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'DELETE',
      });

      const response = await route.DELETE(req);
      expect(response.status).toBe(404);
      expect(await response.json()).toEqual({ error: 'Question not found' });
    });

    it('should return 500 on database error', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });
      mockFindUnique.mockResolvedValue({
        id: '1',
        userId: 'user-id',
      });
      mockDelete.mockRejectedValue(new Error('Database error'));

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'DELETE',
      });

      const response = await route.DELETE(req);
      expect(response.status).toBe(500);
      expect(await response.json()).toEqual({ error: 'Internal server error' });
    });
  });
});
</file>

<file path="src/app/api/questions/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { supabase } from '@/lib/supabase';

export async function GET(req: NextRequest) {
  try {
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const url = new URL(req.url);
    const id = url.pathname.split('/').pop();

    if (id) {
      // Get single question by ID
      const question = await prisma.question.findUnique({
        where: { id },
        include: { user: true },
      });

      if (!question || question.userId !== user.id) {
        return NextResponse.json({ error: 'Question not found' }, { status: 404 });
      }

      return NextResponse.json(question);
    } else {
      // Get all questions for the user
      const questions = await prisma.question.findMany({
        where: { userId: user.id },
        orderBy: { createdAt: 'desc' },
      });

      return NextResponse.json(questions);
    }
  } catch (error: unknown) {
    let errorMessage = 'Internal server error';
    if (error instanceof Error) {
      console.error('Database Error:', error.message);
      errorMessage = error.message;
    }

    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
}

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();

    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    if (!body || typeof body !== 'object') {
      return NextResponse.json({ error: 'Invalid request body' }, { status: 400 });
    }

    const { content, category, difficulty } = body;

    if (!content || !category || !difficulty) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    if (typeof content !== 'string' ||
        typeof category !== 'string' ||
        typeof difficulty !== 'string') {
      return NextResponse.json({ error: 'Invalid field types' }, { status: 400 });
    }

    const question = await prisma.question.create({
      data: {
        content: content.trim(),
        category: category.trim(),
        difficulty: difficulty.trim(),
        userId: user.id,
      },
    });

    return NextResponse.json(question, { status: 201 });
  } catch (error: unknown) {
    if (error instanceof SyntaxError) {
      return NextResponse.json({ error: 'Invalid JSON body' }, { status: 400 });
    }

    let errorMessage = 'Internal server error';
    if (error instanceof Error) {
      console.error('Database Error:', error.message);
      errorMessage = error.message;
    }

    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
}

export async function PUT(req: NextRequest) {
  try {
    const body = await req.json();
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const url = new URL(req.url);
    const id = url.pathname.split('/').pop();

    if (!id) {
      return NextResponse.json({ error: 'Question ID is required' }, { status: 400 });
    }

    if (!body || typeof body !== 'object') {
      return NextResponse.json({ error: 'Invalid request body' }, { status: 400 });
    }

    const { content, category, difficulty } = body;

    if ((!content || !category || !difficulty) && Object.keys(body).length > 0) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    if ((content && typeof content !== 'string') ||
        (category && typeof category !== 'string') ||
        (difficulty && typeof difficulty !== 'string')) {
      return NextResponse.json({ error: 'Invalid field types' }, { status: 400 });
    }

    const question = await prisma.question.findUnique({
      where: { id },
    });

    if (!question || question.userId !== user.id) {
      return NextResponse.json({ error: 'Question not found' }, { status: 404 });
    }

    const updatedQuestion = await prisma.question.update({
      where: { id },
      data: {
        ...(content !== undefined && { content: content.trim() }),
        ...(category !== undefined && { category: category.trim() }),
        ...(difficulty !== undefined && { difficulty: difficulty.trim() }),
      },
    });

    return NextResponse.json(updatedQuestion);
  } catch (error: unknown) {
    if (error instanceof SyntaxError) {
      return NextResponse.json({ error: 'Invalid JSON body' }, { status: 400 });
    }

    let errorMessage = 'Internal server error';
    if (error instanceof Error) {
      console.error('Database Error:', error.message);
      errorMessage = error.message;
    }

    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
}

export async function DELETE(req: NextRequest) {
  try {
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const url = new URL(req.url);
    const id = url.pathname.split('/').pop();

    if (!id) {
      return NextResponse.json({ error: 'Question ID is required' }, { status: 400 });
    }

    const question = await prisma.question.findUnique({
      where: { id },
    });

    if (!question || question.userId !== user.id) {
      return NextResponse.json({ error: 'Question not found' }, { status: 404 });
    }

    await prisma.question.delete({
      where: { id },
    });

    return NextResponse.json({ message: 'Question deleted successfully' });
  } catch (error: unknown) {
    let errorMessage = 'Internal server error';
    if (error instanceof Error) {
      console.error('Database Error:', error.message);
      errorMessage = error.message;
    }

    return NextResponse.json({ error: errorMessage }, { status: 500 });
  }
}
</file>

<file path="package.json">
{
  "name": "prepai",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "jest"
  },
  "dependencies": {
    "@prisma/client": "^6.9.0",
    "@supabase/auth-helpers-nextjs": "^0.10.0",
    "@supabase/supabase-js": "^2.50.0",
    "@testing-library/jest-dom": "^6.6.3",
    "next": "^15.3.3",
    "react": "^19.0.0",
    "react-dom": "^19.0.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@eslint/js": "^9.29.0",
    "@supabase/ssr": "^0.6.1",
    "@tailwindcss/postcss": "^4",
    "@types/jest": "^29.5.12",
    "@types/next": "^8.0.7",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.29.0",
    "eslint-config-next": "15.3.3",
    "eslint-config-prettier": "^10.1.5",
    "eslint-plugin-prettier": "^5.4.1",
    "eslint-plugin-react": "^7.37.5",
    "globals": "^16.2.0",
    "jest": "^29.7.0",
    "node-mocks-http": "^1.17.2",
    "postcss": "^8.5.6",
    "prettier": "^3.5.3",
    "tailwindcss": "^4.1.10",
    "ts-jest": "^29.1.2",
    "typescript": "^5",
    "typescript-eslint": "^8.34.1"
  }
}
</file>

</files>
