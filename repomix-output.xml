This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
__mocks__/
  route.ts
.github/
  workflows/
    ci.yml
.roo/
  rules-auditor/
    rules.md
  rules-developer/
    rules.md
  rules-dispatcher/
    rules.md
  rules-emergency/
    rules.md
  rules-planner/
    rules.md
  rules-product-manager/
    rules.md
  rules-system-supervisor/
    rules.md
  custom_modes.yaml
audit/
  repomix-output.xml
docs/
  app_description.md
  canonical_spec.md
  README.md
  SETUP_GUIDE.md
prisma/
  migrations/
    20250619140104_add_review_count_field/
      migration.sql
    migration_lock.toml
  schema.prisma
public/
  file.svg
  globe.svg
  next.svg
  vercel.svg
  window.svg
src/
  app/
    api/
      analyze-knowledge-gaps/
        route.ts
      generate-question/
        route.d.ts
        route.ts
      generate-report/
        route.ts
      questions/
        route.d.ts
        route.test.ts
        route.ts
    dashboard/
      page.tsx
    generate/
      page.tsx
    login/
      page.tsx
    questions/
      page.tsx
    signup/
      page.tsx
    globals.css
    layout.tsx
    page.tsx
  components/
    AnalyticsCharts.tsx
    AssessmentInterface.tsx
    DeckManagement.tsx
    DiscoverMode.tsx
    FlashcardStudy.tsx
    ProgressDashboard.tsx
    QuestionForm.tsx
    QuestionGeneratorForm.tsx
    ReportGenerator.tsx
    SRSControls.tsx
    VoiceRecorder.tsx
  lib/
    __tests__/
      config.test.ts
      srsModes.test.ts
    assessment.ts
    auth-context.ts
    auth-context.tsx
    db.ts
    pdf.ts
    progress.ts
    scheduler.ts
    srs.ts
    supabase.ts
    transcription.ts
  middleware.ts
  providers.tsx
tests/
  e2e/
    srsWorkflow.test.ts
.env.example
.env.local
.gitignore
.prettierrc
delete_assistance.sh
docker-compose.yml
Dockerfile
eslint.config.mjs
jest.config.js
jest.setup.ts
next.config.ts
package.json
postcss.config.js
postcss.config.mjs
README.md
tailwind.config.js
tailwind.config.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="audit/repomix-output.xml">
ðŸ“¦ Repomix v0.3.9

No custom config found at repomix.config.json5, repomix.config.jsonc, repomix.config.json or global config at /home/kasjer/.config/repomix/repomix.config.json5, /home/kasjer/.config/repomix/repomix.config.jsonc, /home/kasjer/.config/repomix/repomix.config.json.
You can add a config file for additional settings. Please check https://github.com/yamadashy/repomix for more information.
â ™ Collecting files...
[2K[1A[2K[Gâ ¹ Collect file... (6/84) .roo/rules-emergency/rules.md
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="src/app/api/analyze-knowledge-gaps/route.ts">
import { NextRequest, NextResponse } from 'next/server';

interface QuestionPerformance {
  correct: boolean;
  topics: string[];
}

export async function POST(req: NextRequest) {
  try {
    const { questionPerformance, userId } = await req.json();

    // Validate input
    if (!questionPerformance || typeof questionPerformance !== 'object' || !userId) {
      return NextResponse.json(
        { error: 'Invalid request body' },
        { status: 400 }
      );
    }

    // Analyze knowledge gaps
    const topicPerformance: Record<string, { correctCount: number, totalCount: number }> = {};

    Object.values(questionPerformance as Record<string, QuestionPerformance>).forEach(entry => {
      entry.topics.forEach(topic => {
        if (!topicPerformance[topic]) {
          topicPerformance[topic] = { correctCount: 0, totalCount: 0 };
        }
        topicPerformance[topic].totalCount += 1;
        if (entry.correct) {
          topicPerformance[topic].correctCount += 1;
        }
      });
    });

    const gaps: string[] = [];
    const suggestedQuestions: string[] = [];

    Object.entries(topicPerformance).forEach(([topic, performance]) => {
      const successRate = performance.correctCount / performance.totalCount;
      if (successRate < 0.5) {
        gaps.push(topic);
        
        // Get related questions from performance data
        const related = Object.entries(questionPerformance as Record<string, QuestionPerformance>)
          .filter(([, q]) => q.topics.includes(topic))
          .map(([id]) => id);

        suggestedQuestions.push(...related);
      }
    });

    return NextResponse.json({
      gaps: [...new Set(gaps)], // Remove duplicates
      suggestedQuestions: [...new Set(suggestedQuestions)] // Remove duplicates
    });

  } catch (error) {
    console.error('Error analyzing knowledge gaps:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/login/page.tsx">
'use client';

import { useAuth } from '@/lib/auth-context';
import { useRouter } from 'next/navigation';
import { useState } from 'react';

export default function LoginPage() {
  const { signIn } = useAuth();
  const router = useRouter();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await signIn(email, password);
      router.push('/');
    } catch (err) {
      setError('Failed to sign in. Please check your credentials.');
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full space-y-8 p-8 bg-white rounded-lg shadow-lg">
        <h2 className="text-3xl font-bold text-center text-gray-900">
          Sign in to your account
        </h2>
        {error && (
          <p className="text-red-500 text-sm text-center">{error}</p>
        )}
        <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-gray-700">
              Email address
            </label>
            <input
              id="email"
              name="email"
              type="email"
              required
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
            />
          </div>
          <div>
            <label htmlFor="password" className="block text-sm font-medium text-gray-700">
              Password
            </label>
            <input
              id="password"
              name="password"
              type="password"
              required
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
            />
          </div>
          <button
            type="submit"
            className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
            Sign in
          </button>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="src/app/signup/page.tsx">
'use client';

import { useAuth } from '@/lib/auth-context';
import { useRouter } from 'next/navigation';
import { useState } from 'react';

export default function SignupPage() {
  const { signUp } = useAuth();
  const router = useRouter();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await signUp(email, password);
      router.push('/');
    } catch {
      setError('Failed to create account. Please try again.');
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full space-y-8 p-8 bg-white rounded-lg shadow-lg">
        <h2 className="text-3xl font-bold text-center text-gray-900">
          Create a new account
        </h2>
        {error && (
          <p className="text-red-500 text-sm text-center">{error}</p>
        )}
        <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-gray-700">
              Email address
            </label>
            <input
              id="email"
              name="email"
              type="email"
              required
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
            />
          </div>
          <div>
            <label htmlFor="password" className="block text-sm font-medium text-gray-700">
              Password
            </label>
            <input
              id="password"
              name="password"
              type="password"
              required
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
            />
          </div>
          <button
            type="submit"
            className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
            Sign up
          </button>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="src/app/page.tsx">
import Image from "next/image";

export default function Home() {
  return (
    <div className="grid grid-rows-[20px_1fr_20px] items-center justify-items-center min-h-screen p-8 pb-20 gap-16 sm:p-20 font-[family-name:var(--font-geist-sans)]">
      <p className="text-red-500">Tailwind test - this should be red</p>
      <main className="flex flex-col gap-[32px] row-start-2 items-center sm:items-start">
        <Image
          className="dark:invert"
          src="/next.svg"
          alt="Next.js logo"
          width={180}
          height={38}
          priority
        />
        <ol className="list-inside list-decimal text-sm/6 text-center sm:text-left font-[family-name:var(--font-geist-mono)]">
          <li className="mb-2 tracking-[-.01em]">
            Get started by editing{" "}
            <code className="bg-black/[.05] dark:bg-white/[.06] px-1 py-0.5 rounded font-[family-name:var(--font-geist-mono)] font-semibold">
              src/app/page.tsx
            </code>
            .
          </li>
          <li className="tracking-[-.01em]">
            Save and see your changes instantly.
          </li>
        </ol>

        <div className="flex gap-4 items-center flex-col sm:flex-row">
          <a
            className="rounded-full border border-solid border-transparent transition-colors flex items-center justify-center bg-foreground text-background gap-2 hover:bg-[#383838] dark:hover:bg-[#ccc] font-medium text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 sm:w-auto"
            href="https://vercel.com/new?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            <Image
              className="dark:invert"
              src="/vercel.svg"
              alt="Vercel logomark"
              width={20}
              height={20}
            />
            Deploy now
          </a>
          <a
            className="rounded-full border border-solid border-black/[.08] dark:border-white/[.145] transition-colors flex items-center justify-center hover:bg-[#f2f2f2] dark:hover:bg-[#1a1a1a] hover:border-transparent font-medium text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 w-full sm:w-auto md:w-[158px]"
            href="https://nextjs.org/docs?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            Read our docs
          </a>
        </div>
      </main>
      <footer className="row-start-3 flex gap-[24px] flex-wrap items-center justify-center">
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://nextjs.org/learn?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/file.svg"
            alt="File icon"
            width={16}
            height={16}
          />
          Learn
        </a>
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://vercel.com/templates?framework=next.js&utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/window.svg"
            alt="Window icon"
            width={16}
            height={16}
          />
          Examples
        </a>
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://nextjs.org?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/globe.svg"
            alt="Globe icon"
            width={16}
            height={16}
          />
          Go to nextjs.org →
        </a>
      </footer>
    </div>
  );
}
</file>

<file path="src/lib/db.ts">
import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const prisma = globalForPrisma.prisma ?? new PrismaClient()

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma
</file>

<file path="src/middleware.ts">
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

const protectedRoutes = ['/']

export async function middleware(request: NextRequest) {
  const res = NextResponse.next()
  const supabase = createMiddlewareClient({ req: request, res })

  const {
    data: { session },
  } = await supabase.auth.getSession()

  if (!session && protectedRoutes.includes(request.nextUrl.pathname)) {
    return NextResponse.redirect(new URL('/login', request.url))
  }

  return res
}
</file>

<file path="Dockerfile">
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
COPY prisma ./prisma/

RUN npm install
RUN npx prisma generate

COPY . .

RUN npm run build

CMD ["npm", "run", "dev"]
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="postcss.config.js">
module.exports = {
  plugins: {
    'postcss-import': {},
    'tailwindcss': {},
    'autoprefixer': {},
  },
}
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="tailwind.config.ts">
import type { Config } from 'tailwindcss'

const config: Config = {
  content: [
    './app/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './lib/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'gradient-conic': 'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',
      },
    },
  },
  plugins: [],
}

export default config
</file>

<file path="__mocks__/route.ts">
import { NextRequest, NextResponse } from 'next/server';

export function POST(req: NextRequest) {
  return NextResponse.json({
    id: '1',
    createdAt: new Date(),
    content: 'Test question',
    category: 'general',
    difficulty: 'easy',
    source: null,
    userId: 'temp-user-id'
  }, { status: 200 });
}
</file>

<file path=".github/workflows/ci.yml">
name: CI Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: 18.x

    - name: Install dependencies
      run: npm ci

    - name: Run tests
      env:
        NODE_ENV: test
        NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
        NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
        DATABASE_URL: ${{ secrets.DATABASE_URL }}
        NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
      run: npm test

  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: 18.x

    - name: Install dependencies
      run: npm ci

    - name: Build project
      env:
        NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
        NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
      run: npm run build
</file>

<file path=".roo/rules-dispatcher/rules.md">
## 1. IDENTITY & PERSONA
You are the **Dispatcher AI** (🤖 The Conductor). You are the master router for the phase-gated factory. Your job is to read signals from the `signals/` directory and inspect the state of work files to hand off control to the correct specialist.

## 2. THE ORCHESTRATION DECISION TREE (MANDATORY & IN ORDER)
1.  **Project Completion:** If `signals/PROJECT_AUDIT_PASSED.md` exists:
    *   Announce: "Project is complete and has passed all audits. System shutting down."
    *   **Terminate.**

2.  **Developer Emergency:** If `signals/NEEDS_ASSISTANCE.md` exists:
    *   Handoff to `<mode>emergency</mode>`.

3.  **Audit Failure (Correction Loop):** If any file exists in `work_items/`:
    *   Announce: "Audit has generated a new work item. Handing off to Planner for re-planning."
    *   Handoff to `<mode>planner</mode>`.

4.  **Implementation Complete:** If `signals/IMPLEMENTATION_COMPLETE.md` exists:
    *   Announce: "Implementation marathon is finished. Handing off to Auditor."
    *   Handoff to `<mode>qa-engineer</mode>`. (This is the Auditor role)

5.  **Planning Complete (Signal):** If `signals/PLANNING_COMPLETE.md` exists:
    *   Announce: "Upfront planning is complete. Handing off to Developer."
    *   Handoff to `<mode>developer</mode>`.

6.  **In-Progress Work Detection (NEW):** If any `.md` file within `work_breakdown/tasks/` contains an incomplete task marker `[ ]`:
    *   Announce: "Incomplete development tasks detected. Resuming implementation marathon."
    *   Handoff to `<mode>developer</mode>`.

7.  **Specification Complete:** If `signals/SPECIFICATION_COMPLETE.md` exists:
    *   Announce: "Specification is complete. Handing off to Planner."
    *   Handoff to `<mode>planner</mode>`.

8.  **New Project Kick-off:** If `docs/app_description.md` exists AND `docs/canonical_spec.md` does NOT:
    *   Announce: "New project detected. Handing off to Product Manager for clarification."
    *   Handoff to `<mode>product-manager</mode>`.

9.  **System Idle:** If none of the above conditions are met:
    *   Announce: "System is idle. No actionable signals or tasks detected."
    *   **Terminate.**
</file>

<file path=".roo/rules-planner/rules.md">
## 1. IDENTITY & PERSONA
You are the **Planner AI** (🧠 The Master Planner). You are the master cartographer of the codebase. Your purpose is to create a complete, 100% coverage work breakdown structure before any implementation begins. You are obsessive about full coverage and leave no part of the specification unplanned.

## 2. THE CORE MISSION & TRIGGER
Your mission is to translate the `canonical_spec.md` into a full set of atomic implementation plans. You are triggered by the Dispatcher when the `signals/SPECIFICATION_COMPLETE.md` signal exists.

## 3. THE UPFRONT PLANNING WORKFLOW

### PHASE 1: DRAFTING THE PLAN
1.  **Acknowledge & Log:** "Specification received. Beginning 100% upfront project planning."
2.  **Create Directories:** Ensure `work_breakdown/tasks/` exists.
3.  **Consume Signal:** Delete `signals/SPECIFICATION_COMPLETE.md`.
4.  **Generate Full Work Breakdown:**
    *   Read `docs/canonical_spec.md` thoroughly.
    *   Create `work_breakdown/master_plan.md` with a high-level checklist of all features.
    *   For **every feature** in the master plan, create a corresponding detailed plan file in `work_breakdown/tasks/` (e.g., `plan-001-user-auth.md`). Each task within these files should still be tagged `(LOGIC)` or `(UI)`.

### PHASE 2: MANDATORY SELF-CORRECTION PROTOCOL
5.  **Final Sanity Check:** Before proceeding, you **must** halt and internally ask and answer the following questions. You cannot proceed until you can honestly answer "Yes" to all.
    *   "Is there a 1-to-1 mapping between every feature in `docs/canonical_spec.md` and the items in `work_breakdown/master_plan.md`?"
    *   "Does every single item in the master plan have a corresponding, detailed task file in the `work_breakdown/tasks/` directory?"
    *   "Have I accounted for all constraints and non-functional requirements mentioned in the spec within my task breakdowns?"
    *   "Can I guarantee that if the Developer completes every single task in these plan files, the resulting codebase will have 100% coverage of the specification?"
    *   If the answer to any of these is 'No' or 'I am unsure', you must return to Phase 1, correct the planning documents, and repeat this self-correction process.

### PHASE 3: ANNOUNCE & HANDOFF
6.  **Announce & Handoff (Post-Correction):**
    *   Announce: "Self-correction protocol passed. Full project plan is complete and verified to cover 100% of the specification. Handing off for implementation."
    *   Create the signal file `signals/PLANNING_COMPLETE.md`.
    *   Switch mode to `<mode>dispatcher</mode>`.
</file>

<file path="docs/app_description.md">
the ai system driven. user starts a new interview prep objective, for example junior php laravel .
it creates a db for this user and this topic, tables should include all the info about user progress, the interview questions and so on.
the app is ai driven. the user gets the interview question that was not present in the db (all the questions should be verbal processed, user is recording voice messages to answer these questions (if they require typing only then user can type) ai should come up all the time with the most frequent interview questions based on the role preparation user selected. all the questions that user answered (correctly, incorrectly, not discovered) should be srsa based. user can see all his data, all the questions and progresses, should be very interactive. ai should always come up with the new interview questions based on progress and based on data we already have. user also have options like in anki , questions to repeeat, questions to study , questions to discover. then ai estimates based on the progress if the person ready for this role or not. the user should see clearly in his profile the progress he is making, and his problems also. in the profile also a nice feature to export all the progress in a nice pdf for the employer to show off the candidate knowledge in a nice and detialed way.
tech stack requirements: next.js 15+, backend as api (communication via api router) tailwind, prisma, supabase (auth, db, bucket) .
</file>

<file path="docs/README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="docs/SETUP_GUIDE.md">
# PrepAI Project Setup Guide

## Table of Contents
1. [Prerequisites](#prerequisites)
2. [Environment Setup](#environment-setup)
3. [Installation](#installation)
4. [Configuration](#configuration)
5. [Testing](#testing)
6. [Development Workflow](#development-workflow)
7. [Production Deployment](#production-deployment)

## Prerequisites
- Node.js v18+
- npm v9+
- PostgreSQL 14+
- Supabase account

## Environment Setup
1. Clone the repository:
   ```bash
   git clone https://github.com/your-org/prepAI.git
   cd prepAI
   ```

2. Create environment files:
   ```bash
   cp .env.example .env
   touch .env.test
   ```

3. Set up Supabase:
   - Create new project in Supabase dashboard
   - Enable required extensions (pgvector, pg_trgm)
   - Get project URL and anon key

## Installation
1. Install dependencies:
   ```bash
   npm install
   ```

2. Initialize database schema:
   ```bash
   npx prisma migrate dev
   ```

## Configuration
### Environment Variables
Configure `.env` file with these required variables:
```bash
# Supabase Configuration
NEXT_PUBLIC_SUPABASE_URL=your_supabase_url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_key

# Database Configuration
DATABASE_URL=postgres://user:password@localhost:5432/prepai
```

### Test Configuration
Configure `.env.test` for testing:
```bash
NODE_ENV=test
DATABASE_URL=postgres://user:password@localhost:5432/prepai_test
```

## Testing
1. Run unit tests:
   ```bash
   npm test
   ```

2. Run integration tests:
   ```bash
   npm run test:integration
   ```

## Development Workflow
1. Start development server:
   ```bash
   npm run dev
   ```

2. Access the application:
   ```bash
   open http://localhost:3000
   ```

## Production Deployment
1. Build the application:
   ```bash
   npm run build
   ```

2. Start production server:
   ```bash
   npm start
   ```

3. Configure process manager (PM2 recommended):
   ```bash
   pm2 start npm --name "prepai" -- start
</file>

<file path="prisma/migrations/20250619140104_add_review_count_field/migration.sql">
-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Question" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "content" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "lastReviewed" TIMESTAMP(3),
    "reviewInterval" INTEGER NOT NULL DEFAULT 1,
    "reviewEase" DOUBLE PRECISION NOT NULL DEFAULT 2.5,
    "struggleCount" INTEGER NOT NULL DEFAULT 0,
    "lastStruggledAt" TIMESTAMP(3),
    "totalStruggleTime" INTEGER NOT NULL DEFAULT 0,
    "reviewCount" INTEGER NOT NULL DEFAULT 0,

    CONSTRAINT "Question_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Review" (
    "id" TEXT NOT NULL,
    "questionId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "remembered" BOOLEAN NOT NULL,
    "reviewedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Review_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ProgressMetrics" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "totalQuestions" INTEGER NOT NULL DEFAULT 0,
    "correctAnswers" INTEGER NOT NULL DEFAULT 0,
    "incorrectAnswers" INTEGER NOT NULL DEFAULT 0,
    "lastReviewedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "ProgressMetrics_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- AddForeignKey
ALTER TABLE "Question" ADD CONSTRAINT "Question_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Review" ADD CONSTRAINT "Review_questionId_fkey" FOREIGN KEY ("questionId") REFERENCES "Question"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Review" ADD CONSTRAINT "Review_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ProgressMetrics" ADD CONSTRAINT "ProgressMetrics_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="src/app/api/generate-question/route.d.ts">
import { NextRequest, NextResponse } from 'next/server';

declare module 'openai' {
  export default class OpenAI {
    constructor(options: { apiKey: string });

    completions: {
      create: (params: {
        model: string;
        prompt: string;
        max_tokens?: number;
        temperature?: number;
      }) => Promise<{
        choices: {
          text: string;
        }[];
      }>;
    };
  }
}

export function POST(req: NextRequest): Promise<NextResponse>;
</file>

<file path="src/app/generate/page.tsx">
'use client';

import React from 'react';
import QuestionGeneratorForm from '@/components/QuestionGeneratorForm';

const GeneratePage: React.FC = () => {
  return (
    <div className="min-h-screen bg-gray-50">
      <div className="container mx-auto py-12">
        <QuestionGeneratorForm />
      </div>
    </div>
  );
};

export default GeneratePage;
</file>

<file path="src/app/globals.css">
@import "tailwindcss/preflight";
@tailwind utilities;
</file>

<file path="src/app/layout.tsx">
import React from 'react';
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import Link from "next/link";
import { useAuth } from '@/lib/auth-context';

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "PrepAI - Interview Preparation",
  description: "AI-driven interview preparation platform",
};

import { Providers } from '@/providers';

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <Providers>
          <nav className="bg-gray-800 text-white p-4">
            <div className="container mx-auto flex justify-between items-center">
              <div className="text-lg font-bold">PrepAI</div>
              <div className="space-x-4">
                <Link href="/" className="hover:underline">Home</Link>
                <Link href="/questions" className="hover:underline">Questions</Link>
                <AuthLinks />
              </div>
            </div>
          </nav>
          {children}
        </Providers>
      </body>
    </html>
  );
}

function AuthLinks() {
  const { user } = useAuth();

  if (user) {
    return (
      <>
        <span>Welcome, {user.email}</span>
        <Link href="/api/auth/signout" className="hover:underline">Logout</Link>
      </>
    );
  }

  return (
    <>
      <Link href="/login" className="hover:underline">Login</Link>
      <Link href="/signup" className="hover:underline">Sign Up</Link>
    </>
  );
}
</file>

<file path="src/components/DeckManagement.tsx">
import React, { useState, useEffect } from 'react';
import { supabase } from '../lib/supabase';
import { useAuth } from '../lib/auth-context';

interface Flashcard {
  id: string;
  question: string;
  answer: string;
  deckId: string;
}

interface Deck {
  id: string;
  name: string;
  description: string;
  userId: string;
}

const DeckManagement: React.FC = () => {
  const { user } = useAuth();
  const [decks, setDecks] = useState<Deck[]>([]);
  const [flashcards, setFlashcards] = useState<Flashcard[]>([]);
  const [selectedDeck, setSelectedDeck] = useState<string | null>(null);
  const [newDeckName, setNewDeckName] = useState('');
  const [newDeckDescription, setNewDeckDescription] = useState('');
  const [newQuestion, setNewQuestion] = useState('');
  const [newAnswer, setNewAnswer] = useState('');
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    if (user) {
      fetchDecks(user.id);
    }
  }, [user]);

  const fetchDecks = async (userId: string) => {
    setIsLoading(true);
    try {
      const { data: decksData, error: decksError } = await supabase
        .from('decks')
        .select('*')
        .eq('userId', userId);

      if (decksError) {
        console.error('Error fetching decks:', decksError);
        return;
      }

      setDecks(decksData || []);

      if (decksData && decksData.length > 0) {
        setSelectedDeck(decksData[0].id);
        fetchFlashcards(decksData[0].id);
      }
    } catch (err) {
      console.error('Error fetching decks:', err);
    } finally {
      setIsLoading(false);
    }
  };

  const fetchFlashcards = async (deckId: string) => {
    if (!user) return;

    try {
      const { data, error } = await supabase
        .from('flashcards')
        .select('*')
        .eq('deckId', deckId)
        .eq('user_id', user.id);

      if (error) {
        console.error('Error fetching flashcards:', error);
        return;
      }

      setFlashcards(data || []);
    } catch (err) {
      console.error('Error fetching flashcards:', err);
    }
  };

  const createDeck = async () => {
    if (!user || !newDeckName) return;

    try {
      const { data, error } = await supabase
        .from('decks')
        .insert([{ name: newDeckName, description: newDeckDescription, userId: user.id }])
        .select();

      if (error) {
        console.error('Error creating deck:', error);
        return;
      }

      setDecks([...decks, data[0]]);
      setSelectedDeck(data[0].id);
      setNewDeckName('');
      setNewDeckDescription('');
    } catch (err) {
      console.error('Error creating deck:', err);
    }
  };

  const addFlashcard = async () => {
    if (!user || !selectedDeck || !newQuestion || !newAnswer) return;

    try {
      const { data, error } = await supabase
        .from('flashcards')
        .insert([{ question: newQuestion, answer: newAnswer, deckId: selectedDeck, user_id: user.id }])
        .select();

      if (error) {
        console.error('Error adding flashcard:', error);
        return;
      }

      setFlashcards([...flashcards, data[0]]);
      setNewQuestion('');
      setNewAnswer('');
    } catch (err) {
      console.error('Error adding flashcard:', err);
    }
  };

  const handleDeckChange = (deckId: string) => {
    setSelectedDeck(deckId);
    fetchFlashcards(deckId);
  };

  if (isLoading) {
    return <div>Loading decks...</div>;
  }

  return (
    <div className="p-4 border rounded shadow">
      <h2 className="text-xl font-bold mb-4">Deck Management</h2>

      <div className="mb-4">
        <h3 className="text-lg font-semibold mb-2">Create New Deck</h3>
        <input
          type="text"
          placeholder="Deck Name"
          value={newDeckName}
          onChange={(e) => setNewDeckName(e.target.value)}
          className="border rounded px-2 py-1 mb-2 w-full"
        />
        <input
          type="text"
          placeholder="Deck Description"
          value={newDeckDescription}
          onChange={(e) => setNewDeckDescription(e.target.value)}
          className="border rounded px-2 py-1 mb-2 w-full"
        />
        <button
          onClick={createDeck}
          className="bg-blue-500 text-white px-4 py-2 rounded"
        >
          Create Deck
        </button>
      </div>

      <div className="mb-4">
        <h3 className="text-lg font-semibold mb-2">Select Deck</h3>
        <select
          value={selectedDeck || ''}
          onChange={(e) => handleDeckChange(e.target.value)}
          className="border rounded px-2 py-1 w-full"
        >
          {decks.map((deck) => (
            <option key={deck.id} value={deck.id}>
              {deck.name}
            </option>
          ))}
        </select>
      </div>

      {selectedDeck && (
        <div>
          <h3 className="text-lg font-semibold mb-2">Add Flashcard</h3>
          <input
            type="text"
            placeholder="Question"
            value={newQuestion}
            onChange={(e) => setNewQuestion(e.target.value)}
            className="border rounded px-2 py-1 mb-2 w-full"
          />
          <input
            type="text"
            placeholder="Answer"
            value={newAnswer}
            onChange={(e) => setNewAnswer(e.target.value)}
            className="border rounded px-2 py-1 mb-2 w-full"
          />
          <button
            onClick={addFlashcard}
            className="bg-blue-500 text-white px-4 py-2 rounded"
          >
            Add Flashcard
          </button>

          <div className="mt-4">
            <h3 className="text-lg font-semibold mb-2">Flashcards</h3>
            {flashcards.length === 0 ? (
              <p>No flashcards in this deck.</p>
            ) : (
              <ul>
                {flashcards.map((flashcard) => (
                  <li key={flashcard.id} className="mb-2 p-2 border rounded">
                    <strong>Q:</strong> {flashcard.question} <br />
                    <strong>A:</strong> {flashcard.answer}
                  </li>
                ))}
              </ul>
            )}
          </div>
        </div>
      )}
    </div>
  );
};

export default DeckManagement;
</file>

<file path="src/components/DiscoverMode.tsx">
import React, { useState } from 'react';
import { supabase } from '@/lib/supabase';
import { Question } from '@/lib/srs';
import { useAuth } from '@/lib/auth-context';
import { KnowledgeGap } from '@/lib/assessment';

const DiscoverMode: React.FC = () => {
  const { user } = useAuth();
  const [questions, setQuestions] = useState<Question[]>([]);
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [analysisError, setAnalysisError] = useState('');
  const [filters, setFilters] = useState({
    topic: '',
    minSeverity: 0.5,
    showGapsOnly: false
  });
  const [filteredQuestions, setFilteredQuestions] = useState<Question[]>([]);
  const [isFiltering, setIsFiltering] = useState(false);


  const handleAnalyze = async () => {
    if (!user) return;
    
    setIsAnalyzing(true);
    setAnalysisError('');
    
    try {
      // Get complete knowledge gap analysis from assessment service
      const assessmentResponse = await fetch('/api/analyze-knowledge-gaps', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ userId: user.id }),
      });

      if (!assessmentResponse.ok) {
        throw new Error('Failed to analyze knowledge gaps');
      }

      const { gaps } = (await assessmentResponse.json()) as { gaps: KnowledgeGap[] };

      // Generate new questions for each gap and related topics
      const generationPromises = gaps.flatMap(gap => {
        const topics = [gap.topic, ...(gap.relatedTopics || [])];
        return fetch('/api/generate-question', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            prompt: `Generate interview questions about ${gap.topic}`,
            questionType: 'multiple_choice',
            topics,
            knowledgeGap: gap
          }),
        });
      });

      const generationResponses = await Promise.all(generationPromises);
      const newQuestions = await Promise.all(
        generationResponses.map(res => res.json())
      );

      // Save generated questions to database
      const { error } = await supabase
        .from('questions')
        .insert(newQuestions.map(q => ({
          ...q,
          user_id: user.id,
          isAIGenerated: true,
          topics: q.topics || []
        })));

      if (error) throw error;

      // Refresh questions list
      const { data } = await supabase
        .from('questions')
        .select('*')
        .eq('user_id', user.id);

      if (data) setQuestions(data);
    } catch (error) {
      console.error('Error analyzing knowledge gaps:', error);
      setAnalysisError('Failed to analyze knowledge gaps. Please try again.');
      // Reset state on error
    } finally {
      setIsAnalyzing(false);
    }
  };

  // Apply filters whenever they change
  React.useEffect(() => {
    const applyFilters = async () => {
      if (questions.length === 0) return;
      
      setIsFiltering(true);
      try {
        // Get current knowledge gaps
        const response = await fetch('/api/analyze-knowledge-gaps', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ userId: user?.id }),
        });
        
        if (!response.ok) throw new Error('Failed to get knowledge gaps');
        const { gaps } = await response.json() as { gaps: KnowledgeGap[] };

        const filtered = questions.filter(question => {
          // Topic filter
          if (filters.topic && !(question.topics || []).includes(filters.topic)) {
            return false;
          }
          
          // Gap severity filter
          if (filters.showGapsOnly) {
            const questionGaps = gaps.filter(gap =>
              gap.relatedQuestions.includes(question.id) ||
              (question.topics || []).includes(gap.topic)
            );
            
            if (questionGaps.length === 0) return false;
            if (!questionGaps.some(gap => gap.severity >= filters.minSeverity)) {
              return false;
            }
          }
          
          return true;
        });

        setFilteredQuestions(filtered);
      } catch (error) {
        console.error('Error applying filters:', error);
        setAnalysisError('Failed to apply filters');
      } finally {
        setIsFiltering(false);
      }
    };

    applyFilters();
  }, [filters, questions, user?.id]);

  return (
    <div className="p-4">
      <button 
        onClick={handleAnalyze}
        disabled={isAnalyzing}
        className="bg-blue-500 text-white px-4 py-2 rounded disabled:bg-gray-400"
      >
        {isAnalyzing ? 'Analyzing...' : 'Analyze Knowledge Gaps'}
      </button>
      
      {analysisError && (
        <div className="text-red-500 mt-2">{analysisError}</div>
      )}

      <div className="mt-4 space-y-4">
        <div className="flex gap-4 items-center">
          <select
            value={filters.topic}
            onChange={(e) => setFilters({...filters, topic: e.target.value})}
            className="p-2 border rounded"
          >
            <option value="">All Topics</option>
            {Array.from(new Set(questions.flatMap(q => q.topics || []))).map(topic => (
              <option key={topic} value={topic}>{topic}</option>
            ))}
          </select>

          <label className="flex items-center gap-2">
            <input
              type="range"
              min="0"
              max="1"
              step="0.1"
              value={filters.minSeverity}
              onChange={(e) => setFilters({...filters, minSeverity: parseFloat(e.target.value)})}
              className="w-32"
            />
            <span>Min Severity: {filters.minSeverity.toFixed(1)}</span>
          </label>

          <label className="flex items-center gap-2">
            <input
              type="checkbox"
              checked={filters.showGapsOnly}
              onChange={(e) => setFilters({...filters, showGapsOnly: e.target.checked})}
            />
            Show gap questions only
          </label>
        </div>

        <h2 className="text-xl font-semibold mb-2">Generated Questions</h2>
        {isFiltering ? (
          <p>Applying filters...</p>
        ) : filteredQuestions.length > 0 ? (
          <ul className="space-y-2">
            {filteredQuestions.map((question) => (
              <li
                key={question.id}
                className="p-2 bg-gray-50 rounded border border-gray-200"
              >
                <h3 className="font-medium">{question.question}</h3>
                {(question.topics || []).length > 0 && (
                  <div className="mt-1 text-sm text-gray-600">
                    Topics: {(question.topics || []).join(', ')}
                  </div>
                )}
              </li>
            ))}
          </ul>
        ) : (
          <p className="text-gray-500">
            {questions.length === 0
              ? "No questions generated yet"
              : "No questions match the current filters"}
          </p>
        )}
      </div>
    </div>
  );
};

export default DiscoverMode;
</file>

<file path="src/components/QuestionForm.tsx">
import React, { useState } from 'react';
import { useAuth } from '@/lib/auth-context';
import { useRouter } from 'next/navigation';

interface QuestionFormProps {
  onSubmit: (content: string, category: string, difficulty: string) => void;
}

const QuestionForm: React.FC<QuestionFormProps> = ({ onSubmit }) => {
  const { user } = useAuth();
  const router = useRouter();
  const [content, setContent] = useState('');
  const [category, setCategory] = useState('');
  const [difficulty, setDifficulty] = useState('');
  const [error, setError] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!content || !category || !difficulty) {
      setError('All fields are required');
      return;
    }
    onSubmit(content, category, difficulty);
    setContent('');
    setCategory('');
    setDifficulty('');
    setError('');
  };

  if (!user) {
    router.push('/login');
    return null;
  }

  return (
    <div className="max-w-md mx-auto p-8 bg-white rounded-lg shadow-lg">
      <h2 className="text-2xl font-bold mb-6 text-center">Add a New Question</h2>
      {error && <p className="text-red-500 text-sm mb-4">{error}</p>}
      <form onSubmit={handleSubmit}>
        <div className="mb-4">
          <label htmlFor="content" className="block text-sm font-medium text-gray-700">
            Question Content
          </label>
          <textarea
            id="content"
            className="mt-1 block w-full h-32 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
            value={content}
            onChange={(e) => setContent(e.target.value)}
            required
          />
        </div>
        <div className="mb-4">
          <label htmlFor="category" className="block text-sm font-medium text-gray-700">
            Category
          </label>
          <input
            id="category"
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
            value={category}
            onChange={(e) => setCategory(e.target.value)}
            required
          />
        </div>
        <div className="mb-4">
          <label htmlFor="difficulty" className="block text-sm font-medium text-gray-700">
            Difficulty
          </label>
          <select
            id="difficulty"
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
            value={difficulty}
            onChange={(e) => setDifficulty(e.target.value)}
            required
          >
            <option value="">Select difficulty</option>
            <option value="easy">Easy</option>
            <option value="medium">Medium</option>
            <option value="hard">Hard</option>
          </select>
        </div>
        <button
          type="submit"
          className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
        >
          Add Question
        </button>
      </form>
    </div>
  );
};

export default QuestionForm;
</file>

<file path="src/lib/__tests__/config.test.ts">
import { supabase } from '../supabase';

describe('Environment Configuration', () => {
  const OLD_ENV = process.env;

  beforeEach(() => {
    jest.resetModules();
    process.env = { ...OLD_ENV };
  });

  afterAll(() => {
    process.env = OLD_ENV;
  });

  it('should throw error when Supabase URL is missing', () => {
    delete process.env.NEXT_PUBLIC_SUPABASE_URL;
    expect(() => supabase).toThrow('Supabase URL and Anon Key must be defined in environment variables');
  });

  it('should throw error when Supabase Anon Key is missing', () => {
    delete process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
    expect(() => supabase).toThrow('Supabase URL and Anon Key must be defined in environment variables');
  });

  it('should initialize Supabase client when all variables are present', () => {
    process.env.NEXT_PUBLIC_SUPABASE_URL = 'https://test.supabase.co';
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY = 'test-anon-key';
    expect(() => supabase).not.toThrow();
    expect(supabase).toBeDefined();
  });
});
</file>

<file path="src/lib/auth-context.ts">
'use client';

import { createContext, useContext, useEffect, useState } from 'react';
import { createClient, Session, User } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
export const supabase = createClient(supabaseUrl, supabaseAnonKey);

interface AuthContextType {
  user: User | null;
  signIn: (email: string, password: string) => Promise<void>;
  signUp: (email: string, password: string) => Promise<void>;
  signOut: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    const getSession = async () => {
      const { data, error } = await supabase.auth.getSession();
      if (data?.session) {
        setUser(data.session.user);
      }
    };
    getSession();

    const { data: listener } = supabase.auth.onAuthStateChange((event, session) => {
      setUser(session?.user ?? null);
    });

    return () => {
      listener.subscription.unsubscribe();
    };
  }, []);

  const signIn = async (email: string, password: string) => {
    const { data, error } = await supabase.auth.signInWithPassword({ email, password });
    if (error) throw error;
    setUser(data.user);
  };

  const signUp = async (email: string, password: string) => {
    const { data, error } = await supabase.auth.signUp({ email, password });
    if (error) throw error;
    setUser(data.user);
  };

  const signOut = async () => {
    const { error } = await supabase.auth.signOut();
    if (error) throw error;
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{ user, signIn, signUp, signOut }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
</file>

<file path="src/lib/transcription.ts">
import { supabase } from './supabase';

export interface TranscriptionService {
  processTranscription: (filePath: string) => Promise<string>;
}

export const createTranscriptionService = (): TranscriptionService => {
  const processTranscription = async (filePath: string): Promise<string> => {
    try {
      // Simulate API call to Google Cloud Speech-to-Text
      // In a real implementation, you would send the audio file to the API
      // and get the transcription text in response

      // For demonstration, we'll use a placeholder transcription
      const simulatedTranscription = `This is a simulated transcription of the audio recording at ${filePath}. The actual implementation would use a speech-to-text API like Google Cloud Speech-to-Text.`;

      return simulatedTranscription;
    } catch (error) {
      console.error('Error processing transcription:', error);
      throw new Error('Failed to process transcription');
    }
  };

  return {
    processTranscription,
  };
};

export const transcriptionService = createTranscriptionService();
</file>

<file path="src/providers.tsx">
'use client';

import React from 'react';
import { AuthProvider } from './lib/auth-context';

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <AuthProvider>
      {children}
    </AuthProvider>
  );
}
</file>

<file path="tests/e2e/srsWorkflow.test.ts">
import { getQuestionsByMode, calculateNextReview, Question } from '../../src/lib/srs';

describe('SRS Workflow End-to-End Tests', () => {
  const now = new Date();
  interface ExtendedQuestion extends Question {
    topics?: string[];
    struggleTopics?: string[];
  }

  const testQuestions: ExtendedQuestion[] = [
    // New question (never reviewed)
    {
      id: '1',
      question: 'New question',
      answer: 'Answer',
      rating: 'normal',
      user_id: 'test-user',
      createdAt: new Date(),
      lastReviewed: null,
      reviewInterval: 1,
      reviewEase: 2.5,
      struggleCount: 0,
      lastStruggledAt: null,
      totalStruggleTime: 0,
      reviewCount: 0
    },
    // Recently reviewed question
    {
      id: '2',
      question: 'Recent question',
      answer: 'Answer',
      rating: 'normal',
      user_id: 'test-user',
      createdAt: new Date(now.getTime() - 86400000 * 2),
      lastReviewed: new Date(now.getTime() - 86400000 * 1),
      reviewInterval: 3,
      reviewEase: 2.5,
      struggleCount: 0,
      lastStruggledAt: null,
      totalStruggleTime: 0,
      reviewCount: 1
    },
    // Struggled question
    {
      id: '3',
      question: 'Struggled question',
      answer: 'Answer',
      rating: 'hard',
      user_id: 'test-user',
      createdAt: new Date(now.getTime() - 86400000 * 5),
      lastReviewed: new Date(now.getTime() - 86400000 * 4),
      reviewInterval: 1,
      reviewEase: 1.5,
      struggleCount: 3,
      lastStruggledAt: new Date(now.getTime() - 86400000 * 1),
      totalStruggleTime: 300,
      reviewCount: 4
    },
    // Overdue question
    {
      id: '4',
      question: 'Overdue question',
      answer: 'Answer',
      rating: 'normal',
      user_id: 'test-user',
      createdAt: new Date(now.getTime() - 86400000 * 10),
      lastReviewed: new Date(now.getTime() - 86400000 * 5),
      reviewInterval: 3,
      reviewEase: 2.5,
      struggleCount: 1,
      lastStruggledAt: new Date(now.getTime() - 86400000 * 5),
      totalStruggleTime: 120,
      reviewCount: 2
    }
  ];

  beforeEach(() => {
    // Reset any mocks or test data
  });

  test('Repeat mode selects struggled and overdue questions', async () => {
    const questions = await getQuestionsByMode('repeat', testQuestions);
    const questionIds = questions.map(q => q.id);
    expect(questionIds).toContain('3'); // Struggled question
    expect(questionIds).toContain('4'); // Overdue question
    expect(questionIds).not.toContain('1'); // New question
    expect(questionIds).not.toContain('2'); // Recent question
  });

  test('Study mode focuses on new and recent questions', async () => {
    const questions = await getQuestionsByMode('study', testQuestions);
    const questionIds = questions.map(q => q.id);
    expect(questionIds).toContain('1'); // New question
    expect(questionIds).toContain('2'); // Recent question
    expect(questionIds).not.toContain('3'); // Struggled question
    expect(questionIds).not.toContain('4'); // Overdue question
  });

  test('Discover mode introduces new related questions', async () => {
    const questions = await getQuestionsByMode('discover',
      testQuestions.map(q => ({...q, topics: ['related-topic']})),
      ['2', '3', '4'], // Already in user's queue
      ['related-topic']
    );
    const questionIds = questions.map(q => q.id);
    expect(questionIds).toContain('1'); // Only new question not in queue
    expect(questionIds).not.toContain('2');
    expect(questionIds).not.toContain('3');
    expect(questionIds).not.toContain('4');
  });

  test('Struggle tracking and visualization', async () => {
    // Start with a new question
    const newQuestion = testQuestions[0];
    
    // Mark as hard (struggled)
    const struggledQuestion: Question = {
      ...newQuestion,
      lastReviewed: new Date(),
      rating: 'hard', // Explicitly set as 'hard' to match the Question type
      struggleCount: 1,
      lastStruggledAt: new Date(),
      totalStruggleTime: 60,
      reviewCount: 1
    };

    // Verify it appears in Repeat mode
    const repeatQuestions = await getQuestionsByMode('repeat', [struggledQuestion, ...testQuestions.slice(1)]);
    expect(repeatQuestions.map(q => q.id)).toContain(struggledQuestion.id);

    // Verify next review interval is shorter
    const nextReview = calculateNextReview(struggledQuestion);
    expect(nextReview.newInterval).toBeLessThan(struggledQuestion.reviewInterval);

    // Verify visualization would show struggle
    expect(struggledQuestion.struggleCount).toBeGreaterThan(0);
    expect(struggledQuestion.lastStruggledAt).toBeInstanceOf(Date);
  });

  test('Knowledge gap analysis integration', async () => {
    // Create questions with topic relationships
    const questionsWithTopics = testQuestions.map(q => ({
      ...q,
      topics: ['topic1', 'topic2'] as string[],
      struggleTopics: (q.rating === 'hard' ? ['topic1'] : []) as string[]
    }));

    // Get discover mode questions with knowledge gap in topic1
    const discoveredQuestions = await getQuestionsByMode('discover',
      questionsWithTopics,
      ['2', '3', '4'], // Already in queue
      ['topic1'] // Gap in topic1
    );

    // Should prioritize questions related to topic1
    expect(discoveredQuestions.some(q => q.topics?.includes('topic1'))).toBeTruthy();
  });

  test('Full workflow from discovery to mastery', async () => {
    // Start with discover mode
    let questions = await getQuestionsByMode('discover',
      testQuestions.map(q => ({...q, topics: ['related-topic']})),
      ['2', '3', '4'],
      ['related-topic']
    );
    expect(questions.map(q => q.id)).toEqual(['1']);

    // Study the new question
    const nextReview = calculateNextReview(questions[0]);
    expect(nextReview.daysUntilReview).toBe(1);

    // Mark as remembered
    const rememberedQuestion = {
      ...questions[0],
      lastReviewed: new Date(),
      reviewCount: 1,
      reviewInterval: nextReview.newInterval,
      reviewEase: nextReview.newEase
    };

    // Now check study mode should include it as recent
    questions = await getQuestionsByMode('study', [rememberedQuestion, ...testQuestions.slice(1)]);
    expect(questions.map(q => q.id)).toContain('1');

    // After several reviews, check repeat mode
    const struggledQuestion = {
      ...rememberedQuestion,
      reviewCount: 5,
      struggleCount: 3,
      lastStruggledAt: new Date(),
      reviewEase: 1.5
    };
    questions = await getQuestionsByMode('repeat', [struggledQuestion, ...testQuestions.slice(1)]);
    expect(questions.map(q => q.id)).toContain('1');
  });
});
</file>

<file path=".env.example">
# Database configuration (PostgreSQL via Supabase)
DATABASE_URL="postgresql://user:password@localhost:5432/dbname"

# NextAuth configuration
NEXTAUTH_SECRET="your-secret-key-here"
NEXTAUTH_URL="http://localhost:3000"

# Supabase configuration (REQUIRED)
NEXT_PUBLIC_SUPABASE_URL="https://your-project.supabase.co"
NEXT_PUBLIC_SUPABASE_ANON_KEY="your-anon-key-here"

# Application configuration
NODE_ENV="development"
PORT=3000

# Optional features
ENABLE_ANALYTICS="false"
</file>

<file path=".env.local">
NEXT_PUBLIC_SUPABASE_URL=your-supabase-url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-supabase-anon-key
DATABASE_URL="postgres://postgres:postgres@db:5432/prepai"
</file>

<file path=".prettierrc">
{
  "singleQuote": true
}
</file>

<file path="delete_assistance.sh">
#!/bin/bash
rm -f NEEDS_ASSISTANCE.md
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  db:
    image: postgres:15
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: prepai
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5433:5432"
    networks:
      - prepai-network

  app:
    build: ./prepai
    environment:
      DATABASE_URL: postgres://postgres:postgres@db:5432/prepai
      NEXT_PUBLIC_SUPABASE_URL: ${NEXT_PUBLIC_SUPABASE_URL}
      NEXT_PUBLIC_SUPABASE_ANON_KEY: ${NEXT_PUBLIC_SUPABASE_ANON_KEY}
    ports:
      - "3001:3000"
    depends_on:
      - db
    networks:
      - prepai-network

volumes:
  postgres_data:

networks:
  prepai-network:
    driver: bridge
</file>

<file path="eslint.config.mjs">
import js from "@eslint/js";
import globals from "globals";
import tseslint from "typescript-eslint";
import pluginReact from "eslint-plugin-react";
import { defineConfig } from "eslint/config";


export default defineConfig([
  { files: ["**/*.{js,mjs,cjs,ts,mts,cts,jsx,tsx}"], plugins: { js }, extends: ["js/recommended"] },
  { files: ["**/*.{js,mjs,cjs,ts,mts,cts,jsx,tsx}"], languageOptions: { globals: globals.browser } },
  tseslint.configs.recommended,
  pluginReact.configs.flat.recommended,
]);
</file>

<file path="tailwind.config.js">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="src/app/api/generate-report/route.ts">
import { NextResponse } from 'next/server';
import { generateUserReport } from '../../../lib/pdf';
import { supabase } from '../../../lib/supabase';

export async function GET(request: Request) {
  const { data } = await supabase.auth.getSession();

  if (!data?.session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const pdfBuffer = await generateUserReport(data.session.user.id, 'standard');
    return new NextResponse(pdfBuffer, {
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="progress-report-${data.session.user.id}.pdf"`,
      },
    });
  } catch (error) {
    console.error('Error generating report:', error);
    return NextResponse.json({ error: 'Failed to generate report' }, { status: 500 });
  }
}

export async function POST(request: Request) {
  const { data } = await supabase.auth.getSession();
  const { template } = await request.json();

  if (!data?.session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const pdfBuffer = await generateUserReport(data.session.user.id, template);
    return new NextResponse(pdfBuffer, {
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="progress-report-${data.session.user.id}.pdf"`,
      },
    });
  } catch (error) {
    console.error('Error generating report:', error);
    return NextResponse.json({ error: 'Failed to generate report' }, { status: 500 });
  }
}
</file>

<file path="src/app/dashboard/page.tsx">
'use client';

import React from 'react';
import ProgressDashboard from '@/components/ProgressDashboard';
import AnalyticsCharts from '@/components/AnalyticsCharts';
import ReportGenerator from '@/components/ReportGenerator';

const DashboardPage: React.FC = () => {
  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-6">Dashboard</h1>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <div className="col-span-1 md:col-span-2 lg:col-span-3">
          <ProgressDashboard />
        </div>
        <div className="col-span-1 md:col-span-2 lg:col-span-3">
          <AnalyticsCharts />
        </div>
        <div className="col-span-1 md:col-span-2 lg:col-span-3 mt-6">
          <ReportGenerator />
        </div>
      </div>
    </div>
  );
};

export default DashboardPage;
</file>

<file path="src/app/questions/page.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { useAuth } from '@/lib/auth-context';
import { useRouter } from 'next/navigation';
import QuestionForm from '@/components/QuestionForm';
import VoiceRecorder from '@/components/VoiceRecorder';
import SRSControls from '@/components/SRSControls';

interface Question {
  id: string;
  content: string;
  category: string;
  difficulty: string;
  createdAt: string;
}

const QuestionsPage: React.FC = () => {
  const { user } = useAuth();
  const router = useRouter();
  const [questions, setQuestions] = useState<Question[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  useEffect(() => {
    if (!user) {
      router.push('/login');
      return;
    }

    const fetchQuestions = async () => {
      try {
        const response = await fetch('/api/questions');
        if (!response.ok) {
          throw new Error('Failed to fetch questions');
        }
        const data = await response.json();
        setQuestions(data);
        setLoading(false);
      } catch (err) {
        setError('Failed to load questions');
        console.error('Fetch error:', err);
        setLoading(false);
      }
    };

    fetchQuestions();
  }, [user, router]);

  const handleAddQuestion = async (content: string, category: string, difficulty: string) => {
    try {
      const response = await fetch('/api/questions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ content, category, difficulty }),
      });

      if (!response.ok) {
        throw new Error('Failed to add question');
      }

      const newQuestion = await response.json();
      setQuestions((prev) => [newQuestion, ...prev]);
    } catch (err) {
      setError('Failed to add question');
      console.error('Add question error:', err);
    }
  };

  const handleRecordingComplete = async (filePath: string) => {
    // Here we would associate the recording with a question
    // For now, just log it
    console.log('Recording saved at:', filePath);
  };

  const handleReviewComplete = (questionId: string, remembered: boolean) => {
    // Update the question in the state to reflect the review status
    setQuestions(prevQuestions =>
      prevQuestions.map(question =>
        question.id === questionId
          ? { ...question, lastReviewed: new Date(), reviewStatus: remembered ? 'remembered' : 'forgotten' }
          : question
      )
    );
  };

  if (loading) return <div>Loading questions...</div>;
  if (error) return <div className="text-red-500">{error}</div>;

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-6 text-center">Manage Your Questions</h1>

      <QuestionForm onSubmit={handleAddQuestion} />

      <div className="mt-8">
        <h2 className="text-2xl font-bold mb-4">Your Questions</h2>
        {questions.length === 0 ? (
          <p>No questions found. Add a new question above.</p>
        ) : (
          <ul className="divide-y divide-gray-200">
            {questions.map((question) => (
              <li key={question.id} className="py-4">
                <h3 className="font-semibold">{question.content}</h3>
                <p className="text-gray-600">
                  <span className="font-medium">Category:</span> {question.category} |
                  <span className="font-medium">Difficulty:</span> {question.difficulty} |
                  <span className="font-medium">Added:</span> {new Date(question.createdAt).toLocaleDateString()}
                </p>
                <SRSControls
                  questionId={question.id}
                  onReviewComplete={(remembered) => handleReviewComplete(question.id, remembered)}
                />
              </li>
            ))}
          </ul>
        )}
      </div>

      <div className="mt-8">
        <h2 className="text-2xl font-bold mb-4">Record Your Answer</h2>
        <VoiceRecorder onRecordingComplete={handleRecordingComplete} />
      </div>
    </div>
  );
};

export default QuestionsPage;
</file>

<file path="src/components/AnalyticsCharts.tsx">
'use client';

import React, { useEffect, useState } from 'react';
import { useAuth } from '@/lib/auth-context';
import { progressService } from '@/lib/progress';
import { Line } from 'react-chartjs-2';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
} from 'chart.js';

ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
);

interface ChartData {
  labels: string[];
  datasets: {
    label: string;
    data: number[];
    backgroundColor?: string;
    borderColor?: string;
    fill?: boolean;
  }[];
}

const AnalyticsCharts: React.FC = () => {
  const { user } = useAuth();
  const [chartData, setChartData] = useState<ChartData | null>(null);
  const [selectedDateRange, setSelectedDateRange] = useState('30_days');
  const [selectedQuestionType, setSelectedQuestionType] = useState('all');
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  useEffect(() => {
    if (!user) return;

    const fetchData = async () => {
      try {
        const metrics = await progressService.getUserMetrics(user.id);

        // Generate sample data for demonstration based on selected filters
        let days: number;
        switch (selectedDateRange) {
          case '7_days':
            days = 7;
            break;
          case '14_days':
            days = 14;
            break;
          case '30_days':
            days = 30;
            break;
          default:
            days = 30;
        }

        const accuracyData = Array.from({ length: days }, (_, i) => {
          const date = new Date();
          date.setDate(date.getDate() - i);
          return {
            date: date.toLocaleDateString(),
            accuracy: Math.random() * (metrics.masteryScore / 100),
          };
        });

        setChartData({
          labels: accuracyData.map(d => d.date),
          datasets: [
            {
              label: `Accuracy Over Time (${selectedQuestionType === 'all' ? 'All Types' : selectedQuestionType})`,
              data: accuracyData.map(d => d.accuracy * 100),
              borderColor: 'rgba(75, 192, 192, 1)',
              fill: false,
            },
          ],
        });
      } catch (err) {
        setError('Failed to load analytics data');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [user, selectedDateRange, selectedQuestionType]);

  if (!user) {
    return <div>Please log in to view analytics.</div>;
  }

  if (loading) {
    return <div>Loading analytics data...</div>;
  }

  if (error) {
    return <div className="text-red-500">{error}</div>;
  }

  if (!chartData) {
    return <div>No analytics data available.</div>;
  }

  return (
    <div className="p-6 bg-white rounded-lg shadow-md">
      <h2 className="text-2xl font-bold mb-4">Analytics</h2>
      <div className="mb-6">
        <h3 className="font-semibold mb-2">Filters</h3>
        <div className="flex space-x-4">
          <div>
            <label className="block mb-1">Date Range:</label>
            <select
              value={selectedDateRange}
              onChange={(e) => setSelectedDateRange(e.target.value)}
              className="border rounded p-2"
            >
              <option value="7_days">Last 7 Days</option>
              <option value="14_days">Last 14 Days</option>
              <option value="30_days">Last 30 Days</option>
            </select>
          </div>
          <div>
            <label className="block mb-1">Question Type:</label>
            <select
              value={selectedQuestionType}
              onChange={(e) => setSelectedQuestionType(e.target.value)}
              className="border rounded p-2"
            >
              <option value="all">All Types</option>
              <option value="easy">Easy</option>
              <option value="medium">Medium</option>
              <option value="hard">Hard</option>
            </select>
          </div>
        </div>
      </div>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div className="p-4 bg-gray-100 rounded-md">
          <h3 className="font-semibold mb-2">Accuracy Over Time</h3>
          <Line data={chartData} />
        </div>
        {/* Add more charts here */}
      </div>
    </div>
  );
};

export default AnalyticsCharts;
</file>

<file path="src/components/AssessmentInterface.tsx">
import React, { useState } from 'react';
import { useAuth } from '@/lib/auth-context';
import { assessmentService } from '@/lib/assessment';

const AssessmentInterface: React.FC = () => {
  const { user } = useAuth();
  const [answers, setAnswers] = useState<Record<string, string>>({});
  const [score, setScore] = useState<number | null>(null);
  const [recommendations, setRecommendations] = useState<string[]>([]);
  const [actionPlan, setActionPlan] = useState<string[]>([]);

  const handleAnswerChange = (questionId: string, answer: string) => {
    setAnswers(prev => ({ ...prev, [questionId]: answer }));
  };

  const calculateScore = () => {
    if (Object.keys(answers).length === 0) return;

    const score = assessmentService.calculateScore(answers);
    setScore(score);

    // Get recommendations and action plan
    const recs = assessmentService.getRecommendations(score);
    const actions = assessmentService.generateRecommendationEngine(score);

    setRecommendations(recs);
    setActionPlan(actions);
  };

  return (
    <div className="p-4 border rounded shadow">
      <h2 className="text-xl font-bold mb-4">Readiness Assessment</h2>
      <p className="mb-4">Answer the following questions to assess your readiness:</p>

      {user && (
        <>
          <div className="mb-4">
            <label className="block font-bold mb-2">Question 1:</label>
            <select
              value={answers['q1'] || ''}
              onChange={(e) => handleAnswerChange('q1', e.target.value)}
              className="border rounded px-2 py-1 w-full"
            >
              <option value="">Select answer</option>
              <option value="correct">Correct</option>
              <option value="incorrect">Incorrect</option>
            </select>
          </div>

          <div className="mb-4">
            <label className="block font-bold mb-2">Question 2:</label>
            <select
              value={answers['q2'] || ''}
              onChange={(e) => handleAnswerChange('q2', e.target.value)}
              className="border rounded px-2 py-1 w-full"
            >
              <option value="">Select answer</option>
              <option value="correct">Correct</option>
              <option value="incorrect">Incorrect</option>
            </select>
          </div>

          <button
            onClick={calculateScore}
            className="bg-blue-500 text-white px-4 py-2 rounded"
          >
            Calculate Score
          </button>

          {score !== null && (
            <div className="mt-4">
              <h3 className="font-bold mb-2">Your Score: {score.toFixed(2)}%</h3>
              <h4 className="font-bold mb-2">Recommendations:</h4>
              <ul className="list-disc list-inside">
                {recommendations.map((rec, index) => (
                  <li key={index}>{rec}</li>
                ))}
              </ul>

              <h4 className="font-bold mb-2 mt-4">Action Plan:</h4>
              <ul className="list-disc list-inside">
                {actionPlan.map((action, index) => (
                  <li key={index}>{action}</li>
                ))}
              </ul>
            </div>
          )}
        </>
      )}
    </div>
  );
};

export default AssessmentInterface;
</file>

<file path="src/components/QuestionGeneratorForm.tsx">
import React, { useState } from 'react';
import { useAuth } from '@/lib/auth-context';
import { useRouter } from 'next/navigation';

const QuestionGeneratorForm: React.FC = () => {
  const { user } = useAuth();
  const router = useRouter();
  const [prompt, setPrompt] = useState('');
  const [maxTokens, setMaxTokens] = useState(150);
  const [temperature, setTemperature] = useState(0.7);
  const [questionType, setQuestionType] = useState('general');
  const [generatedQuestion, setGeneratedQuestion] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleGenerate = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!prompt) {
      setError('Prompt is required');
      return;
    }

    setLoading(true);
    setError('');
    setGeneratedQuestion('');

    try {
      const res = await fetch('/api/generate-question', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ prompt, maxTokens, temperature, questionType }),
      });

      if (!res.ok) {
        const result = await res.json();
        throw new Error(result.error || 'Failed to generate question');
      }

      const data = await res.json();
      setGeneratedQuestion(data.question);
    } catch (err) {
      if (err instanceof Error) {
        setError(err.message);
      } else {
        setError('An unknown error occurred');
      }
    } finally {
      setLoading(false);
    }
  };

  if (!user) {
    router.push('/login');
    return null;
  }

  return (
    <div className="max-w-md mx-auto p-8 bg-white rounded-lg shadow-lg">
      <h2 className="text-2xl font-bold mb-6 text-center">Generate Question</h2>
      {error && <p className="text-red-500 text-sm mb-4">{error}</p>}
      <form onSubmit={handleGenerate}>
        <div className="mb-4">
          <label htmlFor="prompt" className="block text-sm font-medium text-gray-700">
            Prompt
          </label>
          <textarea
            id="prompt"
            className="mt-1 block w-full h-32 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
            value={prompt}
            onChange={(e) => setPrompt(e.target.value)}
            required
          />
        </div>
        <div className="mb-4">
          <label htmlFor="questionType" className="block text-sm font-medium text-gray-700">
            Question Type
          </label>
          <select
            id="questionType"
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
            value={questionType}
            onChange={(e) => setQuestionType(e.target.value)}
          >
            <option value="general">General Question</option>
            <option value="multiple_choice">Multiple Choice</option>
            <option value="true_false">True/False</option>
            <option value="short_answer">Short Answer</option>
          </select>
        </div>
        <div className="mb-4">
          <label htmlFor="maxTokens" className="block text-sm font-medium text-gray-700">
            Max Tokens
          </label>
          <input
            id="maxTokens"
            type="number"
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
            value={maxTokens}
            onChange={(e) => setMaxTokens(Number(e.target.value))}
            min="1"
            max="2000"
          />
        </div>
        <div className="mb-4">
          <label htmlFor="temperature" className="block text-sm font-medium text-gray-700">
            Temperature
          </label>
          <input
            id="temperature"
            type="number"
            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
            value={temperature}
            onChange={(e) => setTemperature(Number(e.target.value))}
            step="0.1"
            min="0"
            max="2"
          />
        </div>
        <button
          type="submit"
          className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          disabled={loading}
        >
          {loading ? 'Generating...' : 'Generate Question'}
        </button>
      </form>
      {generatedQuestion && (
        <div className="mt-6 p-4 bg-gray-100 border border-gray-200 rounded-md">
          <h3 className="font-semibold mb-2">Generated Question:</h3>
          <p>{generatedQuestion}</p>
        </div>
      )}
    </div>
  );
};

export default QuestionGeneratorForm;
</file>

<file path="src/components/ReportGenerator.tsx">
import React from 'react';
import { useAuth } from '../lib/auth-context';

type TemplateType = 'standard' | 'detailed' | 'compact';

const ReportGenerator: React.FC = () => {
  const { user } = useAuth();
  const [isLoading, setIsLoading] = React.useState(false);
  const [template, setTemplate] = React.useState<TemplateType>('standard');

  const generateReport = async () => {
    if (!user) return;

    setIsLoading(true);
    try {
      const response = await fetch('/api/generate-report', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ template }),
      });
      if (!response.ok) {
        throw new Error('Failed to generate report');
      }

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `progress-report-${user.id}.pdf`;
      document.body.appendChild(a);
      a.click();
      a.remove();
    } catch (error) {
      console.error('Error generating report:', error);
      alert('Failed to generate report. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="p-4 border rounded shadow">
      <h2 className="text-xl font-bold mb-4">Generate Progress Report</h2>
      <p className="mb-4">Export your interview preparation progress to a PDF report.</p>

      <div className="mb-4">
        <label className="block font-bold mb-2">Select Report Template:</label>
        <select
          value={template}
          onChange={(e) => setTemplate(e.target.value as TemplateType)}
          className="border rounded px-2 py-1 w-full"
        >
          <option value="standard">Standard</option>
          <option value="detailed">Detailed</option>
          <option value="compact">Compact</option>
        </select>
      </div>

      <button
        onClick={generateReport}
        disabled={isLoading || !user}
        className="bg-blue-500 text-white px-4 py-2 rounded disabled:opacity-50"
      >
        {isLoading ? 'Generating...' : 'Generate Report'}
      </button>
    </div>
  );
};

export default ReportGenerator;
</file>

<file path="src/lib/auth-context.tsx">
'use client';

import React from 'react';
import { createContext, useContext, useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { supabase } from './supabase';
import { User } from '@supabase/supabase-js';

interface AuthContextType {
  user: User | null;
  loading: boolean;
  error: string | null;
  signIn: (email: string, password: string) => Promise<{ error: string | null }>;
  signUp: (email: string, password: string) => Promise<{ error: string | null }>;
  signOut: () => Promise<void>;
  clearError: () => void;
}

const AuthContext = createContext<AuthContextType>({
  user: null,
  loading: true,
  error: null,
  signIn: async () => ({ error: null }),
  signUp: async () => ({ error: null }),
  signOut: async () => {},
  clearError: () => {},
});

export const AuthProvider = ({ children }: { children: React.ReactNode }): React.JSX.Element => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  useEffect(() => {
    const { data: authListener } = supabase.auth.onAuthStateChange(
      async (event, session) => {
        setUser(session?.user ?? null);
        setLoading(false);
      }
    );

    return () => {
      authListener?.subscription.unsubscribe();
    };
  }, []);

  const handleAuthOperation = async (
    operation: () => Promise<{ error: { message: string } | null }>
  ): Promise<{ error: string | null }> => {
    setLoading(true);
    setError(null);
    try {
      const { error } = await operation();
      if (error) {
        setError(error.message);
        return { error: error.message };
      }
      return { error: null };
    } catch (err: unknown) {
      const error = err as Error;
      setError(error.message);
      return { error: error.message };
    } finally {
      setLoading(false);
    }
  };

  const value: AuthContextType = {
    user,
    loading,
    error,
    signIn: (email, password) =>
      handleAuthOperation(() =>
        supabase.auth.signInWithPassword({ email, password })
      ),
    signUp: (email, password) =>
      handleAuthOperation(() =>
        supabase.auth.signUp({ email, password })
      ),
    signOut: async () => {
      setLoading(true);
      try {
        await supabase.auth.signOut();
        router.push('/login');
      } catch (err: unknown) {
        const error = err as Error;
        setError(error.message);
      } finally {
        setLoading(false);
      }
    },
    clearError: () => setError(null),
  };

  return (
    <AuthContext.Provider value={value}>
      {!loading && children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
</file>

<file path="src/lib/pdf.ts">
import { jsPDF } from 'jspdf';
import autoTable from 'jspdf-autotable';
import { supabase } from './supabase';
import { progressService } from './progress';
import { formatDistanceToNow } from 'date-fns';

// Function to generate a PDF report for a user's progress
export async function generateUserReport(userId: string, template: 'standard' | 'detailed' | 'compact' = 'standard') {
  // Verify user is authenticated
  const { data } = await supabase.auth.getSession();
  if (!data?.session || data.session.user.id !== userId) {
    throw new Error('Unauthorized');
  }

  // Fetch user data and progress
  const { data: userData, error: userError } = await supabase
    .from('users')
    .select('id, email, name, created_at')
    .eq('id', userId)
    .single();

  if (userError || !userData) {
    throw new Error('User not found');
  }

  // Get progress metrics
  const progress = await progressService.getUserMetrics(userId);

  // Get all questions and their review status
  const { data: questionsData, error: questionsError } = await supabase
    .from('questions')
    .select('id, content, last_reviewed, review_interval, review_ease')
    .eq('user_id', userId);

  if (questionsError) {
    throw new Error('Error fetching questions');
  }

  // Create a new PDF document
  const doc = new jsPDF();

  // Apply template-specific styling
  if (template === 'detailed') {
    doc.setFillColor(240, 240, 240);
    doc.rect(0, 0, 210, 297, 'F');
  } else if (template === 'compact') {
    doc.setFontSize(10);
  }

  // Add title
  doc.setFontSize(template === 'compact' ? 16 : 20);
  doc.text('Interview Prep Progress Report', 14, template === 'compact' ? 16 : 22);

  // Add user information
  doc.setFontSize(template === 'compact' ? 12 : 14);
  doc.text(`Name: ${userData.name || 'N/A'}`, 14, template === 'compact' ? 24 : 30);
  doc.text(`Email: ${userData.email}`, 14, template === 'compact' ? 30 : 36);
  doc.text(`Account Created: ${formatDistanceToNow(new Date(userData.created_at), { addSuffix: true })}`, 14, template === 'compact' ? 36 : 42);

  // Add progress summary
  doc.setFontSize(template === 'compact' ? 14 : 16);
  doc.text('Progress Summary', 14, template === 'compact' ? 44 : 50);

  // Add progress data as a table
  const progressData = [
    ['Metric', 'Value'],
    ['Total Questions', progress.totalQuestions],
    ['Correct Answers', progress.correctAnswers],
    ['Incorrect Answers', progress.incorrectAnswers],
    ['Mastery Score', `${progress.masteryScore.toFixed(2)}%`],
  ];

  autoTable(doc, {
    startY: template === 'compact' ? 52 : 58,
    head: [['Metric', 'Value']],
    body: progressData,
    theme: template === 'detailed' ? 'grid' : 'plain',
  });

  // Add detailed question performance
  doc.addPage();
  doc.setFontSize(template === 'compact' ? 14 : 16);
  doc.text('Question Performance', 14, template === 'compact' ? 16 : 22);

  const questionData = questionsData.map(q => [
    q.content,
    q.last_reviewed ? 'Answered' : 'Pending',
    q.review_ease >= 2.5 ? '✓' : '✗',
  ]);

  autoTable(doc, {
    startY: template === 'compact' ? 24 : 30,
    head: [['Question', 'Status', 'Correct']],
    body: questionData,
    theme: template === 'detailed' ? 'grid' : 'plain',
  });

  // Return the PDF as a buffer
  return doc.output('arraybuffer');
}
</file>

<file path="src/lib/progress.ts">
import { supabase } from './supabase';
import { schedulerService } from './scheduler';

export interface ProgressService {
  getUserProgress: (userId: string) => Promise<{
    totalQuestions: number;
    correctAnswers: number;
    incorrectAnswers: number;
    masteryScore: number;
  }>;
  updateProgressAfterReview: (userId: string, questionId: string, remembered: boolean) => Promise<void>;
  getUserMetrics: (userId: string) => Promise<{
    totalQuestions: number;
    correctAnswers: number;
    incorrectAnswers: number;
    masteryScore: number;
    nextReviewDates: { [questionId: string]: Date };
  }>;
}

export const createProgressService = (): ProgressService => {
  const getUserProgress = async (userId: string) => {
    const { data, error } = await supabase
      .from('progress_metrics')
      .select('*')
      .eq('user_id', userId)
      .single();

    if (error || !data) {
      console.error('Error fetching progress metrics:', error);
      return {
        totalQuestions: 0,
        correctAnswers: 0,
        incorrectAnswers: 0,
        masteryScore: 0,
      };
    }

    const { totalQuestions, correctAnswers, incorrectAnswers } = data;
    const masteryScore = calculateMasteryScore(correctAnswers, incorrectAnswers);

    return {
      totalQuestions,
      correctAnswers,
      incorrectAnswers,
      masteryScore,
    };
  };

  const updateProgressAfterReview = async (userId: string, questionId: string, remembered: boolean) => {
    // Update the question review status
    await schedulerService.markQuestionAsReviewed('questions', questionId, remembered);

    // Get current progress metrics
    const { data: metricsData, error: metricsError } = await supabase
      .from('progress_metrics')
      .select('*')
      .eq('user_id', userId)
      .single();

    if (metricsError || !metricsData) {
      console.error('Error fetching progress metrics:', metricsError);
      return;
    }

    // Update metrics based on review result
    const updatedMetrics = {
      ...metricsData,
      totalQuestions: metricsData.total_questions + 1,
      correctAnswers: metricsData.correct_answers + (remembered ? 1 : 0),
      incorrectAnswers: metricsData.incorrect_answers + (!remembered ? 1 : 0),
      lastReviewedAt: new Date(),
    };

    // Update in database
    const { error: updateError } = await supabase
      .from('progress_metrics')
      .update(updatedMetrics)
      .eq('id', metricsData.id);

    if (updateError) {
      console.error('Error updating progress metrics:', updateError);
    }
  };

  const getUserMetrics = async (userId: string) => {
    const progress = await getUserProgress(userId);
    const nextReviewDates = await schedulerService.getNextReviewDates('questions', [userId]);

    return {
      ...progress,
      nextReviewDates,
    };
  };

  return {
    getUserProgress,
    updateProgressAfterReview,
    getUserMetrics,
  };
};

const calculateMasteryScore = (correctAnswers: number, incorrectAnswers: number): number => {
  const totalAnswers = correctAnswers + incorrectAnswers;
  if (totalAnswers === 0) return 0;

  return Math.min(100, Math.round((correctAnswers / totalAnswers) * 100));
};

export const progressService = createProgressService();
</file>

<file path="src/lib/supabase.ts">
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Supabase URL and Anon Key must be defined in environment variables');
}

export const supabase = createClient(supabaseUrl, supabaseAnonKey);
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
# .env*  # Commented out to allow tracking .env.example

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

/src/generated/prisma

# AI-generated directories
logs/
# work_breakdown/  # Commented out to allow tracking plan files
</file>

<file path="jest.setup.ts">
/// <reference types="node" />
import '@testing-library/jest-dom';

process.env.NODE_ENV = 'test';
process.env.NEXT_PUBLIC_SUPABASE_URL = 'https://test.supabase.co';
process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY = 'test-anon-key';
process.env.DATABASE_URL = 'postgresql://test:test@localhost:5432/testdb';
process.env.NEXTAUTH_SECRET = 'test-secret';
process.env.NEXTAUTH_URL = 'http://localhost:3000';
</file>

<file path="README.md">
# AI Interview Prep Platform

## Development Setup

### Environment Configuration

1. Copy the example environment file:
   ```bash
   cp .env.example .env
   ```

2. Configure required environment variables in `.env`:
   ```bash
   # Supabase Configuration
   NEXT_PUBLIC_SUPABASE_URL=your_supabase_project_url
   NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key

   # Optional Development Variables
   DEBUG_MODE=true
   ```

3. Verify all required variables are set:
   ```bash
   npm run check-env
   ```

### Testing Configuration

1. Set up test environment variables:
   ```bash
   echo "NODE_ENV=test" >> .env.test
   ```

2. Run the test suite:
   ```bash
   npm test
   ```

### Application Execution

1. Install dependencies:
   ```bash
   npm install
   ```

2. Start the development server:
   ```bash
   npm run dev
   ```

3. Access the application at:
   ```bash
   open http://localhost:3000
   ```

## Production Configuration

### CI/CD Pipeline Setup

1. Add these secrets to your CI/CD environment:
   - `NEXT_PUBLIC_SUPABASE_URL`
   - `NEXT_PUBLIC_SUPABASE_ANON_KEY`

2. Example GitHub Actions configuration:
   ```yaml
   env:
     NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
     NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
     NODE_ENV: production
   ```

## Verification Checklist

1. Validate environment configuration:
   ```bash
   npm run validate-config
   ```

2. Test application startup without `.env` file:
   ```bash
   rm -f .env && npm run dev
   ```

3. Verify production build:
   ```bash
   npm run build && npm start
   ```
</file>

<file path="docs/canonical_spec.md">
# Canonical Specification: AI Interview Prep Platform

## 1. High-Level Vision
The system is an AI-driven platform designed to prepare users for technical interviews. A user selects an interview topic (e.g., "Junior PHP Laravel"), and the system generates relevant, frequently asked questions. The primary interaction is voice-based; users record verbal answers to questions. The system uses a Spaced Repetition System (SRS) to manage question scheduling, ensuring users master topics over time. The platform provides detailed progress tracking and allows users to export their progress to a PDF to showcase their knowledge to potential employers.

## 2. Functional Requirements

*   **User Authentication:** Users must be able to sign up, sign in, and sign out.
*   **Interview Topic Selection:** Users can start a new "interview prep objective" for a specific role.
*   **AI Question Generation:** The system must generate new, relevant interview questions based on the selected topic and the user's progress. These questions should not already be in the user's database.
*   **Voice-Based Answering:** The primary method for answering questions is by recording voice audio. Text input is a secondary option.
*   **Spaced Repetition System (SRS):** All questions answered (correctly or incorrectly) must be integrated into an SRS (Anki-like) model. Users should have clear modes to "repeat," "study," and "discover" questions.

    ### SRS Modes
    The SRS system operates in three distinct modes to optimize learning:

    *   **Repeat Mode:** Focuses on questions that the user has difficulty with or that are overdue for review. This mode includes:
        - Questions with a low ease factor (below 2.0)
        - Questions that are overdue for review
        - Questions that the user has previously struggled with

    *   **Study Mode:** Targets new or recently added questions to help users build a strong foundation. This mode includes:
        - Questions with no previous reviews
        - Questions with only a few reviews (up to 3)
        - Questions that the user has recently added

    *   **Discover Mode:** Introduces new questions that the user hasn't seen before, expanding their knowledge base. This mode includes:
        - Questions not already in the user's review queue
        - New questions generated by the AI
        - Questions from related topics

*   **Progress Analytics:** The user's profile must clearly visualize their progress, strengths, and weaknesses.
*   **Readiness Estimation:** The AI will estimate if a user is ready for an interview for their selected role based on their progress.
*   **PDF Export:** Users can export their entire progress profile into a detailed PDF.

## 3. System Architecture
The system follows a layered architecture with clear separation of concerns:

*   **Presentation Layer**: Next.js (App Router)
*   **Application Layer**: Next.js API Routes
*   **Domain Layer**: Business logic and AI services
*   **Data Layer**: Supabase (PostgreSQL via Prisma) and Supabase Storage

### Component Diagram
```mermaid
graph TD
    A[Frontend] -->|API Calls| B[Next.js API Routes]
    B --> C[Question Service]
    B --> D[User Service]
    B --> E[Analytics Service]
    C --> F[AI Generation Module]
    D --> G[Auth Service]
    E --> H[Progress Tracking]
    C --> I[Prisma ORM]
    D --> I
    E --> I
    I --> J[Supabase PostgreSQL]
    G --> K[Supabase Auth]
    A -->|Uploads| L[Supabase Storage]
</file>

<file path="prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String   @id @default(cuid())
  email             String   @unique
  name              String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  questions         Question[]
  reviews           Review[]
  progressMetrics  ProgressMetrics[]
}

model Question {
  id                String   @id @default(cuid())
  userId            String
  content           String
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  lastReviewed      DateTime?
  reviewInterval    Int      @default(1)
  reviewEase        Float    @default(2.5)
  struggleCount     Int      @default(0)
  lastStruggledAt   DateTime?
  totalStruggleTime Int      @default(0)
  reviewCount       Int      @default(0)
  overdue           Boolean  @default(false)
  weight            Float    @default(1.0)
  topics            String[] @default([])
  user              User     @relation(fields: [userId], references: [id])
  reviews           Review[]
}

model Review {
  id                String   @id @default(cuid())
  questionId        String
  userId            String
  remembered         Boolean
  reviewedAt        DateTime @default(now())
  question          Question @relation(fields: [questionId], references: [id])
  user              User     @relation(fields: [userId], references: [id])
}

model ProgressMetrics {
  id                String   @id @default(cuid())
  userId            String
  totalQuestions    Int      @default(0)
  correctAnswers    Int      @default(0)
  incorrectAnswers  Int      @default(0)
  lastReviewedAt    DateTime @default(now())
  user              User     @relation(fields: [userId], references: [id])
}
</file>

<file path="src/app/api/generate-question/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { supabase } from '@/lib/supabase';
import OpenAI from 'openai';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function POST(req: NextRequest) {
  try {
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await req.json();
    if (!body || typeof body !== 'object') {
      return NextResponse.json({ error: 'Invalid request body' }, { status: 400 });
    }

    const { prompt, maxTokens = 150, temperature = 0.7, questionType = 'general', topics = [] } = body;

    if (!prompt || typeof prompt !== 'string') {
      return NextResponse.json({ error: 'Prompt is required' }, { status: 400 });
    }

    let systemPrompt = `Generate a question based on this prompt: ${prompt}`;

    // Implement prompt engineering based on question type
    if (questionType === 'multiple_choice') {
      systemPrompt = `Generate a multiple choice question with 4 options (A, B, C, D) based on this prompt: ${prompt}`;
    } else if (questionType === 'true_false') {
      systemPrompt = `Generate a true or false question based on this prompt: ${prompt}`;
    } else if (questionType === 'short_answer') {
      systemPrompt = `Generate a short answer question based on this prompt: ${prompt}`;
    }

    // Enhance prompt with topic context for Discover mode
    if (topics && topics.length > 0) {
      const topicList = topics.join(', ');
      systemPrompt += ` The question should be related to these topics: ${topicList}.`;
    }

    const completion = await openai.completions.create({
      model: 'text-davinci-003',
      prompt: systemPrompt,
      max_tokens: maxTokens,
      temperature: temperature,
    });

    if (!completion.choices || completion.choices.length === 0) {
      return NextResponse.json({ error: 'Failed to generate question' }, { status: 500 });
    }

    const generatedQuestion = completion.choices[0].text.trim();

    // For Discover mode, also generate related questions
    if (topics && topics.length > 0) {
      const relatedPrompt = `Generate 2 additional questions related to the following topics and the previous question: ${topics.join(', ')}, "${generatedQuestion}"`;
      const relatedCompletion = await openai.completions.create({
        model: 'text-davinci-003',
        prompt: relatedPrompt,
        max_tokens: maxTokens,
        temperature: temperature,
      });

      if (relatedCompletion.choices && relatedCompletion.choices.length > 0) {
        const relatedQuestions = relatedCompletion.choices[0].text.trim().split('\n').filter(q => q.trim() !== '');
        return NextResponse.json({
          question: generatedQuestion,
          type: questionType,
          relatedQuestions: relatedQuestions.slice(0, 2) // Return up to 2 related questions
        });
      }
    }

    return NextResponse.json({ question: generatedQuestion, type: questionType });
  } catch (error: unknown) {
    if (error instanceof Error) {
      console.error('Error generating question:', error.message);
    } else {
      console.error('Unknown error:', error);
    }
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
</file>

<file path="src/app/api/questions/route.d.ts">
import { NextRequest, NextResponse } from 'next/server';

export type Question = {
  id: string;
  content: string;
  category: string;
  difficulty: string;
  userId: string;
  createdAt: Date;
};

export type UpdateQuestionData = {
  content?: string;
  category?: string;
  difficulty?: string;
};

export async function GET(req: NextRequest): Promise<NextResponse>;
export async function POST(req: NextRequest): Promise<NextResponse>;
export async function PUT(req: NextRequest): Promise<NextResponse>;
export async function DELETE(req: NextRequest): Promise<NextResponse>;
</file>

<file path="src/components/ProgressDashboard.tsx">
'use client';

import React, { useEffect, useState } from 'react';
import { useAuth } from '@/lib/auth-context';
import { progressService } from '@/lib/progress';
import { Line } from 'react-chartjs-2';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
} from 'chart.js';

ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
);

interface ProgressMetrics {
  totalQuestions: number;
  correctAnswers: number;
  incorrectAnswers: number;
  masteryScore: number;
  nextReviewDates: { [questionId: string]: Date };
  struggleData: {
    date: string;
    count: number;
    totalTime: number;
  }[];
}

interface ChartData {
  labels: string[];
  datasets: {
    label: string;
    data: number[];
    borderColor: string;
    fill: boolean;
  }[];
}

const generateHeatmapData = (struggleData: {date: string, count: number, totalTime: number}[]) => {
  const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  const weeks = 6;
  const data = [];

  // Initialize empty grid
  for (let i = 0; i < weeks; i++) {
    data.push(Array(7).fill(0));
  }

  // Populate with actual data
  struggleData.forEach(entry => {
    const date = new Date(entry.date);
    const week = Math.floor(date.getDate() / 7);
    const day = date.getDay();
    if (week < weeks && day < 7) {
      data[week][day] += entry.count + (entry.totalTime / 60); // Combine count and time
    }
  });

  return { data, days };
};

const ProgressDashboard: React.FC = () => {
  const { user } = useAuth();
  const [metrics, setMetrics] = useState<ProgressMetrics | null>(null);
  const [progressTrends, setProgressTrends] = useState<ChartData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  useEffect(() => {
    if (!user) return;

    const fetchMetrics = async () => {
      try {
        const userMetrics = await progressService.getUserMetrics(user.id);
        setMetrics(userMetrics);

        // Generate sample data for demonstration
        const days = 30;
        const trends = Array.from({ length: days }, (_, i) => {
          const date = new Date();
          date.setDate(date.getDate() - i);
          return {
            date: date.toLocaleDateString(),
            score: userMetrics.masteryScore + (Math.random() - 0.5) * 10, // Random fluctuation
          };
        });

        setProgressTrends({
          labels: trends.map(t => t.date),
          datasets: [
            {
              label: 'Mastery Score Over Time',
              data: trends.map(t => Math.max(0, Math.min(100, t.score))),
              borderColor: 'rgba(75, 192, 192, 1)',
              fill: false,
            },
          ],
        });
      } catch (err) {
        setError('Failed to load progress metrics');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };

    fetchMetrics();
  }, [user]);

  if (!user) {
    return <div>Please log in to view your progress.</div>;
  }

  if (loading) {
    return <div>Loading progress metrics...</div>;
  }

  if (error) {
    return <div className="text-red-500">{error}</div>;
  }

  if (!metrics) {
    return <div>No progress data available.</div>;
  }

  return (
    <div className="p-6 bg-white rounded-lg shadow-md">
      <h2 className="text-2xl font-bold mb-4">Your Progress</h2>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div className="p-4 bg-gray-100 rounded-md">
          <h3 className="font-semibold mb-2">Total Questions</h3>
          <p className="text-3xl">{metrics.totalQuestions}</p>
        </div>
        <div className="p-4 bg-gray-100 rounded-md">
          <h3 className="font-semibold mb-2">Correct Answers</h3>
          <p className="text-3xl">{metrics.correctAnswers}</p>
        </div>
        <div className="p-4 bg-gray-100 rounded-md">
          <h3 className="font-semibold mb-2">Incorrect Answers</h3>
          <p className="text-3xl">{metrics.incorrectAnswers}</p>
        </div>
        <div className="p-4 bg-gray-100 rounded-md">
          <h3 className="font-semibold mb-2">Mastery Score</h3>
          <p className="text-3xl">{metrics.masteryScore}%</p>
        </div>
      </div>
      <div className="mt-6">
        <h3 className="font-semibold mb-2">Next Reviews</h3>
        {metrics.nextReviewDates && Object.keys(metrics.nextReviewDates).length > 0 ? (
          <ul>
            {Object.entries(metrics.nextReviewDates).map(([questionId, date]) => (
              <li key={questionId}>
                Question {questionId.substring(0, 6)}... - {new Date(date).toLocaleDateString()}
              </li>
            ))}
          </ul>
        ) : (
          <p>No questions scheduled for review at this time.</p>
        )}
      </div>
      <div className="mt-6 p-4 bg-gray-100 rounded-md">
        <h3 className="font-semibold mb-2">Progress Trends</h3>
        {progressTrends ? (
          <Line data={progressTrends} />
        ) : (
          <p>No progress trend data available.</p>
        )}
      </div>
      <div className="mt-6 p-4 bg-gray-100 rounded-md">
        <h3 className="font-semibold mb-2">Struggle Heatmap</h3>
        {metrics.struggleData && metrics.struggleData.length > 0 ? (
          <div className="heatmap-container">
            <table className="heatmap">
              <tbody>
                {generateHeatmapData(metrics.struggleData).data.map((week, i) => (
                  <tr key={i}>
                    {week.map((value, j) => (
                      <td
                        key={j}
                        className="heatmap-cell"
                        style={{
                          backgroundColor: `rgba(255, 0, 0, ${Math.min(1, value / 10)})`,
                          width: '30px',
                          height: '30px'
                        }}
                        title={`${generateHeatmapData(metrics.struggleData).days[j]}: ${Math.round(value)} struggles`}
                      />
                    ))}
                  </tr>
                ))}
              </tbody>
            </table>
            <div className="heatmap-legend mt-2 flex gap-2 items-center">
              <span className="text-sm">Less</span>
              {[0, 0.25, 0.5, 0.75, 1].map(opacity => (
                <div
                  key={opacity}
                  className="h-4 w-4"
                  style={{backgroundColor: `rgba(255, 0, 0, ${opacity})`}}
                />
              ))}
              <span className="text-sm">More</span>
            </div>
          </div>
        ) : (
          <p>No struggle data available.</p>
        )}
      </div>
    </div>
  );
};

export default ProgressDashboard;
</file>

<file path="jest.config.js">
export const preset = 'ts-jest';
export const testEnvironment = 'node';
export const transform = {
  '^.+\\.tsx?$': 'ts-jest',
};
export const moduleNameMapper = {
  '^@/(.*)$': '<rootDir>/src/$1',
};
export const globals = {
  'ts-jest': {
    tsconfig: 'tsconfig.json',
    stringifyContentPathRegex: '\\.svg$',
  }
};
export const transformIgnorePatterns = ['<rootDir>/node_modules/'];
export const moduleFileExtensions = ['ts', 'tsx', 'js', 'jsx', 'json', 'node'];
export const testMatch = ['**/?(*.)+(spec|test).[tj]s?(x)'];
export const modulePathIgnorePatterns = [];
export const setupFilesAfterEnv = ['<rootDir>/jest.setup.ts'];
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es6",
    "lib": [
      "dom",
      "es6"
    ],
    "module": "esnext",
    "jsx": "preserve",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "./src/*"
      ]
    },
    "allowJs": true,
    "noEmit": true,
    "incremental": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": [
    "src/**/*",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}
</file>

<file path=".roo/rules-auditor/rules.md">
## 1. IDENTITY & PERSONA
You are the **Auditor AI** (🔎 The Auditor). You are an unyielding, methodical, and obsessive gatekeeper of quality. You operate like a digital forensics expert, using `grep` on the `repomix-output.xml` context file to find evidence of compliance. You are **strictly forbidden** from simulating, assuming, or bypassing any step. You have **zero tolerance** for placeholder code, TODOs, or any form of incomplete implementation.

## 2. THE CORE MISSION & TRIGGER
Your mission is to perform a holistic, plan-driven audit of the project. You are triggered by the Dispatcher when the `signals/IMPLEMENTATION_COMPLETE.md` signal exists.

## 3. THE HOLISTIC AUDIT WORKFLOW

### PHASE 1: PREPARATION & PLANNING
1.  **Acknowledge & Setup:**
    *   Announce: "Implementation complete. Beginning STRICT static audit protocol."
    *   Consume `signals/IMPLEMENTATION_COMPLETE.md`.
    *   Create `audit/`.
    *   Execute `repomix` to generate `repomix-output.xml`.

2.  **Create Audit Plan:**
    *   Read `docs/canonical_spec.md`.
    *   Create `audit/audit_plan.md`. This plan **must** be a meticulous checklist covering every single feature, requirement, and constraint from the spec.
    *   Announce: "Comprehensive audit plan generated. Commencing `grep`-based verification. No assumptions will be made."

### PHASE 2: EXECUTION & FINDINGS
3.  **Execute Audit Plan (No Exceptions):**
    *   Initialize an empty internal list to store failure descriptions.
    *   **Step A: Global Placeholder Scan (High Priority):**
        *   Before checking any features, perform a global `grep` scan on `repomix-output.xml` for all common placeholders.
        *   Search patterns **must** include (but are not limited to): `// TODO`, `// FIXME`, `console.log`, `alert(`, `[IMPLEMENT]`, `dummy`, `placeholder`, `return null`.
        *   For every match found, add a precise failure to your internal list, noting the file path and the offending line.
    *   **Step B: Feature Verification via `grep`:**
        *   Iterate through every checklist item `[ ]` in `audit/audit_plan.md`.
        *   For each item, formulate specific `grep` queries to find the implementation logic within `repomix-output.xml`.
        *   Compare the evidence from your `grep` search with the spec requirement.
        *   If the implementation is correct and complete, mark the item `[x]`.
        *   If there is **any** discrepancy, add a detailed failure description to your internal list and mark the item `[x]`.

### PHASE 3: MANDATORY SELF-CORRECTION PROTOCOL
4.  **Final Sanity Check:** Before proceeding, you **must** halt and internally ask and answer the following questions.
    *   "Did I meticulously check every single item in my audit plan using `grep` against `repomix-output.xml`?"
    *   "Have I performed a thorough `grep` scan for all common types of placeholder code and confirmed any findings are logged as failures?"
    *   "Is there any feature in `docs/canonical_spec.md` that I failed to include in `audit/audit_plan.md`?"
    *   "Can I stake my existence on the guarantee that the codebase is 100% complete, with zero placeholders, and perfectly matches the specification?"
    *   If the answer to any of these is 'No' or 'I am unsure', you must go back to Phase 2, correct your process, and repeat until you achieve certainty.

### PHASE 4: REPORTING & FINAL JUDGMENT
5.  **Decision (Post-Correction):** After successfully passing the Self-Correction Protocol, review your internal failure list.

    *   **Condition: Perfect Match (Failure list is empty).**
        *   Announce: "Self-correction protocol passed. Full static audit passed. Generating final user guide."
        *   Create `POST_COMPLETION_GUIDE.md` as per the detailed template.
        *   Create `signals/PROJECT_AUDIT_PASSED.md`.
        *   You **must** handoff to `<mode>dispatcher</mode>`.
        *   After the handoff, you may use `attempt_completion`.

    *   **Condition: Any Deviation (Failure list is NOT empty).**
        *   You **must** create `work_items/item-001-audit-failures.md` containing a complete report of **all** collected failures (including any placeholders).
        *   You **must** announce: "Audit failed. A comprehensive report of all discrepancies has been created. Restarting the planning loop."
        *   You **must** handoff to `<mode>dispatcher</mode>`.
        *   **CRITICAL:** You are **explicitly forbidden** from using `attempt_completion`. The loop must continue.

6.  **Cleanup:**
    *   Delete `repomix-output.xml`.
    *   Delete the `audit/` directory.
</file>

<file path=".roo/rules-product-manager/rules.md">
## 1. IDENTITY & PERSONA
You are the **Product Manager AI** (📈 The Clarifier). You are a meticulous interpreter of the user's vision. Your purpose is to eliminate all ambiguity by transforming a high-level description into a definitive, machine-readable specification. You do not proceed until you are certain of your interpretation's completeness.

## 2. THE CORE MISSION & TRIGGER
Your mission is to create the project's **source of truth**. You are triggered by the Dispatcher only when `docs/app_description.md` exists, but `docs/canonical_spec.md` does not.

## 3. THE CLARIFICATION WORKFLOW

### PHASE 1: DRAFTING THE SPECIFICATION
1.  **Acknowledge & Log:** "New project vision detected. I will create the canonical specification."
2.  **Create Directories:** Ensure `docs/` and `signals/` exist.
3.  **Read and Deconstruct the Vision:**
    *   Read the full contents of `docs/app_description.md`.
    *   Perform a semantic analysis to identify all features, user stories, requirements, and constraints.
4.  **Create Draft Specification:**
    *   Create `docs/canonical_spec.md`. This file must be a comprehensive, non-ambiguous document detailing the entire project. This is now the project's primary reference.
    *   Create a skeleton `docs/README.md`.

### PHASE 2: MANDATORY SELF-CORRECTION PROTOCOL
5.  **Final Sanity Check:** Before proceeding, you **must** halt and internally ask and answer the following questions. You cannot proceed until you can honestly answer "Yes" to all.
    *   "Have I captured every single feature, requirement, and constraint from `docs/app_description.md`?"
    *   "Is there any statement in my `canonical_spec.md` that could be considered ambiguous or open to misinterpretation by the Planner?"
    *   "Is this specification complete enough for a 100% upfront work breakdown, or are there still 'To Be Determined' sections?"
    *   "If I were the Planner, could I create a complete and exhaustive project plan from this document alone, without asking further questions?"
    *   If the answer to any of these is 'No' or 'I am unsure', you must return to Phase 1, refine `docs/canonical_spec.md`, and repeat this self-correction process.

### PHASE 3: FINALIZATION & HANDOFF
6.  **Announce & Handoff (Post-Correction):**
    *   Announce: "Self-correction protocol passed. Canonical specification is complete and verified. Handing off to the Planner for full-scale planning."
    *   Create the signal file `signals/SPECIFICATION_COMPLETE.md`.
    *   Switch mode to `<mode>dispatcher</mode>`.
</file>

<file path=".roo/rules-system-supervisor/rules.md">
## 1. IDENTITY & PERSONA
You are the **System_Supervisor AI** (👑 Supervisor). You are the ultimate meta-agent that repairs the system's workflow logic. You operate by reading the `project_manifest.json` to find and analyze the system log.

## 2. THE CORE MISSION & TRIGGER
You are activated by the `Dispatcher` during an infinite loop. Your mission is to diagnose the flawed workflow by analyzing the log file and rewrite an agent's rules to correct it.

## 3. THE META-ANALYSIS & REPAIR WORKFLOW

1.  **Read the Manifest:** Read `project_manifest.json` to get the `log_file` path.
2.  **Ingest System State:**
    *   `echo '{"timestamp": "...", "agent": "System_Supervisor", "event": "action_start", "details": "Activated to resolve system-level failure."}' >> [log_file]`

3.  **Perform Root Cause Analysis on the *Workflow*:**
    *   **Analyze the Logs:** Read the `log_file` to trace the sequence of agent handoffs that led to the loop.
    *   **Analyze the Rules:** Read the `.roo/rules-*.md` files for the involved agents.
    *   **Identify & Log the Flaw:** Pinpoint the exact rule conflict causing the failure.
    *   `echo '{"timestamp": "...", "agent": "System_Supervisor", "event": "diagnosis", "details": "Identified logical flaw: [Concise description]"}' >> [log_file]`

4.  **Formulate a Rule-Based Solution:**
    *   Identify the target agent whose rules must be changed.
    *   Draft a new, corrected version of that agent's `rules.md` file.

5.  **Execute the System Refactor:**
    *   **Action:** Replace the content of `[path_to_agent_rules.md]` with the new ruleset.
    *   `echo '{"timestamp": "...", "agent": "System_Supervisor", "event": "action_complete", "details": "Applied fix by rewriting rules for agent: [Agent Name]."}' >> [log_file]`

6.  **Announce Fix & Handoff:**
    *   Announce: "System workflow repaired. I have updated the rules for the `[Agent Name]`. Retrying operation."
    *   Switch mode back to `<mode>dispatcher</mode>`.

## 4. CRITICAL DIRECTIVES
*   You only modify `.md` rule files.
*   Make the smallest, most targeted change possible.
*   You are forbidden from modifying your own `rules.md` file.
*   Explain your reasoning in your announcement and logs.
</file>

<file path="src/components/SRSControls.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { useAuth } from '@/lib/auth-context';
import { schedulerService } from '@/lib/scheduler';
import { progressService } from '@/lib/progress';
import { supabase } from '@/lib/supabase';

type StudyMode = 'repeat' | 'study' | 'discover';

interface SRSControlsProps {
  questionId: string;
  onReviewComplete: (remembered: boolean) => void;
}

const SRSControls: React.FC<SRSControlsProps> = ({ questionId, onReviewComplete }) => {
  const { user } = useAuth();
  const [remembered, setRemembered] = useState<boolean | null>(null);
  const [nextReviewDate, setNextReviewDate] = useState<Date | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [studyMode, setStudyMode] = useState<StudyMode>('study'); // Default to study mode
  const [struggleCount, setStruggleCount] = useState(0);
  const [lastStruggledAt, setLastStruggledAt] = useState<Date | null>(null);
  const [totalStruggleTime, setTotalStruggleTime] = useState(0);

  useEffect(() => {
    if (!user || !questionId) return;

    const fetchQuestionData = async () => {
      try {
        const { data, error } = await supabase
          .from('questions')
          .select('last_reviewed, review_interval, review_ease, struggle_count, last_struggled_at, total_struggle_time')
          .eq('id', questionId)
          .single();

        if (error) throw error;

        const nextReviewDates = await schedulerService.getNextReviewDates('questions', [questionId]);
        setNextReviewDate(nextReviewDates[questionId]);
        setStruggleCount(data.struggle_count || 0);
        setLastStruggledAt(data.last_struggled_at ? new Date(data.last_struggled_at) : null);
        setTotalStruggleTime(data.total_struggle_time || 0);
      } catch (err) {
        setError('Failed to load question data');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };

    fetchQuestionData();
  }, [user, questionId]);

  const handleReview = async () => {
    if (remembered === null || !user) return;

    setLoading(true);
    try {
      await schedulerService.markQuestionAsReviewed('questions', questionId, remembered);
      await progressService.updateProgressAfterReview(user.id, questionId, remembered);
      onReviewComplete(remembered);

      // Update next review date
      const nextReviewDates = await schedulerService.getNextReviewDates('questions', [questionId]);
      const date = nextReviewDates[questionId];
      setNextReviewDate(date);
    } catch (err) {
      setError('Failed to record review');
      console.error(err);
    } finally {
      setLoading(false);
    }
  };

  if (!user) {
    return <div>Please log in to use SRS controls.</div>;
  }

  if (loading) {
    return <div>Loading SRS controls...</div>;
  }

  if (error) {
    return <div className="text-red-500">{error}</div>;
  }

  return (
    <div className="mt-4 p-4 bg-gray-100 rounded-md">
      <h3 className="font-semibold mb-2">Spaced Repetition System</h3>
      
      {/* Struggle Metrics */}
      <div className="mb-4 p-3 bg-white rounded-md shadow-sm">
        <h4 className="font-medium mb-2">Struggle Metrics</h4>
        <div className="grid grid-cols-3 gap-4 text-sm">
          <div className="text-center">
            <p className="font-semibold">{struggleCount}</p>
            <p className="text-gray-600">Times struggled</p>
          </div>
          <div className="text-center">
            <p className="font-semibold">
              {lastStruggledAt ?
                new Date(lastStruggledAt).toLocaleDateString() :
                'Never'
              }
            </p>
            <p className="text-gray-600">Last struggled</p>
          </div>
          <div className="text-center">
            <p className="font-semibold">
              {totalStruggleTime > 0 ?
                `${Math.floor(totalStruggleTime / 60)}m ${totalStruggleTime % 60}s` :
                '0s'
              }
            </p>
            <p className="text-gray-600">Total time</p>
          </div>
        </div>
      </div>

      <div className="mb-2 flex space-x-2">
        <label className="font-medium mr-2">Mode:</label>
        <select
          className="border rounded px-2 py-1"
          value={studyMode}
          onChange={(e) => setStudyMode(e.target.value as StudyMode)}
        >
          <option value="repeat">Repeat</option>
          <option value="study">Study</option>
          <option value="discover">Discover</option>
        </select>
      </div>
      <p className="mb-2">Next review date: {nextReviewDate ? nextReviewDate.toLocaleDateString() : 'Calculating...'}</p>
      <p className="mb-4 font-medium">Current Mode: {studyMode.charAt(0).toUpperCase() + studyMode.slice(1)}</p>
      <div className="flex space-x-4">
        <button
          className={`px-4 py-2 rounded ${remembered === true ? 'bg-green-500 text-white' : 'bg-gray-300'}`}
          onClick={() => setRemembered(true)}
          disabled={loading}
        >
          Remembered
        </button>
        <button
          className={`px-4 py-2 rounded ${remembered === false ? 'bg-red-500 text-white' : 'bg-gray-300'}`}
          onClick={() => setRemembered(false)}
          disabled={loading}
        >
          Forgotten
        </button>
      </div>
      <button
        className="mt-4 px-4 py-2 bg-blue-500 text-white rounded disabled:opacity-50"
        onClick={handleReview}
        disabled={remembered === null || loading}
      >
        Record Review
      </button>
    </div>
  );
};

export default SRSControls;
</file>

<file path="src/components/VoiceRecorder.tsx">
import React, { useState, useRef, useEffect } from 'react';
import { useAuth } from '@/lib/auth-context';
import { supabase } from '@/lib/supabase';
import { transcriptionService } from '@/lib/transcription';

const VoiceRecorder: React.FC<{ onRecordingComplete: (filePath: string, transcription: string) => void }> = ({ onRecordingComplete }) => {
  const { user } = useAuth();
  const [isRecording, setIsRecording] = useState(false);
  const [isTranscribing, setIsTranscribing] = useState(false);
  const [error, setError] = useState('');
  const [transcription, setTranscription] = useState('');
  const [highlightedText, setHighlightedText] = useState('');
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const audioChunksRef = useRef<Blob[]>([]);
  const audioRef = useRef<HTMLAudioElement | null>(null);

  const startRecording = async () => {
    if (!user) return;

    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mediaRecorder = new MediaRecorder(stream);

      mediaRecorderRef.current = mediaRecorder;
      audioChunksRef.current = [];

      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          audioChunksRef.current.push(event.data);
        }
      };

      mediaRecorder.onstop = async () => {
        const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/wav' });
        const filePath = `${user.id}/${Date.now()}.wav`;

        const { data, error: uploadError } = await supabase.storage
          .from('recordings')
          .upload(filePath, audioBlob);

        if (uploadError) {
          setError('Failed to upload recording');
          console.error('Upload error:', uploadError);
        } else {
          setError('');
          await transcribeAudio(data.path);
        }
      };

      mediaRecorder.start();
      setIsRecording(true);
    } catch (err) {
      setError('Error accessing microphone');
      console.error('Recording error:', err);
    }
  };

  const stopRecording = () => {
    if (mediaRecorderRef.current) {
      mediaRecorderRef.current.stop();
      setIsRecording(false);
      setIsTranscribing(true);
    }
  };

  const transcribeAudio = async (filePath: string) => {
    try {
      const transcription = await transcriptionService.processTranscription(filePath);
      setTranscription(transcription);
      setHighlightedText('');
      onRecordingComplete(filePath, transcription);
    } catch (err) {
      setError('Failed to transcribe audio');
      console.error('Transcription error:', err);
    } finally {
      setIsTranscribing(false);
    }
  };

  const handlePlay = () => {
    if (audioRef.current) {
      audioRef.current.play();
    }
  };

  const handlePause = () => {
    if (audioRef.current) {
      audioRef.current.pause();
    }
  };

  const syncHighlighting = (event: React.SyntheticEvent<HTMLAudioElement>) => {
    const audio = event.target as HTMLAudioElement;
    const currentTime = audio.currentTime;
    const words = transcription.split(' ');
    const wordIndex = Math.floor((currentTime / audio.duration) * words.length);
    const highlighted = words.slice(0, wordIndex).join(' ') + ' <span class="highlight">|</span> ' + words.slice(wordIndex).join(' ');
    setHighlightedText(highlighted);
  };

  return (
    <div className="mt-6">
      <button
        onClick={isRecording ? stopRecording : startRecording}
        className={`w-full py-2 px-4 rounded-md text-white ${
          isRecording ? 'bg-red-600 hover:bg-red-700' : 'bg-blue-600 hover:bg-blue-700'
        } focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500`}
        disabled={isTranscribing}
      >
        {isRecording ? 'Stop Recording' : 'Start Recording'}
      </button>
      {error && <p className="text-red-500 text-sm mt-2">{error}</p>}
      {transcription && (
        <div className="mt-4 p-4 border rounded bg-gray-100">
          <h3 className="font-semibold mb-2">Transcription:</h3>
          <div className="transcription-text" dangerouslySetInnerHTML={{ __html: highlightedText || transcription }} />
          <audio
            ref={audioRef}
            src={`/api/get-recording?path=${user?.id}/${Date.now()}.wav`}
            onTimeUpdate={syncHighlighting}
            controls
            className="mt-2"
          />
        </div>
      )}
    </div>
  );
};

export default VoiceRecorder;
</file>

<file path="src/lib/assessment.ts">
export interface TopicRelationship {
  topic: string;
  relatedTopics: string[];
  strength: number; // 0-1 scale of relationship strength
}

export interface QuestionPerformance {
  questionId: string;
  topic: string;
  subtopics: string[];
  correctness: number; // 0-1 scale
  responseTime: number;
  attempts: number;
  relatedTopics?: string[]; // Dynamically discovered related topics
}

const defaultTopicRelationships: TopicRelationship[] = [
  {
    topic: 'javascript',
    relatedTopics: ['typescript', 'web-development', 'nodejs'],
    strength: 0.8
  },
  {
    topic: 'typescript',
    relatedTopics: ['javascript', 'angular', 'react'],
    strength: 0.9
  },
  {
    topic: 'react',
    relatedTopics: ['javascript', 'typescript', 'redux'],
    strength: 0.85
  }
];

export interface KnowledgeGap {
  topic: string;
  subtopic?: string;
  severity: number; // 0-1 scale
  relatedQuestions: string[];
  relatedTopics?: string[]; // Added for topic relationship modeling
}

export interface AssessmentService {
  calculateScore: (answers: Record<string, string>) => number;
  getRecommendations: (score: number) => string[];
  generateRecommendationEngine: (score: number) => string[];
  analyzeKnowledgeGaps: (
    performances: QuestionPerformance[],
    allTopics: string[]
  ) => Promise<KnowledgeGap[]>;
}

/**
 * Analyzes question performances to identify knowledge gaps using AI
 * @param performances Array of question performance data
 * @param allTopics All available topics in the system
 * @returns Array of identified knowledge gaps
 */
const analyzeKnowledgeGaps = async (
  performances: QuestionPerformance[],
  _allTopics: string[]
): Promise<KnowledgeGap[]> => {
  void _allTopics; // Explicitly mark as unused for now
  // TODO: Use allTopics to identify gaps in topics not yet attempted
  // Build topic relationship map
  const topicRelations = new Map<string, TopicRelationship>(
    defaultTopicRelationships.map(rel => [rel.topic, rel])
  );

  // Group performances by topic/subtopic and enrich with related topics
  const topicMap = new Map<string, QuestionPerformance[]>();
  
  for (const perf of performances) {
    const key = `${perf.topic}|${perf.subtopics.join(',')}`;
    const existing = topicMap.get(key) || [];
    
    // Add related topics from predefined relationships
    const enrichedPerf = {
      ...perf,
      relatedTopics: topicRelations.get(perf.topic)?.relatedTopics || []
    };
    
    topicMap.set(key, [...existing, enrichedPerf]);
  }

  // Calculate gap severity scores with related topics
  const gaps: KnowledgeGap[] = [];
  
  for (const [key, perfs] of topicMap) {
    const [topic, subtopic] = key.split('|');
    const avgCorrectness = perfs.reduce((sum, p) => sum + p.correctness, 0) / perfs.length;
    const severity = 1 - avgCorrectness;
    
    const gap: KnowledgeGap = {
      topic,
      subtopic: subtopic || undefined,
      severity,
      relatedQuestions: perfs.map(p => p.questionId)
    };

    // Find related topics with high severity gaps
    const relatedTopics = new Set<string>();
    for (const perf of perfs) {
      for (const rt of perf.relatedTopics || []) {
        if (severity > 0.7) { // Only include strong relationships for severe gaps
          relatedTopics.add(rt);
        }
      }
    }

    if (relatedTopics.size > 0) {
      gap.relatedTopics = Array.from(relatedTopics);
    }

    gaps.push(gap);
  }

  // Combine heuristic gaps with AI analysis
  try {
    const aiGaps = await fetch('/api/analyze-knowledge-gaps', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        performances,
        topics: _allTopics,
        currentGaps: gaps
      }),
    }).then(res => res.json());

    // Merge and deduplicate gaps
    const mergedGaps = [...gaps];
    for (const aiGap of aiGaps) {
      if (!mergedGaps.some(g => g.topic === aiGap.topic && g.subtopic === aiGap.subtopic)) {
        mergedGaps.push(aiGap);
      }
    }

    // Sort by severity descending
    return mergedGaps.sort((a, b) => b.severity - a.severity);
  } catch (error) {
    console.error('AI knowledge gap analysis failed:', error);
    return gaps; // Fallback to heuristic gaps
  }
};

export const createAssessmentService = (): AssessmentService => {
  const calculateScore = (answers: Record<string, string>): number => {
    // Simple scoring model: 1 point for each correct answer
    // In a real implementation, this would be more complex
    const totalQuestions = Object.keys(answers).length;
    const correctAnswers = Object.values(answers).filter(answer => answer === 'correct').length;

    return (correctAnswers / totalQuestions) * 100;
  };

  const getRecommendations = (score: number): string[] => {
    if (score >= 90) {
      return ['You are well-prepared! Consider focusing on advanced topics.', 'Practice with more challenging questions.'];
    } else if (score >= 70) {
      return ['Good job! Review areas where you made mistakes.', 'Focus on improving your weaker areas.'];
    } else if (score >= 50) {
      return ['You need more practice. Review the material carefully.', 'Consider getting help from a tutor or study group.'];
    } else {
      return ['You need significant improvement. Start with the basics.', 'Create a study plan and stick to it.'];
    }
  };

  const generateRecommendationEngine = (score: number): string[] => {
    // More advanced recommendation engine
    // This could be based on machine learning models or complex algorithms
    // For now, we'll use a simple rule-based approach

    const recommendations: string[] = [];

    if (score >= 90) {
      recommendations.push('Excellent job! You are ready for advanced topics.');
      recommendations.push('Consider taking practice exams under timed conditions.');
    } else if (score >= 70) {
      recommendations.push('Good performance! Focus on areas where you made mistakes.');
      recommendations.push('Review key concepts and practice regularly.');
    } else if (score >= 50) {
      recommendations.push('You need more practice. Focus on understanding basic concepts.');
      recommendations.push('Consider joining a study group or getting a tutor.');
    } else {
      recommendations.push('You need significant improvement. Start with the basics.');
      recommendations.push('Create a structured study plan and stick to it.');
    }

    // Add specific recommendations based on question performance
    // This is a placeholder for more advanced logic
    recommendations.push('Review your notes and textbooks.');
    recommendations.push('Practice with sample questions and past exams.');

    return recommendations;
  };


  return {
    calculateScore,
    getRecommendations,
    generateRecommendationEngine,
    analyzeKnowledgeGaps,
  };
};

export const assessmentService = createAssessmentService();
</file>

<file path=".roo/rules-emergency/rules.md">
## 1. IDENTITY & PERSONA
You are the **Emergency Intervention AI** (🚨 Emergency). You are a manifest-driven diagnostician. You use the `architectural_map` and the `<codebase_search>` tool to rapidly pinpoint the source of an error.

## 2. THE CORE MISSION & TRIGGER
Triggered by a `needs_assistance` signal, your mission is to diagnose the failure, create a `FIX_PLAN.md`, and register it in the manifest.

## 3. THE INTERVENTION WORKFLOW

1.  **Read the Manifest:** Read `project_manifest.json` to get all file paths and the `architectural_map`.
2.  **Analyze Failure Signal:** Read the contents of the `needs_assistance` signal file to get the error message and context.
3.  **Diagnose with Codebase Search (Targeted):**
    *   First, try a direct query using the `<codebase_search>` tool:
        <codebase_search>
        <query>[verbatim error message from needs_assistance file]</query>
        </codebase_search>
    *   If that is inconclusive, read the developer's notes in the signal file to identify the architectural concept (e.g., "The error is in the user session logic").
    *   Look up the concept (e.g., "authentication") in the `architectural_map`.
    *   Run the high-quality query from the map using the `<codebase_search>` tool:
        <codebase_search>
        <query>[query from manifest's architectural_map]</query>
        </codebase_search>
4.  **Formulate and Register Fix Plan:**
    *   Create a `FIX_PLAN.md` with precise steps.
    *   Update the `active_plan_file` in `project_manifest.json` to point to `FIX_PLAN.md`.
5.  **Consume Distress Signal:**
    *   Delete the `needs_assistance` signal file.
    *   Log and announce the resolution.
6.  **Handoff:** Switch to `<mode>dispatcher</mode>`.
</file>

<file path="src/components/FlashcardStudy.tsx">
import React, { useState, useEffect } from 'react';
import { supabase } from '../lib/supabase';
import { useAuth } from '../lib/auth-context';
import { schedulerService } from '../lib/scheduler';

interface FlashcardBase {
  id: string;
  question: string;
  answer: string;
  rating: 'easy' | 'normal' | 'hard';
  user_id: string;
  last_reviewed?: string | null;
  review_interval?: number;
  review_ease?: number;
  reviewCount?: number;
}

interface Flashcard extends FlashcardBase {
  createdAt: Date;
  lastReviewed: Date | null;
  reviewInterval: number;
  reviewEase: number;
  struggleCount: number;
  lastStruggledAt: Date | null;
  totalStruggleTime: number;
}

interface FlashcardQueues {
  newQuestions: Flashcard[];
  recentQuestions: Flashcard[];
}

interface RawFlashcard {
  id: string;
  question: string;
  answer: string;
  rating: 'easy' | 'normal' | 'hard';
  user_id: string;
  created_at?: string;
  last_reviewed?: string | null;
  review_interval?: number;
  review_ease?: number;
  review_count?: number;
  struggle_count?: number;
  last_struggled_at?: string | null;
  total_struggle_time?: number;
}

const FlashcardStudy: React.FC = () => {
  const { user } = useAuth();
  const [flashcards, setFlashcards] = useState<Flashcard[]>([]);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [isFlipped, setIsFlipped] = useState(false);
  const [rating, setRating] = useState<'easy' | 'normal' | 'hard'>('normal');
  const [isLoading, setIsLoading] = useState(true);
  const [nextReviewDate, setNextReviewDate] = useState<Date | null>(null);
  const [queueType, setQueueType] = useState<'new' | 'recent'>('new');

  useEffect(() => {
    if (user) {
      fetchFlashcards(user.id);
    }
  }, [user]);

  const fetchFlashcards = async (userId: string) => {
    setIsLoading(true);
    try {
      const { data, error } = await supabase
        .from('flashcards')
        .select('*')
        .eq('user_id', userId);

      if (error) {
        console.error('Error fetching flashcards:', error);
        return;
      }

      // Convert to Flashcard type with defaults
      const flashcards = (data || []).map((f: RawFlashcard): Flashcard => ({
        id: f.id,
        question: f.question,
        answer: f.answer,
        rating: f.rating,
        user_id: f.user_id,
        createdAt: f.created_at ? new Date(f.created_at) : new Date(),
        lastReviewed: f.last_reviewed ? new Date(f.last_reviewed) : null,
        reviewInterval: f.review_interval || 1,
        reviewEase: f.review_ease || 2.5,
        struggleCount: f.struggle_count || 0,
        lastStruggledAt: f.last_struggled_at ? new Date(f.last_struggled_at) : null,
        totalStruggleTime: f.total_struggle_time || 0,
        reviewCount: f.review_count || 0,
      }));

      // Get study mode queues
      const queues: FlashcardQueues = {
        newQuestions: flashcards.filter(f => f.reviewCount === 0),
        recentQuestions: flashcards.filter(f => f.reviewCount && f.reviewCount > 0 && f.reviewCount <= 3)
      };

      // Set initial queue based on state
      setFlashcards(queueType === 'new' ? queues.newQuestions : queues.recentQuestions);
    } catch (err) {
      console.error('Error fetching flashcards:', err);
    } finally {
      setIsLoading(false);
    }
  };

  const currentFlashcard = flashcards[currentIndex];

  const handleFlip = () => {
    setIsFlipped(!isFlipped);
  };

  const handleRate = async (newRating: 'easy' | 'normal' | 'hard') => {
    if (!user || !currentFlashcard) return;

    setRating(newRating);
    const updatedFlashcards = [...flashcards];
    updatedFlashcards[currentIndex].rating = newRating;
    setFlashcards(updatedFlashcards);

    // Update rating in database
    try {
      await schedulerService.markQuestionAsReviewed('flashcards', currentFlashcard.id, newRating === 'easy');
      await supabase
        .from('flashcards')
        .update({ rating: newRating })
        .eq('id', currentFlashcard.id)
        .eq('user_id', user.id);

      // Update next review date
      const nextReviewDates = await schedulerService.getNextReviewDates('flashcards', [currentFlashcard.id]);
      setNextReviewDate(nextReviewDates[currentFlashcard.id]);
    } catch (error) {
      console.error('Error updating flashcard rating:', error);
    }

    // Move to next flashcard
    if (currentIndex < flashcards.length - 1) {
      setCurrentIndex(currentIndex + 1);
    }
    setIsFlipped(false);
  };

  useEffect(() => {
    if (currentFlashcard) {
      const fetchNextReview = async () => {
        if (!user) return;

        try {
          const nextReviewDates = await schedulerService.getNextReviewDates('flashcards', [currentFlashcard.id]);
          setNextReviewDate(nextReviewDates[currentFlashcard.id]);
        } catch (err) {
          console.error('Error fetching next review date:', err);
        }
      };

      fetchNextReview();
    }
  }, [currentFlashcard, user]);

  if (isLoading) {
    return <div>Loading flashcards...</div>;
  }

  if (flashcards.length === 0) {
    return <div>No flashcards available. Please add some flashcards.</div>;
  }

  return (
    <div className="p-4 border rounded shadow">
      <h2 className="text-xl font-bold mb-4">Flashcard Study</h2>
      <div className="mb-4 flex space-x-4">
        <button
          onClick={() => {
            setQueueType('new');
            setFlashcards(prev => prev.filter(f => f.reviewCount === 0));
          }}
          className={`px-4 py-2 rounded ${queueType === 'new' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
        >
          New Questions
        </button>
        <button
          onClick={() => {
            setQueueType('recent');
            setFlashcards(prev => prev.filter(f => f.reviewCount !== undefined && f.reviewCount > 0 && f.reviewCount <= 3));
          }}
          className={`px-4 py-2 rounded ${queueType === 'recent' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
        >
          Recent Questions
        </button>
      </div>
      {nextReviewDate && (
        <p className="mb-4">
          Next review: {nextReviewDate.toLocaleDateString()}
        </p>
      )}
      <div
        className="flashcard bg-white border-4 rounded shadow p-4 mb-4 relative"
        style={{
          borderColor: `rgba(255, 0, 0, ${Math.min(0.8, currentFlashcard.struggleCount / 5)})`,
          borderWidth: `${Math.min(4, 1 + currentFlashcard.struggleCount)}px`
        }}
      >
        <div className="struggle-indicator absolute top-2 right-2">
          <div className="flex items-center bg-red-100 rounded-lg p-2">
            <svg
              className="w-5 h-5 text-red-600 mr-1"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
              />
            </svg>
            <span className="text-red-600 font-semibold">
              {currentFlashcard.struggleCount}
            </span>
          </div>
          <div className="mt-1 w-full bg-gray-200 rounded-full h-1.5">
            <div
              className="bg-red-600 h-1.5 rounded-full"
              style={{ width: `${Math.min(100, currentFlashcard.struggleCount * 20)}%` }}
            ></div>
          </div>
          {currentFlashcard.lastStruggledAt && (
            <div className="text-xs text-gray-500 mt-1">
              Last: {new Date(currentFlashcard.lastStruggledAt).toLocaleDateString()}
            </div>
          )}
        </div>
        <div className="question text-lg font-semibold mb-2">
          {isFlipped ? currentFlashcard.answer : currentFlashcard.question}
        </div>
        <button
          onClick={handleFlip}
          className="bg-blue-500 text-white px-4 py-2 rounded mb-2"
        >
          {isFlipped ? 'Hide Answer' : 'Show Answer'}
        </button>
        {isFlipped && (
          <div className="ratings mb-2">
            <button
              onClick={() => handleRate('easy')}
              className={`px-2 py-1 rounded mr-2 ${rating === 'easy' ? 'bg-green-500 text-white' : 'bg-gray-200'}`}
            >
              Easy
            </button>
            <button
              onClick={() => handleRate('normal')}
              className={`px-2 py-1 rounded mr-2 ${rating === 'normal' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
            >
              Normal
            </button>
            <button
              onClick={() => handleRate('hard')}
              className={`px-2 py-1 rounded ${rating === 'hard' ? 'bg-red-500 text-white' : 'bg-gray-200'}`}
            >
              Hard
            </button>
          </div>
        )}
      </div>
      <p className="text-sm text-gray-600">
        {currentIndex + 1} of {flashcards.length}
      </p>
    </div>
  );
};

export default FlashcardStudy;
</file>

<file path="src/lib/__tests__/srsModes.test.ts">
import { schedulerService } from '@/lib/scheduler';
import { supabase } from '@/lib/supabase';
import { assessmentService } from '@/lib/assessment';
import { getRepeatModeQuestions, getStudyModeQuestions, getDiscoverModeQuestions, Question } from '@/lib/srs';

// Mock data
const mockUser = { id: 'user123' };
const mockQuestions: Question[] = [
  // Basic questions
  { id: 'q1', user_id: 'user123', createdAt: new Date('2024-01-01'), lastReviewed: null, reviewInterval: 1, reviewEase: 1.5, struggleCount: 0, lastStruggledAt: null, totalStruggleTime: 0, reviewCount: 0, question: 'What is 2+2?', answer: '4', rating: 'easy', topics: ['math'] },
  { id: 'q2', user_id: 'user123', createdAt: new Date('2024-01-02'), lastReviewed: new Date('2024-01-01'), reviewInterval: 5, reviewEase: 3.0, struggleCount: 2, lastStruggledAt: new Date('2024-02-01'), totalStruggleTime: 300, reviewCount: 5, question: 'What is gravity?', answer: 'Force that attracts objects', rating: 'normal', topics: ['science'] },
  { id: 'q3', user_id: 'user123', createdAt: new Date('2024-01-03'), lastReviewed: new Date('2024-05-01'), reviewInterval: 10, reviewEase: 2.5, struggleCount: 1, lastStruggledAt: new Date('2024-04-01'), totalStruggleTime: 150, reviewCount: 3, question: 'Who was the first US president?', answer: 'George Washington', rating: 'easy', topics: ['history'] },
  { id: 'q4', user_id: 'user123', createdAt: new Date('2024-01-04'), lastReviewed: new Date('2024-03-01'), reviewInterval: 3, reviewEase: 2.0, struggleCount: 3, lastStruggledAt: new Date('2024-03-15'), totalStruggleTime: 450, reviewCount: 2, question: 'What is photosynthesis?', answer: 'Process by which plants make food', rating: 'hard', topics: ['math', 'science'] },
  { id: 'q5', user_id: 'user123', createdAt: new Date('2024-01-05'), lastReviewed: new Date('2024-06-01'), reviewInterval: 8, reviewEase: 2.8, struggleCount: 0, lastStruggledAt: null, totalStruggleTime: 0, reviewCount: 1, question: 'What is the capital of France?', answer: 'Paris', rating: 'easy', topics: ['history', 'math'] },

  // Questions for testing new features
  { id: 'q6', user_id: 'user123', createdAt: new Date('2024-01-06'), lastReviewed: new Date('2024-01-15'), reviewInterval: 2, reviewEase: 2.2, struggleCount: 4, lastStruggledAt: new Date('2024-01-20'), totalStruggleTime: 600, reviewCount: 1, question: 'What is E=mc^2?', answer: 'Mass-energy equivalence', rating: 'hard', topics: ['physics'] },
  { id: 'q7', user_id: 'user123', createdAt: new Date('2024-01-07'), lastReviewed: new Date('2024-02-10'), reviewInterval: 4, reviewEase: 2.7, struggleCount: 0, lastStruggledAt: null, totalStruggleTime: 0, reviewCount: 4, question: 'What is H2O?', answer: 'Water', rating: 'easy', topics: ['chemistry'] },
  { id: 'q8', user_id: 'user123', createdAt: new Date('2024-01-08'), lastReviewed: new Date('2024-03-25'), reviewInterval: 6, reviewEase: 1.8, struggleCount: 2, lastStruggledAt: new Date('2024-03-30'), totalStruggleTime: 200, reviewCount: 2, question: 'What is photosynthesis?', answer: 'Process by which plants make food', rating: 'normal', topics: ['biology'] },
];

// Mock functions
jest.mock('@/lib/supabase');
jest.mock('@/lib/scheduler');

describe('SRS Modes Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    (supabase.auth.getUser as jest.Mock).mockResolvedValue({ data: { user: mockUser }, error: null });
    (supabase.from as jest.Mock).mockReturnValue({
      select: jest.fn().mockResolvedValue({ data: mockQuestions, error: null }),
    });
  });

  it('should filter questions for Repeat mode with strict criteria', async () => {
    const mode = 'repeat';
    const questions = await schedulerService.getQuestionsByMode(mode, mockUser.id, []);

    // Should include:
    // q1 - ease 1.5 < 2.0
    // q4 - struggleCount 3 >= 3
    // q6 - struggleCount 4 >= 3
    // q8 - ease 1.8 < 2.0
    expect(questions).toHaveLength(4);
    expect(questions.map(q => q.id)).toContain('q1');
    expect(questions.map(q => q.id)).toContain('q4');
    expect(questions.map(q => q.id)).toContain('q6');
    expect(questions.map(q => q.id)).toContain('q8');
  });

  it('should filter questions for Study mode', async () => {
    const mode = 'study';
    const questions = await schedulerService.getQuestionsByMode(mode, mockUser.id, []);

    expect(questions).toHaveLength(3);
    expect(questions.map(q => q.id)).toContain('q1');
    expect(questions.map(q => q.id)).toContain('q2');
    expect(questions.map(q => q.id)).toContain('q4');
  });

  it('should filter questions for Discover mode', async () => {
    const mode = 'discover';
    const questions = await schedulerService.getQuestionsByMode(mode, mockUser.id, ['q1', 'q2']);

    expect(questions).toHaveLength(3);
    expect(questions.map(q => q.id)).toContain('q3');
    expect(questions.map(q => q.id)).toContain('q4');
    expect(questions.map(q => q.id)).toContain('q5');
  });

  it('should handle empty question list for Repeat mode', async () => {
    (supabase.from as jest.Mock).mockReturnValueOnce({
      select: jest.fn().mockResolvedValue({ data: [], error: null }),
    });

    const mode = 'repeat';
    const questions = await schedulerService.getQuestionsByMode(mode, mockUser.id, []);

    expect(questions).toHaveLength(0);
  });

  it('should handle empty question list for Study mode', async () => {
    (supabase.from as jest.Mock).mockReturnValueOnce({
      select: jest.fn().mockResolvedValue({ data: [], error: null }),
    });

    const mode = 'study';
    const questions = await schedulerService.getQuestionsByMode(mode, mockUser.id, []);

    expect(questions).toHaveLength(0);
  });

  it('should handle empty question list for Discover mode', async () => {
    (supabase.from as jest.Mock).mockReturnValueOnce({
      select: jest.fn().mockResolvedValue({ data: [], error: null }),
    });

    const mode = 'discover';
    const questions = await schedulerService.getQuestionsByMode(mode, mockUser.id, []);

    expect(questions).toHaveLength(0);
  });

  it('should handle API error for Repeat mode', async () => {
    (supabase.from as jest.Mock).mockReturnValueOnce({
      select: jest.fn().mockResolvedValue({ data: null, error: 'API error' }),
    });

    const mode = 'repeat';
    const questions = await schedulerService.getQuestionsByMode(mode, mockUser.id, []);

    expect(questions).toHaveLength(0);
  });

  it('should handle API error for Study mode', async () => {
    (supabase.from as jest.Mock).mockReturnValueOnce({
      select: jest.fn().mockResolvedValue({ data: null, error: 'API error' }),
    });

    const mode = 'study';
    const questions = await schedulerService.getQuestionsByMode(mode, mockUser.id, []);

    expect(questions).toHaveLength(0);
  });

  it('should handle API error for Discover mode', async () => {
    (supabase.from as jest.Mock).mockReturnValueOnce({
      select: jest.fn().mockResolvedValue({ data: null, error: 'API error' }),
    });

    const mode = 'discover';
    const questions = await schedulerService.getQuestionsByMode(mode, mockUser.id, []);

    expect(questions).toHaveLength(0);
  });

  it('should handle invalid mode', async () => {
    await expect(schedulerService.getQuestionsByMode('invalid' as 'repeat' | 'study' | 'discover', mockUser.id, []))
      .rejects
      .toThrow('Invalid mode');
  });

  // Test struggle tracking for Repeat mode
  it('should prioritize questions with higher struggle metrics in Repeat mode', () => {
    const questions = mockQuestions.filter(q => q.user_id === mockUser.id);
    const sorted = getRepeatModeQuestions(questions);

    // Verify sorting by struggle metrics
    expect(sorted[0].id).toBe('q6'); // Highest struggleCount (4)
    expect(sorted[1].id).toBe('q4'); // Next highest (3)
    // q8 and q2 should not be included since they don't meet the >=3 threshold
    expect(sorted).toHaveLength(2);
    
    // Verify questions with low ease factor are included
    expect(sorted.some(q => q.reviewEase <= 2.0)).toBe(true);
  });

  // Test full Repeat mode filtering criteria
  it('should include questions with ease < 2.0 OR overdue OR struggleCount >=3', () => {
    const questions = mockQuestions.filter(q => q.user_id === mockUser.id);
    const filtered = getRepeatModeQuestions(questions);
    
    filtered.forEach(q => {
      const isOverdue = q.lastReviewed &&
        ((Date.now() - q.lastReviewed.getTime()) / 86400000) > q.reviewInterval;
      const meetsCriteria = q.reviewEase < 2.0 || isOverdue || q.struggleCount >= 3;
      expect(meetsCriteria).toBe(true);
    });
  });

  it('should exclude questions with only recent struggles', () => {
    const testQuestion = {
      ...mockQuestions[0],
      id: 'test1',
      reviewEase: 2.5,
      struggleCount: 2, // Below threshold
      lastStruggledAt: new Date(), // Recent struggle
    };
    const questions = [...mockQuestions, testQuestion];
    const filtered = getRepeatModeQuestions(questions);
    
    expect(filtered.some(q => q.id === 'test1')).toBe(false);
  });

  // Test time-based decay for Study mode
  it('should select newer questions less frequently in Study mode', () => {
    const studyQueues = getStudyModeQuestions(mockQuestions.filter(q => q.user_id === mockUser.id));

    // New questions should be prioritized
    expect(studyQueues.newQuestions.length).toBeGreaterThan(0);
    expect(studyQueues.newQuestions[0].reviewCount).toBe(0);

    // Recent questions should have low review counts
    expect(studyQueues.recentQuestions.every(q => q.reviewCount > 0)).toBe(true);
  });

  // Test separate queues for new vs. recent questions in Study mode
  it('should handle new and recent questions separately in Study mode', () => {
    const newQuestions = mockQuestions.filter(q => q.user_id === mockUser.id && q.reviewCount === 0);
    const recentQuestions = mockQuestions.filter(q => q.user_id === mockUser.id && q.reviewCount > 0);

    const studyQueues = getStudyModeQuestions(mockQuestions.filter(q => q.user_id === mockUser.id));

    // New questions should be in newQuestions queue
    newQuestions.forEach(newQ => {
      expect(studyQueues.newQuestions.find(q => q.id === newQ.id)).toBeDefined();
    });

    // Recent questions should be in recentQuestions queue
    recentQuestions.forEach(recentQ => {
      expect(studyQueues.recentQuestions.find(q => q.id === recentQ.id)).toBeDefined();
    });
  });

  // Test topic relationship modeling for Discover mode
  it('should group questions by topic in Discover mode', () => {
    const discoverQuestions = getDiscoverModeQuestions(mockQuestions.filter(q => q.user_id === mockUser.id), []);

    // Questions should be grouped by topic
    const topics = new Set(discoverQuestions.map(q => q.topics![0])); // Safe access with non-null assertion
    expect(topics.size).toBeLessThanOrEqual(mockQuestions.length);
  });

  // Test knowledge gap analysis
  it('should identify knowledge gaps correctly', () => {
    const questionPerformance = mockQuestions.reduce((acc, question) => {
      acc[question.id] = {
        correct: question.reviewCount > 0, // Simplified heuristic
        topics: question.topics || [],
      };
      return acc;
    }, {} as Record<string, { correct: boolean, topics: string[] }>);

    const { gaps } = assessmentService.analyzeKnowledgeGaps(questionPerformance);

    // Topics with low performance should be identified as gaps
    expect(gaps).toContain('physics'); // q6 has high struggle but low reviews
    expect(gaps).not.toContain('chemistry'); // q7 has no struggles, good performance
  });

  // Edge case tests
  it('should handle default reviewEase in Repeat mode', () => {
    const edgeQuestions = [...mockQuestions, {
      ...mockQuestions[0],
      id: 'edge1',
      reviewEase: 2.5, // Set default value
    }];

    const questions = getRepeatModeQuestions(edgeQuestions);
    expect(questions.some(q => q.id === 'edge1')).toBe(true);
  });

  it('should handle negative struggleCount in Repeat mode', () => {
    const edgeQuestions = [...mockQuestions, {
      ...mockQuestions[0],
      id: 'edge2',
      struggleCount: -5,
    }];

    const questions = getRepeatModeQuestions(edgeQuestions);
    expect(questions.some(q => q.id === 'edge2')).toBe(false);
  });

  it('should handle very old struggle dates in Repeat mode', () => {
    const edgeQuestions = [...mockQuestions, {
      ...mockQuestions[0],
      id: 'edge3',
      lastStruggledAt: new Date('2000-01-01'),
    }];

    const questions = getRepeatModeQuestions(edgeQuestions);
    expect(questions.some(q => q.id === 'edge3')).toBe(false);
  });

  it('should handle NaN reviewCount in Study mode', () => {
    const edgeQuestions = [...mockQuestions, {
      ...mockQuestions[0],
      id: 'edge4',
      reviewCount: NaN,
    }];

    const { newQuestions, recentQuestions } = getStudyModeQuestions(edgeQuestions);
    expect([...newQuestions, ...recentQuestions].some(q => q.id === 'edge4')).toBe(false);
  });

  it('should handle null lastReviewed in Study mode', () => {
    const edgeQuestions = [...mockQuestions, {
      ...mockQuestions[0],
      id: 'edge5',
      lastReviewed: null,
    }];

    const { newQuestions } = getStudyModeQuestions(edgeQuestions);
    expect(newQuestions.some(q => q.id === 'edge5')).toBe(true);
  });

  it('should handle AI-generated questions without topics in Discover mode', () => {
    const edgeQuestions = [...mockQuestions, {
      ...mockQuestions[0],
      id: 'edge6',
      isAIGenerated: true,
      topics: undefined,
    }];

    const questions = getDiscoverModeQuestions(edgeQuestions, []);
    expect(questions.some(q => q.id === 'edge6')).toBe(true);
  });

  it('should handle empty topics array in Discover mode', () => {
    const edgeQuestions = [...mockQuestions, {
      ...mockQuestions[0],
      id: 'edge7',
      topics: [],
    }];

    const questions = getDiscoverModeQuestions(edgeQuestions, []);
    expect(questions.some(q => q.id === 'edge7')).toBe(false);
  });

  it('should handle invalid topic data types in Discover mode', () => {
    const edgeQuestions = [...mockQuestions, {
      ...mockQuestions[0],
      id: 'edge8',
      topics: [123, true], // Invalid types
    } as unknown as Question]; // Force invalid type

    const questions = getDiscoverModeQuestions(edgeQuestions, []);
    expect(questions.some(q => q.id === 'edge8')).toBe(false);
  });
});
</file>

<file path=".roo/custom_modes.yaml">
customModes:
  - slug: product-manager
    name: Product Manager (The Clarifier)
    roleDefinition: >-
      You are the **Product Manager AI** (📈). Your sole purpose is to transform the user's initial, potentially vague `app_description.md` into a comprehensive and unambiguous `/docs/canonical_spec.md`. You are the source of project truth.
    groups: [read, edit, command, mcp]
    source: global

  - slug: planner
    name: Planner (The Master Planner)
    roleDefinition: >-
      You are the **Planner AI** (🧠). Triggered by a complete specification, you perform a single, upfront planning session to create a 100% complete work breakdown structure for the entire project, stored in `work_breakdown/`.
    groups: [read, edit, command, mcp]
    source: global

  - slug: developer
    name: Developer (The Marathon Runner)
    roleDefinition: >-
      You are the **Developer AI** (👨‍💻). You implement the full project plan by writing code. You operate in a **static-only** mode, meaning you cannot run tests, migrations, or servers, but you can use code generators like 'prisma generate'.
    groups: [read, edit, command, mcp]
    source: global

  - slug: auditor
    name: Auditor (The Gatekeeper)
    roleDefinition: >-
      You are the **Auditor AI** (🔎). You perform a **static-only** audit of the codebase against the spec. You do not run tests. If the audit passes, you generate the final `POST_COMPLETION_GUIDE.md` for the user.
    groups: [read, edit, command, mcp]
    source: global

  - slug: dispatcher
    name: Dispatcher (The Conductor)
    roleDefinition: >-
      You are the **Dispatcher AI** (🤖). You are the master router of the phase-gated factory. You read signals from the `signals/` directory and hand off control to the appropriate specialist for the next phase of work.
    groups: [read, edit, command, mcp]
    source: global

  - slug: emergency
    name: Emergency
    roleDefinition: >-
      You are the **Emergency AI** (🚨). You are a tactical fail-safe. You are triggered by a `NEEDS_ASSISTANCE.md` signal from the Developer. You diagnose the failure, create a `FIX_PLAN.md`, and hand back to the Dispatcher to restart the development phase.
    groups: [read, edit, command, browser, mcp]
    source: global

  - slug: system-supervisor
    name: System Supervisor (Meta-Agent)
    roleDefinition: >-
      You are the **System_Supervisor AI** (👑). You are the meta-agent that fixes the system itself. Triggered by the Dispatcher on infinite loops, you diagnose and rewrite the rules of failing agents to correct the system's logic.
    groups: [read, edit, command, browser, mcp]
    source: global
</file>

<file path="src/app/api/questions/route.test.ts">
import { NextRequest } from 'next/server';
import * as route from './route';
import { prisma } from '@/lib/db';
import { supabase } from '@/lib/supabase';

// Mock Prisma and Supabase
jest.mock('@/lib/db', () => ({
  prisma: {
    question: {
      create: jest.fn(),
      findMany: jest.fn(),
      findUnique: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
    },
  },
}));

jest.mock('@/lib/supabase', () => ({
  supabase: {
    auth: {
      getUser: jest.fn(),
    },
  },
}));

const mockCreate = prisma.question.create as jest.Mock;
const mockFindMany = prisma.question.findMany as jest.Mock;
const mockFindUnique = prisma.question.findUnique as jest.Mock;
const mockUpdate = prisma.question.update as jest.Mock;
const mockDelete = prisma.question.delete as jest.Mock;
const mockGetUser = supabase.auth.getUser as jest.Mock;

describe('CRUD operations for questions', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('POST /api/questions', () => {
    it('should return 401 if unauthorized', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: null },
        error: new Error('Not authenticated'),
      });

      const req = new NextRequest('http://localhost/api/questions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: 'Test question',
          category: 'general',
          difficulty: 'easy',
        }),
      });

      const response = await route.POST(req);
      expect(response.status).toBe(401);
      expect(await response.json()).toEqual({ error: 'Unauthorized' });
    });

    it('should create a new question with valid data', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      const mockQuestion = {
        id: '1',
        content: 'Test question',
        category: 'general',
        difficulty: 'easy',
        userId: 'user-id',
        createdAt: new Date(),
      };
      mockCreate.mockResolvedValue(mockQuestion);

      const req = new NextRequest('http://localhost/api/questions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: 'Test question',
          category: 'general',
          difficulty: 'easy',
        }),
      });

      const response = await route.POST(req);
      expect(response.status).toBe(201);
      const json = await response.json();
      expect(json.id).toBe(mockQuestion.id);
      expect(json.content).toBe(mockQuestion.content);
      expect(json.category).toBe(mockQuestion.category);
      expect(json.difficulty).toBe(mockQuestion.difficulty);
      expect(json.userId).toBe(mockQuestion.userId);
      expect(json.createdAt).toBeDefined();
    });

    it('should return 400 if missing required fields', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      const req = new NextRequest('http://localhost/api/questions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({}),
      });

      const response = await route.POST(req);
      expect(response.status).toBe(400);
      expect(await response.json()).toEqual({ error: 'Missing required fields' });
    });

    it('should return 400 if field types are invalid', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      const req = new NextRequest('http://localhost/api/questions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: 123,
          category: 'general',
          difficulty: 'easy',
        }),
      });

      const response = await route.POST(req);
      expect(response.status).toBe(400);
      expect(await response.json()).toEqual({ error: 'Invalid field types' });
    });

    it('should return 500 on database error', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });
      mockCreate.mockRejectedValue(new Error('Database error'));

      const req = new NextRequest('http://localhost/api/questions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: 'Test question',
          category: 'general',
          difficulty: 'easy',
        }),
      });

      const response = await route.POST(req);
      expect(response.status).toBe(500);
      expect(await response.json()).toEqual({ error: 'Internal server error' });
    });
  });

  describe('GET /api/questions', () => {
    it('should return 401 if unauthorized', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: null },
        error: new Error('Not authenticated'),
      });

      const req = new NextRequest('http://localhost/api/questions', {
        method: 'GET',
      });

      const response = await route.GET(req);
      expect(response.status).toBe(401);
      expect(await response.json()).toEqual({ error: 'Unauthorized' });
    });

    it('should return all questions for the user', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      const mockQuestions = [
        {
          id: '1',
          content: 'Test question 1',
          category: 'general',
          difficulty: 'easy',
          userId: 'user-id',
          createdAt: new Date(),
        },
        {
          id: '2',
          content: 'Test question 2',
          category: 'general',
          difficulty: 'easy',
          userId: 'user-id',
          createdAt: new Date(),
        },
      ];
      mockFindMany.mockResolvedValue(mockQuestions);

      const req = new NextRequest('http://localhost/api/questions', {
        method: 'GET',
      });

      const response = await route.GET(req);
      expect(response.status).toBe(200);
      const json = await response.json();
      expect(json.length).toBe(mockQuestions.length);
      json.forEach((q: any, index: number) => {
        expect(q.id).toBe(mockQuestions[index].id);
        expect(q.content).toBe(mockQuestions[index].content);
        expect(q.category).toBe(mockQuestions[index].category);
        expect(q.difficulty).toBe(mockQuestions[index].difficulty);
        expect(q.userId).toBe(mockQuestions[index].userId);
        expect(q.createdAt).toBeDefined();
      });
    });

    it('should return a single question by ID', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      const mockQuestion = {
        id: '1',
        content: 'Test question',
        category: 'general',
        difficulty: 'easy',
        userId: 'user-id',
        createdAt: new Date(),
      };
      mockFindUnique.mockResolvedValue(mockQuestion);

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'GET',
      });

      const response = await route.GET(req);
      expect(response.status).toBe(200);
      const json = await response.json();
      expect(json.id).toBe(mockQuestion.id);
      expect(json.content).toBe(mockQuestion.content);
      expect(json.category).toBe(mockQuestion.category);
      expect(json.difficulty).toBe(mockQuestion.difficulty);
      expect(json.userId).toBe(mockQuestion.userId);
      expect(json.createdAt).toBeDefined();
    });

    it('should return 404 if question not found', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      mockFindUnique.mockResolvedValue(null);

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'GET',
      });

      const response = await route.GET(req);
      expect(response.status).toBe(404);
      expect(await response.json()).toEqual({ error: 'Question not found' });
    });

    it('should return 500 on database error', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });
      mockFindMany.mockRejectedValue(new Error('Database error'));

      const req = new NextRequest('http://localhost/api/questions', {
        method: 'GET',
      });

      const response = await route.GET(req);
      expect(response.status).toBe(500);
      expect(await response.json()).toEqual({ error: 'Internal server error' });
    });
  });

  describe('PUT /api/questions/[id]', () => {
    it('should return 401 if unauthorized', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: null },
        error: new Error('Not authenticated'),
      });

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: 'Updated question',
        }),
      });

      const response = await route.PUT(req);
      expect(response.status).toBe(401);
      expect(await response.json()).toEqual({ error: 'Unauthorized' });
    });

    it('should update an existing question', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      const mockQuestion = {
        id: '1',
        content: 'Updated question',
        category: 'general',
        difficulty: 'easy',
        userId: 'user-id',
        createdAt: new Date(),
      };
      mockFindUnique.mockResolvedValue(mockQuestion);
      mockUpdate.mockResolvedValue(mockQuestion);

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: 'Updated question',
        }),
      });

      const response = await route.PUT(req);
      expect(response.status).toBe(200);
      const json = await response.json();
      expect(json.id).toBe(mockQuestion.id);
      expect(json.content).toBe(mockQuestion.content);
      expect(json.category).toBe(mockQuestion.category);
      expect(json.difficulty).toBe(mockQuestion.difficulty);
      expect(json.userId).toBe(mockQuestion.userId);
      expect(json.createdAt).toBeDefined();
    });

    it('should return 404 if question not found', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      mockFindUnique.mockResolvedValue(null);

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: 'Updated question',
        }),
      });

      const response = await route.PUT(req);
      expect(response.status).toBe(404);
      expect(await response.json()).toEqual({ error: 'Question not found' });
    });

    it('should return 400 if missing required fields', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({}),
      });

      const response = await route.PUT(req);
      expect(response.status).toBe(400);
      expect(await response.json()).toEqual({ error: 'Missing required fields' });
    });

    it('should return 500 on database error', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });
      mockFindUnique.mockResolvedValue({
        id: '1',
        userId: 'user-id',
      });
      mockUpdate.mockRejectedValue(new Error('Database error'));

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: 'Updated question',
        }),
      });

      const response = await route.PUT(req);
      expect(response.status).toBe(500);
      expect(await response.json()).toEqual({ error: 'Internal server error' });
    });
  });

  describe('DELETE /api/questions/[id]', () => {
    it('should return 401 if unauthorized', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: null },
        error: new Error('Not authenticated'),
      });

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'DELETE',
      });

      const response = await route.DELETE(req);
      expect(response.status).toBe(401);
      expect(await response.json()).toEqual({ error: 'Unauthorized' });
    });

    it('should delete an existing question', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      const mockQuestion = {
        id: '1',
        content: 'Test question',
        category: 'general',
        difficulty: 'easy',
        userId: 'user-id',
        createdAt: new Date(),
      };
      mockFindUnique.mockResolvedValue(mockQuestion);
      mockDelete.mockResolvedValue(undefined);

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'DELETE',
      });

      const response = await route.DELETE(req);
      expect(response.status).toBe(200);
      expect(await response.json()).toEqual({ message: 'Question deleted successfully' });
    });

    it('should return 404 if question not found', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });

      mockFindUnique.mockResolvedValue(null);

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'DELETE',
      });

      const response = await route.DELETE(req);
      expect(response.status).toBe(404);
      expect(await response.json()).toEqual({ error: 'Question not found' });
    });

    it('should return 500 on database error', async () => {
      mockGetUser.mockResolvedValue({
        data: { user: { id: 'user-id' } },
        error: null,
      });
      mockFindUnique.mockResolvedValue({
        id: '1',
        userId: 'user-id',
      });
      mockDelete.mockRejectedValue(new Error('Database error'));

      const req = new NextRequest('http://localhost/api/questions/1', {
        method: 'DELETE',
      });

      const response = await route.DELETE(req);
      expect(response.status).toBe(500);
      expect(await response.json()).toEqual({ error: 'Internal server error' });
    });
  });
});
</file>

<file path="src/lib/scheduler.ts">
import { Question, calculateNextReview, updateQuestionAfterReview } from './srs';
import { supabase } from './supabase';

export interface SchedulerService {
  getQuestionsDueForReview: (table: 'questions' | 'flashcards') => Promise<Question[]>;
  markQuestionAsReviewed: (table: 'questions' | 'flashcards', questionId: string, remembered: boolean) => Promise<void>;
  getNextReviewDates: (table: 'questions' | 'flashcards', questionIds: string[]) => Promise<{ [questionId: string]: Date }>;
  getQuestionsByMode: (mode: 'repeat' | 'study' | 'discover', userId: string, userQuestions: string[]) => Promise<Question[]>;
}

export const createSchedulerService = (): SchedulerService => {
  const getQuestionsDueForReview = async (table: 'questions' | 'flashcards' = 'questions'): Promise<Question[]> => {
    const { data, error } = await supabase
      .from(table)
      .select('id, created_at, last_reviewed, review_interval, review_ease, struggle_count, last_struggled_at, total_struggle_time, review_count')
      .order('last_reviewed', { ascending: false });

    if (error) {
      console.error(`Error fetching ${table}:`, error);
      return [];
    }

    if (!data) return [];

    const questions = data.map(item => ({
      id: item.id,
      createdAt: new Date(item.created_at),
      lastReviewed: item.last_reviewed ? new Date(item.last_reviewed) : null,
      reviewInterval: item.review_interval,
      reviewEase: item.review_ease,
      struggleCount: item.struggle_count || 0,
      lastStruggledAt: item.last_struggled_at ? new Date(item.last_struggled_at) : null,
      totalStruggleTime: item.total_struggle_time || 0,
      reviewCount: item.review_count || 0,
    }));

    // Filter and sort questions by overdue priority
    return questions
      .filter(item => {
        const { daysUntilReview } = calculateNextReview(item);
        return daysUntilReview === 0;
      })
      .sort((a, b) => {
        // Calculate overdue days for both questions
        const aOverdue = a.lastReviewed
          ? (Date.now() - a.lastReviewed.getTime()) / (1000 * 60 * 60 * 24) - a.reviewInterval
          : Infinity;
        const bOverdue = b.lastReviewed
          ? (Date.now() - b.lastReviewed.getTime()) / (1000 * 60 * 60 * 24) - b.reviewInterval
          : Infinity;

        // Combine overdue days with struggle count for priority score
        const aPriority = aOverdue * 2 + a.struggleCount;
        const bPriority = bOverdue * 2 + b.struggleCount;

        return bPriority - aPriority; // Sort descending
      });
  };

  const markQuestionAsReviewed = async (table: 'questions' | 'flashcards', questionId: string, remembered: boolean): Promise<void> => {
    const { data: itemData, error: fetchError } = await supabase
      .from(table)
      .select('id, created_at, last_reviewed, review_interval, review_ease, struggle_count, last_struggled_at, total_struggle_time, review_count')
      .eq('id', questionId)
      .single();

    if (fetchError || !itemData) {
      console.error(`Error fetching ${table} item:`, fetchError);
      return;
    }

    const updatedItem = updateQuestionAfterReview({
      id: questionId,
      createdAt: new Date(itemData.created_at),
      lastReviewed: itemData.last_reviewed ? new Date(itemData.last_reviewed) : null,
      reviewInterval: itemData.review_interval,
      reviewEase: itemData.review_ease,
      struggleCount: itemData.struggle_count || 0,
      lastStruggledAt: itemData.last_struggled_at ? new Date(itemData.last_struggled_at) : null,
      totalStruggleTime: itemData.total_struggle_time || 0,
      reviewCount: itemData.review_count || 0,
    }, remembered, 0);

    const { error: updateError } = await supabase
      .from(table)
      .update({
        last_reviewed: updatedItem.lastReviewed,
        review_interval: updatedItem.reviewInterval,
        review_ease: updatedItem.reviewEase,
      })
      .eq('id', questionId);

    if (updateError) {
      console.error(`Error updating ${table} item:`, updateError);
    }
  };

  const getNextReviewDates = async (table: 'questions' | 'flashcards', questionIds: string[]): Promise<{ [questionId: string]: Date }> => {
    const { data, error } = await supabase
      .from(table)
      .select('id, last_reviewed, review_interval, review_ease, created_at, struggle_count, last_struggled_at, total_struggle_time, review_count')
      .in('id', questionIds);

    if (error) {
      console.error(`Error fetching ${table}:`, error);
      return {};
    }

    if (!data) return {};

    const nextReviewDates: { [questionId: string]: Date } = {};

    data.forEach(item => {
      const { daysUntilReview } = calculateNextReview({
        id: item.id,
        createdAt: new Date(item.created_at),
        lastReviewed: item.last_reviewed ? new Date(item.last_reviewed) : null,
        reviewInterval: item.review_interval,
        reviewEase: item.review_ease,
        struggleCount: item.struggle_count || 0,
        lastStruggledAt: item.last_struggled_at ? new Date(item.last_struggled_at) : null,
        totalStruggleTime: item.total_struggle_time || 0,
        reviewCount: item.review_count || 0,
      });

      const nextReview = new Date();
      nextReview.setDate(nextReview.getDate() + daysUntilReview);
      nextReviewDates[item.id] = nextReview;
    });

    return nextReviewDates;
  };

  const getQuestionsByMode = async (mode: 'repeat' | 'study' | 'discover', userId: string, userQuestions: string[]): Promise<Question[]> => {
    const { data, error } = await supabase
      .from('questions')
      .select('id, created_at, last_reviewed, review_interval, review_ease, struggle_count, last_struggled_at, total_struggle_time, review_count')
      .eq('userId', userId);

    if (error) {
      console.error('Error fetching questions:', error);
      return [];
    }

    if (!data) return [];

    const questions = data.map(item => ({
      id: item.id,
      createdAt: new Date(item.created_at),
      lastReviewed: item.last_reviewed ? new Date(item.last_reviewed) : null,
      reviewInterval: item.review_interval,
      reviewEase: item.review_ease,
      struggleCount: item.struggle_count || 0,
      lastStruggledAt: item.last_struggled_at ? new Date(item.last_struggled_at) : null,
      totalStruggleTime: item.total_struggle_time || 0,
      reviewCount: item.review_count || 0,
    }));

    let filteredQuestions;
    switch (mode) {
      case 'repeat':
        filteredQuestions = questions.filter(q => {
          const isHighStruggle = q.struggleCount > 2;
          const recentStruggle = q.lastStruggledAt
            ? (Date.now() - q.lastStruggledAt.getTime()) < 7 * 24 * 60 * 60 * 1000
            : false;
          return q.reviewEase <= 2.0 || !q.lastReviewed || isHighStruggle || recentStruggle;
        }).sort((a, b) => {
          // Calculate priority scores based on struggle metrics
          const aScore = (a.struggleCount * 2) +
            (a.lastStruggledAt ? (1 / (Date.now() - a.lastStruggledAt.getTime())) : 0) +
            (a.totalStruggleTime / 1000);
          const bScore = (b.struggleCount * 2) +
            (b.lastStruggledAt ? (1 / (Date.now() - b.lastStruggledAt.getTime())) : 0) +
            (b.totalStruggleTime / 1000);
          return bScore - aScore; // Higher scores first
        });
        break;
      case 'study':
        filteredQuestions = questions.filter(q => {
          if (!q.lastReviewed) return true; // New questions always included
          if (q.reviewCount <= 3) return true; // Low review count questions included

          // Apply time-based decay: reduce probability for older questions
          const daysSinceLastReview = (new Date().getTime() - q.lastReviewed.getTime()) / (1000 * 60 * 60 * 24);
          const decayFactor = Math.max(0, 1 - (daysSinceLastReview / (q.reviewInterval * 2)));

          // Random selection with decay factor
          return Math.random() < decayFactor;
        });
        break;
      case 'discover':
        filteredQuestions = questions.filter(q => !userQuestions.includes(q.id));
        break;
      default:
        throw new Error('Invalid mode');
    }

    return filteredQuestions;
  };

  return {
    getQuestionsDueForReview,
    markQuestionAsReviewed,
    getNextReviewDates,
    getQuestionsByMode,
  };
};

export const schedulerService = createSchedulerService();
</file>

<file path="src/app/api/questions/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { supabase } from '@/lib/supabase';

export async function GET(req: NextRequest) {
  try {
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const url = new URL(req.url);
    const pathParts = url.pathname.replace(/\/$/, "").split('/');
    const lastPart = pathParts.pop();

    if (lastPart && lastPart !== 'questions') {
      const id = lastPart;
      // Get single question by ID
      const question = await prisma.question.findUnique({
        where: { id },
      });

      if (!question || question.userId !== user.id) {
        return NextResponse.json({ error: 'Question not found' }, { status: 404 });
      }

      return NextResponse.json(question);
    } else {
      // Get all questions for the user
      const questions = await prisma.question.findMany({
        where: { userId: user.id },
        orderBy: { createdAt: 'desc' },
      });

      return NextResponse.json(questions);
    }
  } catch (error: unknown) {
    if (error instanceof Error) {
      console.error('Database Error:', error.message);
    } else {
      console.error('Unknown Error:', error);
    }
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

/**
 * GET /api/questions/mode
 * Returns questions filtered by SRS mode
 */
export async function GET_MODE(req: NextRequest) {
  try {
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const url = new URL(req.url);
    const mode = url.searchParams.get('mode');
    const userQuestions = url.searchParams.get('userQuestions') ? JSON.parse(url.searchParams.get('userQuestions')!) : [];

    if (!mode) {
      return NextResponse.json({ error: 'Mode parameter is required' }, { status: 400 });
    }

    const questions = await prisma.question.findMany({
      where: { userId: user.id },
    });

    let filteredQuestions;
    switch (mode) {
      case 'repeat':
        filteredQuestions = questions.filter(q => q.reviewEase <= 2.0 || q.lastReviewed === null);
        break;
      case 'study':
        filteredQuestions = questions.filter(q => {
          if (!q.lastReviewed) return true;
          const daysSinceCreated = (new Date().getTime() - q.createdAt.getTime()) / (1000 * 60 * 60 * 24);
          const approxReviews = daysSinceCreated / q.reviewInterval;
          return approxReviews <= 3;
        });
        break;
      case 'discover':
        filteredQuestions = questions.filter(q => !userQuestions.includes(q.id));
        break;
      default:
        return NextResponse.json({ error: 'Invalid mode' }, { status: 400 });
    }

    return NextResponse.json(filteredQuestions);
  } catch (error: unknown) {
    if (error instanceof Error) {
      console.error('Database Error:', error.message);
    } else {
      console.error('Unknown Error:', error);
    }
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();

    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    if (!body || typeof body !== 'object') {
      return NextResponse.json({ error: 'Invalid request body' }, { status: 400 });
    }

    const { content, category, difficulty } = body;

    if (!content || !category || !difficulty) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    if (typeof content !== 'string' ||
        typeof category !== 'string' ||
        typeof difficulty !== 'string') {
      return NextResponse.json({ error: 'Invalid field types' }, { status: 400 });
    }

    const question = await prisma.question.create({
      data: {
        content: content.trim(),
        category: category.trim(),
        difficulty: difficulty.trim(),
        userId: user.id,
      },
    });

    return NextResponse.json(question, { status: 201 });
  } catch (error: unknown) {
    if (error instanceof SyntaxError) {
      return NextResponse.json({ error: 'Invalid JSON body' }, { status: 400 });
    }
    if (error instanceof Error) {
      console.error('Database Error:', error.message);
    } else {
      console.error('Unknown Error:', error);
    }
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

export async function PUT(req: NextRequest) {
  try {
    const body = await req.json();
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const url = new URL(req.url);
    const pathParts = url.pathname.replace(/\/$/, "").split('/');
    const id = pathParts.pop();

    if (!id || id === 'questions') {
      return NextResponse.json({ error: 'Question ID is required' }, { status: 400 });
    }

    if (!body || typeof body !== 'object') {
      return NextResponse.json({ error: 'Invalid request body' }, { status: 400 });
    }

    const { content, category, difficulty } = body;

    if (!content && !category && !difficulty) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    if ((content && typeof content !== 'string') ||
        (category && typeof category !== 'string') ||
        (difficulty && typeof difficulty !== 'string')) {
      return NextResponse.json({ error: 'Invalid field types' }, { status: 400 });
    }

    const question = await prisma.question.findUnique({
      where: { id },
    });

    if (!question || question.userId !== user.id) {
      return NextResponse.json({ error: 'Question not found' }, { status: 404 });
    }

    const updatedQuestion = await prisma.question.update({
      where: { id },
      data: {
        ...(content !== undefined && { content: content.trim() }),
        ...(category !== undefined && { category: category.trim() }),
        ...(difficulty !== undefined && { difficulty: difficulty.trim() }),
      },
    });

    return NextResponse.json(updatedQuestion);
  } catch (error: unknown) {
    if (error instanceof SyntaxError) {
      return NextResponse.json({ error: 'Invalid JSON body' }, { status: 400 });
    }
    if (error instanceof Error) {
      console.error('Database Error:', error.message);
    } else {
      console.error('Unknown Error:', error);
    }
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

export async function DELETE(req: NextRequest) {
  try {
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const url = new URL(req.url);
    const pathParts = url.pathname.replace(/\/$/, "").split('/');
    const id = pathParts.pop();

    if (!id || id === 'questions') {
      return NextResponse.json({ error: 'Question ID is required' }, { status: 400 });
    }

    const question = await prisma.question.findUnique({
      where: { id },
    });

    if (!question || question.userId !== user.id) {
      return NextResponse.json({ error: 'Question not found' }, { status: 404 });
    }

    await prisma.question.delete({
      where: { id },
    });

    return NextResponse.json({ message: 'Question deleted successfully' });
  } catch (error: unknown) {
    if (error instanceof Error) {
      console.error('Database Error:', error.message);
    } else {
      console.error('Unknown Error:', error);
    }
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
</file>

<file path="package.json">
{
  "name": "prepai",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "jest"
  },
  "dependencies": {
    "@prisma/client": "^6.9.0",
    "@supabase/auth-helpers-nextjs": "^0.10.0",
    "@supabase/supabase-js": "^2.50.0",
    "@testing-library/jest-dom": "^6.6.3",
    "@types/chart.js": "^2.9.41",
    "chart.js": "^4.5.0",
    "date-fns": "^3.6.0",
    "jspdf": "^2.5.1",
    "jspdf-autotable": "^3.5.6",
    "next": "^15.3.3",
    "next-auth": "^4.24.5",
    "openai": "^5.5.1",
    "react": "^19.0.0",
    "react-chartjs-2": "^5.3.0",
    "react-dom": "^19.0.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@eslint/js": "^9.29.0",
    "@supabase/ssr": "^0.6.1",
    "@tailwindcss/postcss": "^4",
    "@types/jest": "^29.5.12",
    "@types/next": "^8.0.7",
    "@types/node": "^20.19.1",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.29.0",
    "eslint-config-next": "15.3.3",
    "eslint-config-prettier": "^10.1.5",
    "eslint-plugin-prettier": "^5.4.1",
    "eslint-plugin-react": "^7.37.5",
    "globals": "^16.2.0",
    "jest": "^29.7.0",
    "node-mocks-http": "^1.17.2",
    "postcss": "^8.5.6",
    "prettier": "^3.5.3",
    "tailwindcss": "^4.1.10",
    "ts-jest": "^29.1.2",
    "typescript": "^5",
    "typescript-eslint": "^8.34.1"
  }
}
</file>

<file path=".roo/rules-developer/rules.md">
## 1. IDENTITY & PERSONA
You are the **Developer AI** (👨‍💻 The Resilient Runner). You are a highly efficient specialist who implements the project task by task. You are also self-aware: you monitor your own progress, recognize when you are stuck, and know when to ask for help instead of repeating a failing approach. Your work is purely static; you write code, you do not run it.

## 2. THE CORE MISSION & TRIGGER
Your mission is to execute all tasks outlined in the files under `work_breakdown/tasks/`. You are triggered by the Dispatcher when `signals/PLANNING_COMPLETE.md` exists, or when incomplete tasks are detected and the system hands control back to you.

## 3. EXECUTION CONSTRAINTS
*   **Static Generation Only:** You are **strictly forbidden** from executing runtime commands (e.g., `npm test`, `docker-compose up`).
*   **Permitted Commands:** You **are permitted** to run static code generation tools like `prisma generate`. You should consider a successful run of such tools as a "unit test" for your implementation.
*   **Environment Variables:** You **must** create `.env.example` and a placeholder `.env` file.

## 4. THE IMPLEMENTATION MARATHON (WITH SELF-CORRECTION)

1.  **Acknowledge & Set Up:**
    *   Announce: "Implementation marathon beginning. Adhering to static-only generation and self-correction protocols."
    *   If `signals/PLANNING_COMPLETE.md` exists, consume it.

2.  **The Outer Loop: Task Selection**
    *   This loop continues until **every task in every file** under `work_breakdown/tasks/` is marked complete `[x]`.
    *   **STEP 1: Find Next Task.**
        *   Scan all `.md` files in `work_breakdown/tasks/` for the first available incomplete task `[ ]`.
        *   If no incomplete tasks are found, proceed to Step 4 (Announce & Handoff).
        *   If a task is found, store its file path and description. Now, enter the Inner Loop.

3.  **The Inner Loop: Task Execution & Self-Questioning**
    *   Initialize an attempt counter for the current task: `attempts = 0`. Set `MAX_ATTEMPTS = 3`.
    *   **While `attempts < MAX_ATTEMPTS`:**
        *   **A. Self-Question (Before Attempt):**
            *   `attempts = attempts + 1`
            *   "This is attempt [attempts] for task: '[task description]'. My strategy is to [describe implementation plan]."
        *   **B. Execute:**
            *   Implement the code required to complete the task.
        *   **C. Self-Verify:**
            *   Run any relevant static analysis or generation commands (e.g., `prisma generate`).
            *   If the commands succeed and you believe the code fulfills the task, the attempt is successful. Break this inner loop and proceed to Step D.
            *   If the commands fail, the attempt has failed.
        *   **D. Self-Question (After Failure):**
            *   "Attempt [attempts] failed with error: [error message]. Is this a simple typo, or is my approach flawed? I will re-read the plan and try a different implementation strategy."
            *   (The loop will then repeat for the next attempt).
    *   **After the Inner Loop:**
        *   **If the attempt was successful:**
            *   Announce: "Task completed successfully."
            *   Commit the changes (`git add . && git commit -m "..."`).
            *   Update the plan file by marking the task `[x]`.
            *   **Return to the Outer Loop (Step 1)** to find the next task.
        *   **If `attempts` reached `MAX_ATTEMPTS` (you are stuck):**
            *   HALT the marathon.
            *   Go to the Failure Protocol (Step 5).

4.  **Announce & Handoff (Only when ALL tasks are complete):**
    *   Create `signals/IMPLEMENTATION_COMPLETE.md`.
    *   Announce: "Implementation marathon complete. All tasks in all plan files are finished. The codebase is ready for a holistic audit."
    *   Switch mode to `<mode>dispatcher</mode>`.

5.  **FAILURE PROTOCOL (When Stuck)**
    *   Announce: "I have failed to complete a task after [MAX_ATTEMPTS] attempts. I am stuck and require assistance."
    *   Create `signals/NEEDS_ASSISTANCE.md`. The content of this file **must** include:
        *   The task description that failed.
        *   The file path of the plan.
        *   A summary of the failed approaches.
        *   The final error message received.
    *   Hand off to the Dispatcher by switching to `<mode>dispatcher</mode>`.
    *   Do **not** create the `IMPLEMENTATION_COMPLETE.md` signal.
</file>

<file path="src/lib/srs.ts">
export interface Question {
  id: string;
  createdAt: Date;
  lastReviewed: Date | null;
  reviewInterval: number;
  reviewEase: number;
  struggleCount: number;
  lastStruggledAt: Date | null;
  totalStruggleTime: number;
  reviewCount: number;
  question: string;
  answer: string;
  rating: 'easy' | 'normal' | 'hard';
  user_id: string;
  topics?: string[];
  isAIGenerated?: boolean;
}

export const calculateNextReview = (question: Question): { daysUntilReview: number, newInterval: number, newEase: number } => {
  const now = new Date();
  const timeSinceLastReview = question.lastReviewed
    ? now.getTime() - question.lastReviewed.getTime()
    : 0;

  // If this is the first review, set initial values
  if (!question.lastReviewed) {
    return {
      daysUntilReview: 1,
      newInterval: 1,
      newEase: 2.5,
    };
  }

  // Calculate days since last review
  const daysSinceLastReview = timeSinceLastReview / (1000 * 60 * 60 * 24);

  // If it's time for review, update the interval and ease
  if (daysSinceLastReview >= question.reviewInterval) {
    // Update ease factor based on whether the user remembered the answer
    // For simplicity, we'll assume a default ease factor update
    // In a real system, this would be based on user performance
    const newEase = Math.min(question.reviewEase + 0.1, 3.0);

    // Calculate base interval using SM2 algorithm
    const baseInterval = daysSinceLastReview * newEase;
    
    // Apply struggle factor - reduces interval for high struggle questions
    const struggleFactor = Math.max(0.5, 1 - (question.struggleCount * 0.1));
    const adjustedInterval = baseInterval * struggleFactor;
  
    const newInterval = Math.ceil(
      Math.max(1, adjustedInterval)
    );

    return {
      daysUntilReview: 0, // Ready for review now
      newInterval,
      newEase,
    };
  } else {
    // Not time for review yet
    return {
      daysUntilReview: question.reviewInterval - daysSinceLastReview,
      newInterval: question.reviewInterval,
      newEase: question.reviewEase,
    };
  }
};

export const getQuestionsDueForReview = (questions: Question[]): Question[] => {
  return questions.filter(question => {
    const { daysUntilReview } = calculateNextReview(question);
    return daysUntilReview === 0;
  });
};

/**
 * Get questions for Repeat mode (low ease, overdue, or high struggle)
 * @param questions - Array of questions to filter
 * @param easeThreshold - Maximum ease factor to consider for repeat (default: 2.0)
 * @param struggleThreshold - Minimum struggle count to consider (default: 3)
 * @returns Filtered list of questions needing reinforcement
 */
const calculateQuestionWeight = (question: Question): number => {
  const easeFactor = Math.max(1.3, question.reviewEase);
  
  // Calculate time since last struggle (in days)
  const daysSinceLastStruggle = question.lastStruggledAt
    ? (Date.now() - question.lastStruggledAt.getTime()) / (1000 * 60 * 60 * 24)
    : Infinity;
  
  // Recent struggles get higher weight
  const recencyFactor = daysSinceLastStruggle < 7
    ? 1 + (7 - daysSinceLastStruggle) * 0.2
    : 1;

  // Total struggle time contributes to weight
  const timeFactor = Math.log(question.totalStruggleTime / 1000 + 1) * 0.5;

  // Combine factors for final weight
  return (
    (Math.log(question.struggleCount + 1) * 2) * recencyFactor +
    timeFactor
  ) / easeFactor;
};

export const getRepeatModeQuestions = (
  questions: Question[],
  easeThreshold = 2.0,
  struggleThreshold = 3
): Question[] => {
  try {
    if (!questions?.length) {
      return [];
    }

    // First filter questions that need review
    const filtered = questions.filter(question => {
      const { daysUntilReview } = calculateNextReview(question);
      
      return daysUntilReview === 0 ||
             question.reviewEase <= easeThreshold ||
             question.struggleCount >= struggleThreshold;
    });

    // Then sort by calculated weight (descending)
    return filtered.sort((a, b) => {
      const weightA = calculateQuestionWeight(a);
      const weightB = calculateQuestionWeight(b);
      return weightB - weightA;
    });
  } catch (error) {
    console.error('Error in getRepeatModeQuestions:', error);
    throw new Error('Failed to get repeat mode questions');
  }
};

/**
 * Get questions for Study mode (new or recently added)
 * @param questions - Array of questions to filter
 * @param reviewThreshold - Maximum number of reviews to consider as "new" (default: 3)
 * @returns Filtered list of questions for new learning
 */
export interface StudyModeQueues {
  newQuestions: Question[];
  recentQuestions: Question[];
}

export const getStudyModeQuestions = (questions: Question[], reviewThreshold = 3): StudyModeQueues => {
  try {
    if (!questions?.length) {
      return { newQuestions: [], recentQuestions: [] };
    }

    const newQuestions = questions.filter(q => q.reviewCount === 0);
    const recentQuestions = questions.filter(q => {
      return q.reviewCount > 0 && q.reviewCount <= reviewThreshold;
    });

    return {
      newQuestions,
      recentQuestions
    };
  } catch (error) {
    console.error('Error in getStudyModeQuestions:', error);
    throw new Error('Failed to get study mode questions');
  }
};

/**
 * Calculate similarity between two sets of topics
 * @param topicsA - Topics from first question
 * @param topicsB - Topics from second question
 * @returns Similarity score (0-1)
 */
const calculateTopicSimilarity = (topicsA: string[], topicsB: string[]): number => {
  if (topicsA.length === 0 || topicsB.length === 0) return 0;

  const intersection = topicsA.filter(topic => topicsB.includes(topic));
  return intersection.length / Math.max(topicsA.length, topicsB.length);
};

/**
 * Get questions for Discover mode (potential new questions)
 * @param questions - Array of questions to filter
 * @param userQuestions - IDs of questions already in user's queue
 * @param currentTopics - Topics from currently active questions
 * @returns Filtered list of questions for discovery, sorted by relevance
 */
export const getDiscoverModeQuestions = (questions: Question[], userQuestions: string[], currentTopics: string[] = []): Question[] => {
  try {
    if (!questions?.length) {
      return [];
    }

    return questions
      .filter(question => {
        // Exclude questions already in user's queue
        if (userQuestions.includes(question.id)) return false;

        // Include questions with some topic overlap if they have topics
        if (!question.topics || question.topics.length === 0) return false;

        return question.isAIGenerated ||
          (question.topics && calculateTopicSimilarity(question.topics, currentTopics) > 0);
      })
      .sort((a, b) => {
        // Sort by topic similarity (descending)
        const similarityA = calculateTopicSimilarity(a.topics || [], currentTopics);
        const similarityB = calculateTopicSimilarity(b.topics || [], currentTopics);
        return similarityB - similarityA;
      });
  } catch (error) {
    console.error('Error in getDiscoverModeQuestions:', error);
    throw new Error('Failed to get discover mode questions');
  }
};

export const updateQuestionAfterReview = (question: Question, remembered: boolean, timeSpent = 0): Question => {
  const { newInterval, newEase } = calculateNextReview(question);

  // Adjust interval and ease based on whether the user remembered the answer
  let adjustedInterval = newInterval;
  let adjustedEase = newEase;
  let struggleCount = question.struggleCount;
  let lastStruggledAt = question.lastStruggledAt;
  let totalStruggleTime = question.totalStruggleTime;

  if (!remembered) {
    // If user didn't remember, update struggle metrics
    struggleCount += 1;
    lastStruggledAt = new Date();
    totalStruggleTime += timeSpent;

    // Adjust interval and ease more aggressively based on struggle history
    const strugglePenalty = 1 + (question.struggleCount * 0.2);
    adjustedInterval = Math.max(1, Math.ceil(newInterval / strugglePenalty));
    adjustedEase = Math.max(1.3, newEase - (0.2 * strugglePenalty));
  } else {
    // If user remembered, improve metrics slightly
    adjustedInterval = Math.ceil(newInterval * 1.1);
    adjustedEase = Math.min(3.0, newEase + 0.1);
  }

  return {
    ...question,
    lastReviewed: new Date(),
    reviewInterval: adjustedInterval,
    reviewEase: adjustedEase,
    struggleCount,
    lastStruggledAt,
    totalStruggleTime,
    reviewCount: question.reviewCount + 1,
  };
};

/**
 * Get questions by mode, ensuring consistent array return type
 * @param mode - SRS mode (repeat/study/discover)
 * @param questions - All available questions
 * @param userQuestions - Questions in user's queue (for discover mode)
 * @param currentTopics - Current active topics (for discover mode)
 * @returns Array of questions for the specified mode (empty array if none)
 */
export const getQuestionsByMode = (
  mode: 'repeat' | 'study' | 'discover',
  questions: Question[],
  userQuestions?: string[],
  currentTopics?: string[]
): Question[] => {
  try {
    switch(mode) {
      case 'repeat':
        return getRepeatModeQuestions(questions);
      case 'study': {
        const { newQuestions, recentQuestions } = getStudyModeQuestions(questions);
        return [...newQuestions, ...recentQuestions];
      }
      case 'discover':
        return getDiscoverModeQuestions(questions, userQuestions || [], currentTopics || []);
      default:
        return [];
    }
  } catch (error) {
    console.error(`Error getting questions for mode ${mode}:`, error);
    return [];
  }
};
</file>

</files>
